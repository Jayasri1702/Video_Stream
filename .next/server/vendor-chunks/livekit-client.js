"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RoomState: () => (/* binding */ RoomState),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== \"default\" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(module) {\n    (function(root, definition) {\n        if (module.exports) {\n            module.exports = definition();\n        } else {\n            root.log = definition();\n        }\n    })(commonjsGlobal, function() {\n        // Slightly dubious tricks to cut down minimized file size\n        var noop = function() {};\n        var undefinedType = \"undefined\";\n        var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n        var logMethods = [\n            \"trace\",\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\"\n        ];\n        // Cross-browser bind equivalent that works at least back to IE6\n        function bindMethod(obj, methodName) {\n            var method = obj[methodName];\n            if (typeof method.bind === \"function\") {\n                return method.bind(obj);\n            } else {\n                try {\n                    return Function.prototype.bind.call(method, obj);\n                } catch (e) {\n                    // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                    return function() {\n                        return Function.prototype.apply.apply(method, [\n                            obj,\n                            arguments\n                        ]);\n                    };\n                }\n            }\n        }\n        // Trace() doesn't print the message in IE, so for that case we need to wrap it\n        function traceForIE() {\n            if (console.log) {\n                if (console.log.apply) {\n                    console.log.apply(console, arguments);\n                } else {\n                    // In old IE, native console methods themselves don't have apply().\n                    Function.prototype.apply.apply(console.log, [\n                        console,\n                        arguments\n                    ]);\n                }\n            }\n            if (console.trace) console.trace();\n        }\n        // Build the best logging method possible for this env\n        // Wherever possible we want to bind, not wrap, to preserve stack traces\n        function realMethod(methodName) {\n            if (methodName === \"debug\") {\n                methodName = \"log\";\n            }\n            if (typeof console === undefinedType) {\n                return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n            } else if (methodName === \"trace\" && isIE) {\n                return traceForIE;\n            } else if (console[methodName] !== undefined) {\n                return bindMethod(console, methodName);\n            } else if (console.log !== undefined) {\n                return bindMethod(console, \"log\");\n            } else {\n                return noop;\n            }\n        }\n        // These private functions always need `this` to be set properly\n        function replaceLoggingMethods(level, loggerName) {\n            /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n                var methodName = logMethods[i];\n                this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n            }\n            // Define log.log as an alias for log.debug\n            this.log = this.debug;\n        }\n        // In old IE versions, the console isn't present until you first open it.\n        // We build realMethod() replacements here that regenerate logging methods\n        function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n            return function() {\n                if (typeof console !== undefinedType) {\n                    replaceLoggingMethods.call(this, level, loggerName);\n                    this[methodName].apply(this, arguments);\n                }\n            };\n        }\n        // By default, we use closely bound real methods wherever possible, and\n        // otherwise we wait for a console to appear, and then try again.\n        function defaultMethodFactory(methodName, level, loggerName) {\n            /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n        }\n        function Logger(name, defaultLevel, factory) {\n            var self1 = this;\n            var currentLevel;\n            defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n            var storageKey = \"loglevel\";\n            if (typeof name === \"string\") {\n                storageKey += \":\" + name;\n            } else if (typeof name === \"symbol\") {\n                storageKey = undefined;\n            }\n            function persistLevelIfPossible(levelNum) {\n                var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage[storageKey] = levelName;\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                } catch (ignore) {}\n            }\n            function getPersistedLevel() {\n                var storedLevel;\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                try {\n                    storedLevel = window.localStorage[storageKey];\n                } catch (ignore) {}\n                // Fallback to cookies if local storage gives us nothing\n                if (typeof storedLevel === undefinedType) {\n                    try {\n                        var cookie = window.document.cookie;\n                        var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                        if (location !== -1) {\n                            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                        }\n                    } catch (ignore) {}\n                }\n                // If the stored level is not valid, treat it as if nothing was stored.\n                if (self1.levels[storedLevel] === undefined) {\n                    storedLevel = undefined;\n                }\n                return storedLevel;\n            }\n            function clearPersistedLevel() {\n                if (\"undefined\" === undefinedType || !storageKey) return;\n                // Use localStorage if available\n                try {\n                    window.localStorage.removeItem(storageKey);\n                    return;\n                } catch (ignore) {}\n                // Use session cookie as fallback\n                try {\n                    window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                } catch (ignore) {}\n            }\n            /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self1.name = name;\n            self1.levels = {\n                \"TRACE\": 0,\n                \"DEBUG\": 1,\n                \"INFO\": 2,\n                \"WARN\": 3,\n                \"ERROR\": 4,\n                \"SILENT\": 5\n            };\n            self1.methodFactory = factory || defaultMethodFactory;\n            self1.getLevel = function() {\n                return currentLevel;\n            };\n            self1.setLevel = function(level, persist) {\n                if (typeof level === \"string\" && self1.levels[level.toUpperCase()] !== undefined) {\n                    level = self1.levels[level.toUpperCase()];\n                }\n                if (typeof level === \"number\" && level >= 0 && level <= self1.levels.SILENT) {\n                    currentLevel = level;\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(level);\n                    }\n                    replaceLoggingMethods.call(self1, level, name);\n                    if (typeof console === undefinedType && level < self1.levels.SILENT) {\n                        return \"No console available for logging\";\n                    }\n                } else {\n                    throw \"log.setLevel() called with invalid level: \" + level;\n                }\n            };\n            self1.setDefaultLevel = function(level) {\n                defaultLevel = level;\n                if (!getPersistedLevel()) {\n                    self1.setLevel(level, false);\n                }\n            };\n            self1.resetLevel = function() {\n                self1.setLevel(defaultLevel, false);\n                clearPersistedLevel();\n            };\n            self1.enableAll = function(persist) {\n                self1.setLevel(self1.levels.TRACE, persist);\n            };\n            self1.disableAll = function(persist) {\n                self1.setLevel(self1.levels.SILENT, persist);\n            };\n            // Initialize with the right level\n            var initialLevel = getPersistedLevel();\n            if (initialLevel == null) {\n                initialLevel = defaultLevel;\n            }\n            self1.setLevel(initialLevel, false);\n        }\n        /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n        var _loggersByName = {};\n        defaultLogger.getLogger = function getLogger(name) {\n            if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                throw new TypeError(\"You must supply a name when creating a logger.\");\n            }\n            var logger = _loggersByName[name];\n            if (!logger) {\n                logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n            }\n            return logger;\n        };\n        // Grab the current global log variable in case of overwrite\n        var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n        defaultLogger.noConflict = function() {\n            if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                window.log = _log;\n            }\n            return defaultLogger;\n        };\n        defaultLogger.getLoggers = function getLoggers() {\n            return _loggersByName;\n        };\n        // ES6 default export, for compatibility\n        defaultLogger[\"default\"] = defaultLogger;\n        return defaultLogger;\n    });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nconst livekitLogger = loglevelExports.getLogger(\"livekit\");\nlivekitLogger.setDefaultLevel(LogLevel.info);\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    }\n    for (const logger of Object.values(loglevelExports.getLoggers())){\n        logger.setLevel(level);\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension) {\n    const originalFactory = livekitLogger.methodFactory;\n    livekitLogger.methodFactory = (methodName, configLevel, loggerName)=>{\n        const rawMethod = originalFactory(methodName, configLevel, loggerName);\n        const logLevel = LogLevel[methodName];\n        const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n        return (msg, context)=>{\n            if (context) rawMethod(msg, context);\n            else rawMethod(msg);\n            if (needLog) {\n                extension(logLevel, msg, context);\n            }\n        };\n    };\n    livekitLogger.setLevel(livekitLogger.getLevel()); // Be sure to call setLevel method in order to apply plugin\n}\nloglevelExports.getLogger(\"lk-e2ee\");\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -3.4028234663852886e38, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, json, bin, util) {\n    return {\n        syntax,\n        json,\n        bin,\n        util,\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType\n    };\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * Used for groups\n   * @deprecated\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element on the wire and return the skipped data.\n   * Supports WireType.StartGroup since v2.0.0-alpha.23.\n   */ skip(wireType) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                // From descriptor.proto: Group type is deprecated, not supported in proto3.\n                // But we must still be able to parse and treat as unknown.\n                let t;\n                while((t = this.tag()[1]) !== WireType.EndGroup){\n                    this.skip(t);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (value instanceof Message || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the default value for the given scalar type, following\n * proto3 semantics.\n */ function scalarDefaultValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ function scalarTypeInfo(type, value) {\n    const isUndefined = value === undefined;\n    let wireType = WireType.Varint;\n    let isIntrinsicDefault = value === 0;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.STRING:\n            isIntrinsicDefault = isUndefined || !value.length;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.BOOL:\n            isIntrinsicDefault = value === false;\n            break;\n        case ScalarType.DOUBLE:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.INT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.UINT64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            break;\n        case ScalarType.FIXED64:\n            isIntrinsicDefault = isUndefined || value == 0; // Loose comparison matches 0n, 0 and \"0\"\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.BYTES:\n            isIntrinsicDefault = isUndefined || !value.byteLength;\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.FIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED32:\n            wireType = WireType.Bit32;\n            break;\n        case ScalarType.SFIXED64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.SINT64:\n            isIntrinsicDefault = isUndefined || value == 0;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method,\n        isUndefined || isIntrinsicDefault\n    ];\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormatCommon() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, length, options) {\n            const type = message.getType();\n            const end = length === undefined ? reader.len : reader.pos + length;\n            while(reader.pos < end){\n                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                let target = message, repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    target = target[field.oneof.localName];\n                    if (target.case != localName) {\n                        delete target.value;\n                    }\n                    target.case = localName;\n                    localName = \"value\";\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        let read = readScalar$1;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n                        if (field.kind == \"scalar\" && field.L > 0) {\n                            read = readScalarLTString;\n                        }\n                        if (repeated) {\n                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                            if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {\n                                let e = reader.uint32() + reader.pos;\n                                while(reader.pos < e){\n                                    arr.push(read(reader, scalarType));\n                                }\n                            } else {\n                                arr.push(read(reader, scalarType));\n                            }\n                        } else {\n                            target[localName] = read(reader, scalarType);\n                        }\n                        break;\n                    case \"message\":\n                        const messageType = field.T;\n                        if (repeated) {\n                            // safe to assume presence of array, oneof cannot contain repeated values\n                            target[localName].push(readMessageField(reader, new messageType(), options));\n                        } else {\n                            if (target[localName] instanceof Message) {\n                                readMessageField(reader, target[localName], options);\n                            } else {\n                                target[localName] = readMessageField(reader, new messageType(), options);\n                                if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                        }\n                        break;\n                    case \"map\":\n                        let [mapKey, mapVal] = readMapEntry(field, reader, options);\n                        // safe to assume presence of map object, oneof cannot contain repeated values\n                        target[localName][mapKey] = mapVal;\n                        break;\n                }\n            }\n        }\n    };\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options) {\n    const format = message.getType().runtime.bin;\n    format.readMessage(message, reader, reader.uint32(), options);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        let [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar$1(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar$1(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        let keyRaw = scalarDefaultValue(field.K, LongType.BIGINT);\n        key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarDefaultValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = 0;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar$1(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar$1(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar$1(writer, field.K, 1, keyValue, true);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar$1(writer, field.V.T, 2, value, true);\n            break;\n        case \"enum\":\n            writeScalar$1(writer, ScalarType.INT32, 2, value, true);\n            break;\n        case \"message\":\n            writeMessageField(writer, options, field.V.T, 2, value);\n            break;\n    }\n    writer.join();\n}\nfunction writeMessageField(writer, options, type, fieldNo, value) {\n    if (value !== undefined) {\n        const message = wrapField(type, value);\n        writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));\n    }\n}\nfunction writeScalar$1(writer, type, fieldNo, value, emitIntrinsicDefault) {\n    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);\n    if (!isIntrinsicDefault || emitIntrinsicDefault) {\n        writer.tag(fieldNo, wireType)[method](value);\n    }\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/strict-boolean-expressions, prefer-const, no-case-declarations */ function makeBinaryFormatProto3() {\n    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                let value, // this will be our field value, whether it is member of a oneof or regular field\n                repeated = field.repeated, localName = field.localName;\n                if (field.oneof) {\n                    const oneof = message[field.oneof.localName];\n                    if (oneof.case !== localName) {\n                        continue; // field is not selected, skip\n                    }\n                    value = oneof.value;\n                } else {\n                    value = message[localName];\n                }\n                switch(field.kind){\n                    case \"scalar\":\n                    case \"enum\":\n                        let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n                        if (repeated) {\n                            if (field.packed) {\n                                writePacked(writer, scalarType, field.no, value);\n                            } else {\n                                for (const item of value){\n                                    writeScalar$1(writer, scalarType, field.no, item, true);\n                                }\n                            }\n                        } else {\n                            if (value !== undefined) {\n                                writeScalar$1(writer, scalarType, field.no, value, !!field.oneof || field.opt);\n                            }\n                        }\n                        break;\n                    case \"message\":\n                        if (repeated) {\n                            for (const item of value){\n                                writeMessageField(writer, options, field.T, field.no, item);\n                            }\n                        } else {\n                            writeMessageField(writer, options, field.T, field.no, value);\n                        }\n                        break;\n                    case \"map\":\n                        for (const [key, val] of Object.entries(value)){\n                            writeMapEntry(writer, options, field, key, val);\n                        }\n                        break;\n                }\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        }\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nfunction makeJsonFormatCommon(makeWriteField) {\n    const writeField = makeWriteField(writeEnum, writeScalar);\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(this.debug(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = {};\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (!field) {\n                    if (!options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: key \"').concat(jsonKey, '\" is unknown'));\n                    }\n                    continue;\n                }\n                let localName = field.localName;\n                let target = message;\n                if (field.oneof) {\n                    if (jsonValue === null && field.kind == \"scalar\") {\n                        continue;\n                    }\n                    const seen = oneofSeen[field.oneof.localName];\n                    if (seen) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: multiple keys for oneof \"').concat(field.oneof.name, '\" present: \"').concat(seen, '\", \"').concat(jsonKey, '\"'));\n                    }\n                    oneofSeen[field.oneof.localName] = jsonKey;\n                    target = target[field.oneof.localName] = {\n                        case: localName\n                    };\n                    localName = \"value\";\n                }\n                if (field.repeated) {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (!Array.isArray(jsonValue)) {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetArray = target[localName];\n                    for (const jsonItem of jsonValue){\n                        if (jsonItem === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem)));\n                        }\n                        let val;\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- \"map\" is invalid for repeated fields\n                        switch(field.kind){\n                            case \"message\":\n                                val = field.T.fromJson(jsonItem, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.T, jsonItem, field.L);\n                                } catch (e) {\n                                    let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonItem));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        targetArray.push(val);\n                    }\n                } else if (field.kind == \"map\") {\n                    if (jsonValue === null) {\n                        continue;\n                    }\n                    if (Array.isArray(jsonValue) || typeof jsonValue != \"object\") {\n                        throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue)));\n                    }\n                    const targetMap = target[localName];\n                    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n                        if (jsonMapValue === null) {\n                            throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n                        }\n                        let val;\n                        switch(field.V.kind){\n                            case \"message\":\n                                val = field.V.T.fromJson(jsonMapValue, options);\n                                break;\n                            case \"enum\":\n                                val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);\n                                if (val === undefined) continue;\n                                break;\n                            case \"scalar\":\n                                try {\n                                    val = readScalar(field.V.T, jsonMapValue, LongType.BIGINT);\n                                } catch (e) {\n                                    let m = \"cannot decode map value for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                    if (e instanceof Error && e.message.length > 0) {\n                                        m += \": \".concat(e.message);\n                                    }\n                                    throw new Error(m);\n                                }\n                                break;\n                        }\n                        try {\n                            targetMap[readScalar(field.K, field.K == ScalarType.BOOL ? jsonMapKey == \"true\" ? true : jsonMapKey == \"false\" ? false : jsonMapKey : jsonMapKey, LongType.BIGINT).toString()] = val;\n                        } catch (e) {\n                            let m = \"cannot decode map key for field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                            if (e instanceof Error && e.message.length > 0) {\n                                m += \": \".concat(e.message);\n                            }\n                            throw new Error(m);\n                        }\n                    }\n                } else {\n                    switch(field.kind){\n                        case \"message\":\n                            const messageType = field.T;\n                            if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                                if (field.oneof) {\n                                    throw new Error(\"cannot decode field \".concat(type.typeName, \".\").concat(field.name, ' from JSON: null is invalid for oneof field \"').concat(jsonKey, '\"'));\n                                }\n                                continue;\n                            }\n                            if (target[localName] instanceof Message) {\n                                target[localName].fromJson(jsonValue, options);\n                            } else {\n                                target[localName] = messageType.fromJson(jsonValue, options);\n                                if (messageType.fieldWrapper && !field.oneof) {\n                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                                }\n                            }\n                            break;\n                        case \"enum\":\n                            const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);\n                            if (enumValue !== undefined) {\n                                target[localName] = enumValue;\n                            }\n                            break;\n                        case \"scalar\":\n                            try {\n                                target[localName] = readScalar(field.T, jsonValue, field.L);\n                            } catch (e) {\n                                let m = \"cannot decode field \".concat(type.typeName, \".\").concat(field.name, \" from JSON: \").concat(this.debug(jsonValue));\n                                if (e instanceof Error && e.message.length > 0) {\n                                    m += \": \".concat(e.message);\n                                }\n                                throw new Error(m);\n                            }\n                            break;\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (const member of type.fields.byMember()){\n                    let jsonValue;\n                    if (member.kind == \"oneof\") {\n                        const oneof = message[member.localName];\n                        if (oneof.value === undefined) {\n                            continue;\n                        }\n                        field = member.findField(oneof.case);\n                        if (!field) {\n                            throw \"oneof case not found: \" + oneof.case;\n                        }\n                        jsonValue = writeField(field, oneof.value, options);\n                    } else {\n                        field = member;\n                        jsonValue = writeField(field, message[field.localName], options);\n                    }\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar,\n        writeScalar,\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : '\"'.concat(json.split('\"').join('\\\\\"'), '\"');\n        default:\n            return String(json);\n    }\n}\n// May throw an error. If the error message is non-blank, it should be shown.\n// It is up to the caller to provide context.\nfunction readScalar(type, json, longType) {\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === null) return 0.0;\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            if (json === null) return 0;\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (json === null) return protoInt64.zero;\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (json === null) return false;\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (json === null) return \"\";\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === null || json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields) {\n    if (json === null) {\n        // proto3 requires 0 to be default value for all enums\n        return 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n            if (value || ignoreUnknownFields) {\n                return value === null || value === void 0 ? void 0 : value.no;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\nfunction writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {\n    var _a;\n    if (value === undefined) {\n        return value;\n    }\n    if (value === 0 && !emitIntrinsicDefault) {\n        // proto3 requires 0 to be default value for all enums\n        return undefined;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar(type, value, emitIntrinsicDefault) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value != 0 || emitIntrinsicDefault ? value : undefined;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value !== 0 || emitIntrinsicDefault ? value : undefined;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value.length > 0 || emitIntrinsicDefault ? value : undefined;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value || emitIntrinsicDefault ? value : undefined;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            // We use implicit conversion with `value != 0` to catch both 0n and \"0\"\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            return emitIntrinsicDefault || value != 0 ? value.toString(10) : undefined;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : undefined;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations, @typescript-eslint/restrict-plus-operands,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function makeJsonFormatProto3() {\n    return makeJsonFormatCommon((writeEnum, writeScalar)=>{\n        return function writeField(field, value, options) {\n            if (field.kind == \"map\") {\n                const jsonObj = {};\n                switch(field.V.kind){\n                    case \"scalar\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            const val = writeScalar(field.V.T, entryValue, true);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                    case \"message\":\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            // JSON standard allows only (double quoted) string as property key\n                            jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                        }\n                        break;\n                    case \"enum\":\n                        const enumType = field.V.T;\n                        for (const [entryKey, entryValue] of Object.entries(value)){\n                            assert(entryValue === undefined || typeof entryValue == \"number\");\n                            const val = writeEnum(enumType, entryValue, true, options.enumAsInteger);\n                            assert(val !== undefined);\n                            jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : undefined;\n            } else if (field.repeated) {\n                const jsonArr = [];\n                switch(field.kind){\n                    case \"scalar\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeScalar(field.T, value[i], true));\n                        }\n                        break;\n                    case \"enum\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(writeEnum(field.T, value[i], true, options.enumAsInteger));\n                        }\n                        break;\n                    case \"message\":\n                        for(let i = 0; i < value.length; i++){\n                            jsonArr.push(wrapField(field.T, value[i]).toJson(options));\n                        }\n                        break;\n                }\n                return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n            } else {\n                switch(field.kind){\n                    case \"scalar\":\n                        return writeScalar(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);\n                    case \"enum\":\n                        return writeEnum(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);\n                    case \"message\":\n                        return value !== undefined ? wrapField(field.T, value).toJson(options) : undefined;\n                }\n            }\n        };\n    });\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] === undefined) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !(val instanceof sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>val instanceof mt ? val : new mt(val));\n                        } else if (s[localName] !== undefined) {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = val instanceof mt ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (value instanceof Message) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {\n    newFieldList (fields) {\n        return new InternalFieldList(fields, normalizeFieldInfosProto3);\n    },\n    initFields (target) {\n        for (const member of target.getType().fields.byMember()){\n            if (member.opt) {\n                continue;\n            }\n            const name = member.localName, t = target;\n            if (member.repeated) {\n                t[name] = [];\n                continue;\n            }\n            switch(member.kind){\n                case \"oneof\":\n                    t[name] = {\n                        case: undefined\n                    };\n                    break;\n                case \"enum\":\n                    t[name] = 0;\n                    break;\n                case \"map\":\n                    t[name] = {};\n                    break;\n                case \"scalar\":\n                    t[name] = scalarDefaultValue(member.T, member.L); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n                    break;\n            }\n        }\n    }\n}));\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument */ function normalizeFieldInfosProto3(fieldInfos) {\n    var _a, _b, _c, _d;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        // From the proto3 language guide:\n        // > In proto3, repeated fields of scalar numeric types are packed by default.\n        // This information is incomplete - according to the conformance tests, BOOL\n        // and ENUM are packed by default as well. This means only STRING and BYTES\n        // are not packed by default, which makes sense because they are length-delimited.\n        f.packed = (_d = field.packed) !== null && _d !== void 0 ? _d : field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.AudioCodec\n */ var AudioCodec;\n(function(AudioCodec) {\n    /**\n   * @generated from enum value: DEFAULT_AC = 0;\n   */ AudioCodec[AudioCodec[\"DEFAULT_AC\"] = 0] = \"DEFAULT_AC\";\n    /**\n   * @generated from enum value: OPUS = 1;\n   */ AudioCodec[AudioCodec[\"OPUS\"] = 1] = \"OPUS\";\n    /**\n   * @generated from enum value: AAC = 2;\n   */ AudioCodec[AudioCodec[\"AAC\"] = 2] = \"AAC\";\n})(AudioCodec || (AudioCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(AudioCodec)\nproto3.util.setEnumType(AudioCodec, \"livekit.AudioCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_AC\"\n    },\n    {\n        no: 1,\n        name: \"OPUS\"\n    },\n    {\n        no: 2,\n        name: \"AAC\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoCodec\n */ var VideoCodec;\n(function(VideoCodec) {\n    /**\n   * @generated from enum value: DEFAULT_VC = 0;\n   */ VideoCodec[VideoCodec[\"DEFAULT_VC\"] = 0] = \"DEFAULT_VC\";\n    /**\n   * @generated from enum value: H264_BASELINE = 1;\n   */ VideoCodec[VideoCodec[\"H264_BASELINE\"] = 1] = \"H264_BASELINE\";\n    /**\n   * @generated from enum value: H264_MAIN = 2;\n   */ VideoCodec[VideoCodec[\"H264_MAIN\"] = 2] = \"H264_MAIN\";\n    /**\n   * @generated from enum value: H264_HIGH = 3;\n   */ VideoCodec[VideoCodec[\"H264_HIGH\"] = 3] = \"H264_HIGH\";\n    /**\n   * @generated from enum value: VP8 = 4;\n   */ VideoCodec[VideoCodec[\"VP8\"] = 4] = \"VP8\";\n})(VideoCodec || (VideoCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoCodec)\nproto3.util.setEnumType(VideoCodec, \"livekit.VideoCodec\", [\n    {\n        no: 0,\n        name: \"DEFAULT_VC\"\n    },\n    {\n        no: 1,\n        name: \"H264_BASELINE\"\n    },\n    {\n        no: 2,\n        name: \"H264_MAIN\"\n    },\n    {\n        no: 3,\n        name: \"H264_HIGH\"\n    },\n    {\n        no: 4,\n        name: \"VP8\"\n    }\n]);\n/**\n * @generated from enum livekit.ImageCodec\n */ var ImageCodec;\n(function(ImageCodec) {\n    /**\n   * @generated from enum value: IC_DEFAULT = 0;\n   */ ImageCodec[ImageCodec[\"IC_DEFAULT\"] = 0] = \"IC_DEFAULT\";\n    /**\n   * @generated from enum value: IC_JPEG = 1;\n   */ ImageCodec[ImageCodec[\"IC_JPEG\"] = 1] = \"IC_JPEG\";\n})(ImageCodec || (ImageCodec = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ImageCodec)\nproto3.util.setEnumType(ImageCodec, \"livekit.ImageCodec\", [\n    {\n        no: 0,\n        name: \"IC_DEFAULT\"\n    },\n    {\n        no: 1,\n        name: \"IC_JPEG\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n   * @generated from enum value: AUDIO = 0;\n   */ TrackType[TrackType[\"AUDIO\"] = 0] = \"AUDIO\";\n    /**\n   * @generated from enum value: VIDEO = 1;\n   */ TrackType[TrackType[\"VIDEO\"] = 1] = \"VIDEO\";\n    /**\n   * @generated from enum value: DATA = 2;\n   */ TrackType[TrackType[\"DATA\"] = 2] = \"DATA\";\n})(TrackType || (TrackType = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackType)\nproto3.util.setEnumType(TrackType, \"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\n/**\n * @generated from enum livekit.TrackSource\n */ var TrackSource;\n(function(TrackSource) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ TrackSource[TrackSource[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: CAMERA = 1;\n   */ TrackSource[TrackSource[\"CAMERA\"] = 1] = \"CAMERA\";\n    /**\n   * @generated from enum value: MICROPHONE = 2;\n   */ TrackSource[TrackSource[\"MICROPHONE\"] = 2] = \"MICROPHONE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE = 3;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n   * @generated from enum value: SCREEN_SHARE_AUDIO = 4;\n   */ TrackSource[TrackSource[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackSource || (TrackSource = {}));\n// Retrieve enum metadata with: proto3.getEnumType(TrackSource)\nproto3.util.setEnumType(TrackSource, \"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\n/**\n * @generated from enum livekit.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n   * @generated from enum value: LOW = 0;\n   */ VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    /**\n   * @generated from enum value: MEDIUM = 1;\n   */ VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    /**\n   * @generated from enum value: HIGH = 2;\n   */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n   * @generated from enum value: OFF = 3;\n   */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n// Retrieve enum metadata with: proto3.getEnumType(VideoQuality)\nproto3.util.setEnumType(VideoQuality, \"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\n/**\n * @generated from enum livekit.ConnectionQuality\n */ var ConnectionQuality$1;\n(function(ConnectionQuality) {\n    /**\n   * @generated from enum value: POOR = 0;\n   */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 0] = \"POOR\";\n    /**\n   * @generated from enum value: GOOD = 1;\n   */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 1] = \"GOOD\";\n    /**\n   * @generated from enum value: EXCELLENT = 2;\n   */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 2] = \"EXCELLENT\";\n    /**\n   * @generated from enum value: LOST = 3;\n   */ ConnectionQuality[ConnectionQuality[\"LOST\"] = 3] = \"LOST\";\n})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ConnectionQuality)\nproto3.util.setEnumType(ConnectionQuality$1, \"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\n/**\n * @generated from enum livekit.ClientConfigSetting\n */ var ClientConfigSetting;\n(function(ClientConfigSetting) {\n    /**\n   * @generated from enum value: UNSET = 0;\n   */ ClientConfigSetting[ClientConfigSetting[\"UNSET\"] = 0] = \"UNSET\";\n    /**\n   * @generated from enum value: DISABLED = 1;\n   */ ClientConfigSetting[ClientConfigSetting[\"DISABLED\"] = 1] = \"DISABLED\";\n    /**\n   * @generated from enum value: ENABLED = 2;\n   */ ClientConfigSetting[ClientConfigSetting[\"ENABLED\"] = 2] = \"ENABLED\";\n})(ClientConfigSetting || (ClientConfigSetting = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientConfigSetting)\nproto3.util.setEnumType(ClientConfigSetting, \"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\n/**\n * @generated from enum livekit.DisconnectReason\n */ var DisconnectReason;\n(function(DisconnectReason) {\n    /**\n   * @generated from enum value: UNKNOWN_REASON = 0;\n   */ DisconnectReason[DisconnectReason[\"UNKNOWN_REASON\"] = 0] = \"UNKNOWN_REASON\";\n    /**\n   * @generated from enum value: CLIENT_INITIATED = 1;\n   */ DisconnectReason[DisconnectReason[\"CLIENT_INITIATED\"] = 1] = \"CLIENT_INITIATED\";\n    /**\n   * @generated from enum value: DUPLICATE_IDENTITY = 2;\n   */ DisconnectReason[DisconnectReason[\"DUPLICATE_IDENTITY\"] = 2] = \"DUPLICATE_IDENTITY\";\n    /**\n   * @generated from enum value: SERVER_SHUTDOWN = 3;\n   */ DisconnectReason[DisconnectReason[\"SERVER_SHUTDOWN\"] = 3] = \"SERVER_SHUTDOWN\";\n    /**\n   * @generated from enum value: PARTICIPANT_REMOVED = 4;\n   */ DisconnectReason[DisconnectReason[\"PARTICIPANT_REMOVED\"] = 4] = \"PARTICIPANT_REMOVED\";\n    /**\n   * @generated from enum value: ROOM_DELETED = 5;\n   */ DisconnectReason[DisconnectReason[\"ROOM_DELETED\"] = 5] = \"ROOM_DELETED\";\n    /**\n   * @generated from enum value: STATE_MISMATCH = 6;\n   */ DisconnectReason[DisconnectReason[\"STATE_MISMATCH\"] = 6] = \"STATE_MISMATCH\";\n    /**\n   * @generated from enum value: JOIN_FAILURE = 7;\n   */ DisconnectReason[DisconnectReason[\"JOIN_FAILURE\"] = 7] = \"JOIN_FAILURE\";\n})(DisconnectReason || (DisconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DisconnectReason)\nproto3.util.setEnumType(DisconnectReason, \"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    }\n]);\n/**\n * @generated from enum livekit.ReconnectReason\n */ var ReconnectReason;\n(function(ReconnectReason) {\n    /**\n   * @generated from enum value: RR_UNKNOWN = 0;\n   */ ReconnectReason[ReconnectReason[\"RR_UNKNOWN\"] = 0] = \"RR_UNKNOWN\";\n    /**\n   * @generated from enum value: RR_SIGNAL_DISCONNECTED = 1;\n   */ ReconnectReason[ReconnectReason[\"RR_SIGNAL_DISCONNECTED\"] = 1] = \"RR_SIGNAL_DISCONNECTED\";\n    /**\n   * @generated from enum value: RR_PUBLISHER_FAILED = 2;\n   */ ReconnectReason[ReconnectReason[\"RR_PUBLISHER_FAILED\"] = 2] = \"RR_PUBLISHER_FAILED\";\n    /**\n   * @generated from enum value: RR_SUBSCRIBER_FAILED = 3;\n   */ ReconnectReason[ReconnectReason[\"RR_SUBSCRIBER_FAILED\"] = 3] = \"RR_SUBSCRIBER_FAILED\";\n    /**\n   * @generated from enum value: RR_SWITCH_CANDIDATE = 4;\n   */ ReconnectReason[ReconnectReason[\"RR_SWITCH_CANDIDATE\"] = 4] = \"RR_SWITCH_CANDIDATE\";\n})(ReconnectReason || (ReconnectReason = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ReconnectReason)\nproto3.util.setEnumType(ReconnectReason, \"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\n/**\n * @generated from enum livekit.SubscriptionError\n */ var SubscriptionError;\n(function(SubscriptionError) {\n    /**\n   * @generated from enum value: SE_UNKNOWN = 0;\n   */ SubscriptionError[SubscriptionError[\"SE_UNKNOWN\"] = 0] = \"SE_UNKNOWN\";\n    /**\n   * @generated from enum value: SE_CODEC_UNSUPPORTED = 1;\n   */ SubscriptionError[SubscriptionError[\"SE_CODEC_UNSUPPORTED\"] = 1] = \"SE_CODEC_UNSUPPORTED\";\n    /**\n   * @generated from enum value: SE_TRACK_NOTFOUND = 2;\n   */ SubscriptionError[SubscriptionError[\"SE_TRACK_NOTFOUND\"] = 2] = \"SE_TRACK_NOTFOUND\";\n})(SubscriptionError || (SubscriptionError = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SubscriptionError)\nproto3.util.setEnumType(SubscriptionError, \"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\n/**\n * @generated from message livekit.Room\n */ let Room$1 = class Room extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 empty_timeout = 3;\n     */ this.emptyTimeout = 0;\n        /**\n     * @generated from field: uint32 max_participants = 4;\n     */ this.maxParticipants = 0;\n        /**\n     * @generated from field: int64 creation_time = 5;\n     */ this.creationTime = protoInt64.zero;\n        /**\n     * @generated from field: string turn_password = 6;\n     */ this.turnPassword = \"\";\n        /**\n     * @generated from field: repeated livekit.Codec enabled_codecs = 7;\n     */ this.enabledCodecs = [];\n        /**\n     * @generated from field: string metadata = 8;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: uint32 num_participants = 9;\n     */ this.numParticipants = 0;\n        /**\n     * @generated from field: uint32 num_publishers = 11;\n     */ this.numPublishers = 0;\n        /**\n     * @generated from field: bool active_recording = 10;\n     */ this.activeRecording = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Room().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Room().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Room().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Room, a, b);\n    }\n};\nRoom$1.runtime = proto3;\nRoom$1.typeName = \"livekit.Room\";\nRoom$1.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.Codec\n */ class Codec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime = 1;\n     */ this.mime = \"\";\n        /**\n     * @generated from field: string fmtp_line = 2;\n     */ this.fmtpLine = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Codec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Codec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Codec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Codec, a, b);\n    }\n}\nCodec.runtime = proto3;\nCodec.typeName = \"livekit.Codec\";\nCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.PlayoutDelay\n */ class PlayoutDelay extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool enabled = 1;\n     */ this.enabled = false;\n        /**\n     * @generated from field: uint32 min = 2;\n     */ this.min = 0;\n        /**\n     * @generated from field: uint32 max = 3;\n     */ this.max = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new PlayoutDelay().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new PlayoutDelay().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new PlayoutDelay().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(PlayoutDelay, a, b);\n    }\n}\nPlayoutDelay.runtime = proto3;\nPlayoutDelay.typeName = \"livekit.PlayoutDelay\";\nPlayoutDelay.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"min\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantPermission\n */ class ParticipantPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * allow participant to subscribe to other tracks in the room\n     *\n     * @generated from field: bool can_subscribe = 1;\n     */ this.canSubscribe = false;\n        /**\n     * allow participant to publish new tracks to room\n     *\n     * @generated from field: bool can_publish = 2;\n     */ this.canPublish = false;\n        /**\n     * allow participant to publish data\n     *\n     * @generated from field: bool can_publish_data = 3;\n     */ this.canPublishData = false;\n        /**\n     * sources that are allowed to be published\n     *\n     * @generated from field: repeated livekit.TrackSource can_publish_sources = 9;\n     */ this.canPublishSources = [];\n        /**\n     * indicates that it's hidden to others\n     *\n     * @generated from field: bool hidden = 7;\n     */ this.hidden = false;\n        /**\n     * indicates it's a recorder instance\n     *\n     * @generated from field: bool recorder = 8;\n     */ this.recorder = false;\n        /**\n     * indicates that participant can update own metadata\n     *\n     * @generated from field: bool can_update_metadata = 10;\n     */ this.canUpdateMetadata = false;\n        /**\n     * indicates that participant is an agent\n     *\n     * @generated from field: bool agent = 11;\n     */ this.agent = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantPermission, a, b);\n    }\n}\nParticipantPermission.runtime = proto3;\nParticipantPermission.typeName = \"livekit.ParticipantPermission\";\nParticipantPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantInfo\n */ class ParticipantInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: string identity = 2;\n     */ this.identity = \"\";\n        /**\n     * @generated from field: livekit.ParticipantInfo.State state = 3;\n     */ this.state = ParticipantInfo_State.JOINING;\n        /**\n     * @generated from field: repeated livekit.TrackInfo tracks = 4;\n     */ this.tracks = [];\n        /**\n     * @generated from field: string metadata = 5;\n     */ this.metadata = \"\";\n        /**\n     * timestamp when participant joined room, in seconds\n     *\n     * @generated from field: int64 joined_at = 6;\n     */ this.joinedAt = protoInt64.zero;\n        /**\n     * @generated from field: string name = 9;\n     */ this.name = \"\";\n        /**\n     * @generated from field: uint32 version = 10;\n     */ this.version = 0;\n        /**\n     * @generated from field: string region = 12;\n     */ this.region = \"\";\n        /**\n     * indicates the participant has an active publisher connection\n     * and can publish to the server\n     *\n     * @generated from field: bool is_publisher = 13;\n     */ this.isPublisher = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantInfo, a, b);\n    }\n}\nParticipantInfo.runtime = proto3;\nParticipantInfo.typeName = \"livekit.ParticipantInfo\";\nParticipantInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ParticipantInfo.State\n */ var ParticipantInfo_State;\n(function(ParticipantInfo_State) {\n    /**\n   * websocket' connected, but not offered yet\n   *\n   * @generated from enum value: JOINING = 0;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINING\"] = 0] = \"JOINING\";\n    /**\n   * server received client offer\n   *\n   * @generated from enum value: JOINED = 1;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"JOINED\"] = 1] = \"JOINED\";\n    /**\n   * ICE connectivity established\n   *\n   * @generated from enum value: ACTIVE = 2;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"ACTIVE\"] = 2] = \"ACTIVE\";\n    /**\n   * WS disconnected\n   *\n   * @generated from enum value: DISCONNECTED = 3;\n   */ ParticipantInfo_State[ParticipantInfo_State[\"DISCONNECTED\"] = 3] = \"DISCONNECTED\";\n})(ParticipantInfo_State || (ParticipantInfo_State = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ParticipantInfo_State)\nproto3.util.setEnumType(ParticipantInfo_State, \"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\n/**\n * @generated from message livekit.Encryption\n */ class Encryption extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Encryption().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Encryption().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Encryption().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Encryption, a, b);\n    }\n}\nEncryption.runtime = proto3;\nEncryption.typeName = \"livekit.Encryption\";\nEncryption.fields = proto3.util.newFieldList(()=>[]);\n/**\n * @generated from enum livekit.Encryption.Type\n */ var Encryption_Type;\n(function(Encryption_Type) {\n    /**\n   * @generated from enum value: NONE = 0;\n   */ Encryption_Type[Encryption_Type[\"NONE\"] = 0] = \"NONE\";\n    /**\n   * @generated from enum value: GCM = 1;\n   */ Encryption_Type[Encryption_Type[\"GCM\"] = 1] = \"GCM\";\n    /**\n   * @generated from enum value: CUSTOM = 2;\n   */ Encryption_Type[Encryption_Type[\"CUSTOM\"] = 2] = \"CUSTOM\";\n})(Encryption_Type || (Encryption_Type = {}));\n// Retrieve enum metadata with: proto3.getEnumType(Encryption_Type)\nproto3.util.setEnumType(Encryption_Type, \"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\n/**\n * @generated from message livekit.SimulcastCodecInfo\n */ class SimulcastCodecInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string mime_type = 1;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 2;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: string cid = 3;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 4;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodecInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodecInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodecInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodecInfo, a, b);\n    }\n}\nSimulcastCodecInfo.runtime = proto3;\nSimulcastCodecInfo.typeName = \"livekit.SimulcastCodecInfo\";\nSimulcastCodecInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackInfo\n */ class TrackInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 2;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * @generated from field: string name = 3;\n     */ this.name = \"\";\n        /**\n     * @generated from field: bool muted = 4;\n     */ this.muted = false;\n        /**\n     * original width of video (unset for audio)\n     * clients may receive a lower resolution version with simulcast\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * original height of video (unset for audio)\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * true if track is simulcasted\n     *\n     * @generated from field: bool simulcast = 7;\n     */ this.simulcast = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 8;\n     */ this.disableDtx = false;\n        /**\n     * source of media\n     *\n     * @generated from field: livekit.TrackSource source = 9;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 10;\n     */ this.layers = [];\n        /**\n     * mime type of codec\n     *\n     * @generated from field: string mime_type = 11;\n     */ this.mimeType = \"\";\n        /**\n     * @generated from field: string mid = 12;\n     */ this.mid = \"\";\n        /**\n     * @generated from field: repeated livekit.SimulcastCodecInfo codecs = 13;\n     */ this.codecs = [];\n        /**\n     * @generated from field: bool stereo = 14;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 15;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 16;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * @generated from field: string stream = 17;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackInfo, a, b);\n    }\n}\nTrackInfo.runtime = proto3;\nTrackInfo.typeName = \"livekit.TrackInfo\";\nTrackInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * provide information about available spatial layers\n *\n * @generated from message livekit.VideoLayer\n */ class VideoLayer extends Message {\n    constructor(data){\n        super();\n        /**\n     * for tracks with a single layer, this should be HIGH\n     *\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: uint32 width = 2;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 3;\n     */ this.height = 0;\n        /**\n     * target bitrate in bit per second (bps), server will measure actual\n     *\n     * @generated from field: uint32 bitrate = 4;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 ssrc = 5;\n     */ this.ssrc = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoLayer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoLayer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoLayer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoLayer, a, b);\n    }\n}\nVideoLayer.runtime = proto3;\nVideoLayer.typeName = \"livekit.VideoLayer\";\nVideoLayer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * new DataPacket API\n *\n * @generated from message livekit.DataPacket\n */ class DataPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.DataPacket.Kind kind = 1;\n     */ this.kind = DataPacket_Kind.RELIABLE;\n        /**\n     * @generated from oneof livekit.DataPacket.value\n     */ this.value = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataPacket, a, b);\n    }\n}\nDataPacket.runtime = proto3;\nDataPacket.typeName = \"livekit.DataPacket\";\nDataPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        }\n    ]);\n/**\n * @generated from enum livekit.DataPacket.Kind\n */ var DataPacket_Kind;\n(function(DataPacket_Kind) {\n    /**\n   * @generated from enum value: RELIABLE = 0;\n   */ DataPacket_Kind[DataPacket_Kind[\"RELIABLE\"] = 0] = \"RELIABLE\";\n    /**\n   * @generated from enum value: LOSSY = 1;\n   */ DataPacket_Kind[DataPacket_Kind[\"LOSSY\"] = 1] = \"LOSSY\";\n})(DataPacket_Kind || (DataPacket_Kind = {}));\n// Retrieve enum metadata with: proto3.getEnumType(DataPacket_Kind)\nproto3.util.setEnumType(DataPacket_Kind, \"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\n/**\n * @generated from message livekit.ActiveSpeakerUpdate\n */ class ActiveSpeakerUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ActiveSpeakerUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ActiveSpeakerUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ActiveSpeakerUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ActiveSpeakerUpdate, a, b);\n    }\n}\nActiveSpeakerUpdate.runtime = proto3;\nActiveSpeakerUpdate.typeName = \"livekit.ActiveSpeakerUpdate\";\nActiveSpeakerUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SpeakerInfo\n */ class SpeakerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * audio level, 0-1.0, 1 is loudest\n     *\n     * @generated from field: float level = 2;\n     */ this.level = 0;\n        /**\n     * true if speaker is currently active\n     *\n     * @generated from field: bool active = 3;\n     */ this.active = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakerInfo, a, b);\n    }\n}\nSpeakerInfo.runtime = proto3;\nSpeakerInfo.typeName = \"livekit.SpeakerInfo\";\nSpeakerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.UserPacket\n */ class UserPacket extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of user that sent the message\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string participant_identity = 5;\n     */ this.participantIdentity = \"\";\n        /**\n     * user defined payload\n     *\n     * @generated from field: bytes payload = 2;\n     */ this.payload = new Uint8Array(0);\n        /**\n     * the ID of the participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_sids = 3;\n     */ this.destinationSids = [];\n        /**\n     * identities of participants who will receive the message (sent to all by default)\n     *\n     * @generated from field: repeated string destination_identities = 6;\n     */ this.destinationIdentities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UserPacket().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UserPacket().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UserPacket().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UserPacket, a, b);\n    }\n}\nUserPacket.runtime = proto3;\nUserPacket.typeName = \"livekit.UserPacket\";\nUserPacket.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            opt: true\n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantTracks\n */ class ParticipantTracks extends Message {\n    constructor(data){\n        super();\n        /**\n     * participant ID of participant to whom the tracks belong\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: repeated string track_sids = 2;\n     */ this.trackSids = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantTracks().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantTracks().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantTracks().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantTracks, a, b);\n    }\n}\nParticipantTracks.runtime = proto3;\nParticipantTracks.typeName = \"livekit.ParticipantTracks\";\nParticipantTracks.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        }\n    ]);\n/**\n * details about the server\n *\n * @generated from message livekit.ServerInfo\n */ class ServerInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ServerInfo.Edition edition = 1;\n     */ this.edition = ServerInfo_Edition.Standard;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string region = 4;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string node_id = 5;\n     */ this.nodeId = \"\";\n        /**\n     * additional debugging information. sent only if server is in development mode\n     *\n     * @generated from field: string debug_info = 6;\n     */ this.debugInfo = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ServerInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ServerInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ServerInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ServerInfo, a, b);\n    }\n}\nServerInfo.runtime = proto3;\nServerInfo.typeName = \"livekit.ServerInfo\";\nServerInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ServerInfo.Edition\n */ var ServerInfo_Edition;\n(function(ServerInfo_Edition) {\n    /**\n   * @generated from enum value: Standard = 0;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Standard\"] = 0] = \"Standard\";\n    /**\n   * @generated from enum value: Cloud = 1;\n   */ ServerInfo_Edition[ServerInfo_Edition[\"Cloud\"] = 1] = \"Cloud\";\n})(ServerInfo_Edition || (ServerInfo_Edition = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ServerInfo_Edition)\nproto3.util.setEnumType(ServerInfo_Edition, \"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\n/**\n * details about the client\n *\n * @generated from message livekit.ClientInfo\n */ class ClientInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientInfo.SDK sdk = 1;\n     */ this.sdk = ClientInfo_SDK.UNKNOWN;\n        /**\n     * @generated from field: string version = 2;\n     */ this.version = \"\";\n        /**\n     * @generated from field: int32 protocol = 3;\n     */ this.protocol = 0;\n        /**\n     * @generated from field: string os = 4;\n     */ this.os = \"\";\n        /**\n     * @generated from field: string os_version = 5;\n     */ this.osVersion = \"\";\n        /**\n     * @generated from field: string device_model = 6;\n     */ this.deviceModel = \"\";\n        /**\n     * @generated from field: string browser = 7;\n     */ this.browser = \"\";\n        /**\n     * @generated from field: string browser_version = 8;\n     */ this.browserVersion = \"\";\n        /**\n     * @generated from field: string address = 9;\n     */ this.address = \"\";\n        /**\n     * wifi, wired, cellular, vpn, empty if not known\n     *\n     * @generated from field: string network = 10;\n     */ this.network = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientInfo, a, b);\n    }\n}\nClientInfo.runtime = proto3;\nClientInfo.typeName = \"livekit.ClientInfo\";\nClientInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from enum livekit.ClientInfo.SDK\n */ var ClientInfo_SDK;\n(function(ClientInfo_SDK) {\n    /**\n   * @generated from enum value: UNKNOWN = 0;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n   * @generated from enum value: JS = 1;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"JS\"] = 1] = \"JS\";\n    /**\n   * @generated from enum value: SWIFT = 2;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"SWIFT\"] = 2] = \"SWIFT\";\n    /**\n   * @generated from enum value: ANDROID = 3;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n   * @generated from enum value: FLUTTER = 4;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"FLUTTER\"] = 4] = \"FLUTTER\";\n    /**\n   * @generated from enum value: GO = 5;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"GO\"] = 5] = \"GO\";\n    /**\n   * @generated from enum value: UNITY = 6;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"UNITY\"] = 6] = \"UNITY\";\n    /**\n   * @generated from enum value: REACT_NATIVE = 7;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"REACT_NATIVE\"] = 7] = \"REACT_NATIVE\";\n    /**\n   * @generated from enum value: RUST = 8;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"RUST\"] = 8] = \"RUST\";\n    /**\n   * @generated from enum value: PYTHON = 9;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"PYTHON\"] = 9] = \"PYTHON\";\n    /**\n   * @generated from enum value: CPP = 10;\n   */ ClientInfo_SDK[ClientInfo_SDK[\"CPP\"] = 10] = \"CPP\";\n})(ClientInfo_SDK || (ClientInfo_SDK = {}));\n// Retrieve enum metadata with: proto3.getEnumType(ClientInfo_SDK)\nproto3.util.setEnumType(ClientInfo_SDK, \"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    }\n]);\n/**\n * server provided client configuration\n *\n * @generated from message livekit.ClientConfiguration\n */ class ClientConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting resume_connection = 3;\n     */ this.resumeConnection = ClientConfigSetting.UNSET;\n        /**\n     * @generated from field: livekit.ClientConfigSetting force_relay = 5;\n     */ this.forceRelay = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ClientConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ClientConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ClientConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ClientConfiguration, a, b);\n    }\n}\nClientConfiguration.runtime = proto3;\nClientConfiguration.typeName = \"livekit.ClientConfiguration\";\nClientConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.VideoConfiguration\n */ class VideoConfiguration extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.ClientConfigSetting hardware_encoder = 1;\n     */ this.hardwareEncoder = ClientConfigSetting.UNSET;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new VideoConfiguration().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new VideoConfiguration().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new VideoConfiguration().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(VideoConfiguration, a, b);\n    }\n}\nVideoConfiguration.runtime = proto3;\nVideoConfiguration.typeName = \"livekit.VideoConfiguration\";\nVideoConfiguration.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\n/**\n * @generated from message livekit.DisabledCodecs\n */ class DisabledCodecs extends Message {\n    constructor(data){\n        super();\n        /**\n     * disabled for both publish and subscribe\n     *\n     * @generated from field: repeated livekit.Codec codecs = 1;\n     */ this.codecs = [];\n        /**\n     * only disable for publish\n     *\n     * @generated from field: repeated livekit.Codec publish = 2;\n     */ this.publish = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DisabledCodecs().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DisabledCodecs().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DisabledCodecs().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DisabledCodecs, a, b);\n    }\n}\nDisabledCodecs.runtime = proto3;\nDisabledCodecs.typeName = \"livekit.DisabledCodecs\";\nDisabledCodecs.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RTPDrift\n */ class RTPDrift extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint64 start_timestamp = 4;\n     */ this.startTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 end_timestamp = 5;\n     */ this.endTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: uint64 rtp_clock_ticks = 6;\n     */ this.rtpClockTicks = protoInt64.zero;\n        /**\n     * @generated from field: int64 drift_samples = 7;\n     */ this.driftSamples = protoInt64.zero;\n        /**\n     * @generated from field: double drift_ms = 8;\n     */ this.driftMs = 0;\n        /**\n     * @generated from field: double clock_rate = 9;\n     */ this.clockRate = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPDrift().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPDrift().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPDrift().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPDrift, a, b);\n    }\n}\nRTPDrift.runtime = proto3;\nRTPDrift.typeName = \"livekit.RTPDrift\";\nRTPDrift.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"start_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 5,\n            name: \"end_timestamp\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 6,\n            name: \"rtp_clock_ticks\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"drift_samples\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 8,\n            name: \"drift_ms\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 9,\n            name: \"clock_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        }\n    ]);\n/**\n * @generated from message livekit.RTPStats\n */ class RTPStats extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: double duration = 3;\n     */ this.duration = 0;\n        /**\n     * @generated from field: uint32 packets = 4;\n     */ this.packets = 0;\n        /**\n     * @generated from field: double packet_rate = 5;\n     */ this.packetRate = 0;\n        /**\n     * @generated from field: uint64 bytes = 6;\n     */ this.bytes = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes = 39;\n     */ this.headerBytes = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate = 7;\n     */ this.bitrate = 0;\n        /**\n     * @generated from field: uint32 packets_lost = 8;\n     */ this.packetsLost = 0;\n        /**\n     * @generated from field: double packet_loss_rate = 9;\n     */ this.packetLossRate = 0;\n        /**\n     * @generated from field: float packet_loss_percentage = 10;\n     */ this.packetLossPercentage = 0;\n        /**\n     * @generated from field: uint32 packets_duplicate = 11;\n     */ this.packetsDuplicate = 0;\n        /**\n     * @generated from field: double packet_duplicate_rate = 12;\n     */ this.packetDuplicateRate = 0;\n        /**\n     * @generated from field: uint64 bytes_duplicate = 13;\n     */ this.bytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_duplicate = 40;\n     */ this.headerBytesDuplicate = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_duplicate = 14;\n     */ this.bitrateDuplicate = 0;\n        /**\n     * @generated from field: uint32 packets_padding = 15;\n     */ this.packetsPadding = 0;\n        /**\n     * @generated from field: double packet_padding_rate = 16;\n     */ this.packetPaddingRate = 0;\n        /**\n     * @generated from field: uint64 bytes_padding = 17;\n     */ this.bytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: uint64 header_bytes_padding = 41;\n     */ this.headerBytesPadding = protoInt64.zero;\n        /**\n     * @generated from field: double bitrate_padding = 18;\n     */ this.bitratePadding = 0;\n        /**\n     * @generated from field: uint32 packets_out_of_order = 19;\n     */ this.packetsOutOfOrder = 0;\n        /**\n     * @generated from field: uint32 frames = 20;\n     */ this.frames = 0;\n        /**\n     * @generated from field: double frame_rate = 21;\n     */ this.frameRate = 0;\n        /**\n     * @generated from field: double jitter_current = 22;\n     */ this.jitterCurrent = 0;\n        /**\n     * @generated from field: double jitter_max = 23;\n     */ this.jitterMax = 0;\n        /**\n     * @generated from field: map<int32, uint32> gap_histogram = 24;\n     */ this.gapHistogram = {};\n        /**\n     * @generated from field: uint32 nacks = 25;\n     */ this.nacks = 0;\n        /**\n     * @generated from field: uint32 nack_acks = 37;\n     */ this.nackAcks = 0;\n        /**\n     * @generated from field: uint32 nack_misses = 26;\n     */ this.nackMisses = 0;\n        /**\n     * @generated from field: uint32 nack_repeated = 38;\n     */ this.nackRepeated = 0;\n        /**\n     * @generated from field: uint32 plis = 27;\n     */ this.plis = 0;\n        /**\n     * @generated from field: uint32 firs = 29;\n     */ this.firs = 0;\n        /**\n     * @generated from field: uint32 rtt_current = 31;\n     */ this.rttCurrent = 0;\n        /**\n     * @generated from field: uint32 rtt_max = 32;\n     */ this.rttMax = 0;\n        /**\n     * @generated from field: uint32 key_frames = 33;\n     */ this.keyFrames = 0;\n        /**\n     * @generated from field: uint32 layer_lock_plis = 35;\n     */ this.layerLockPlis = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RTPStats().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RTPStats().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RTPStats().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RTPStats, a, b);\n    }\n}\nRTPStats.runtime = proto3;\nRTPStats.typeName = \"livekit.RTPStats\";\nRTPStats.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"start_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 2,\n            name: \"end_time\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"duration\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 4,\n            name: \"packets\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"packet_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 6,\n            name: \"bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 39,\n            name: \"header_bytes\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 7,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 8,\n            name: \"packets_lost\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 9,\n            name: \"packet_loss_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 10,\n            name: \"packet_loss_percentage\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        },\n        {\n            no: 11,\n            name: \"packets_duplicate\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 12,\n            name: \"packet_duplicate_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 13,\n            name: \"bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 40,\n            name: \"header_bytes_duplicate\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 14,\n            name: \"bitrate_duplicate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 15,\n            name: \"packets_padding\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 16,\n            name: \"packet_padding_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 17,\n            name: \"bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 41,\n            name: \"header_bytes_padding\",\n            kind: \"scalar\",\n            T: 4 /* ScalarType.UINT64 */ \n        },\n        {\n            no: 18,\n            name: \"bitrate_padding\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 19,\n            name: \"packets_out_of_order\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 20,\n            name: \"frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 21,\n            name: \"frame_rate\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 22,\n            name: \"jitter_current\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 23,\n            name: \"jitter_max\",\n            kind: \"scalar\",\n            T: 1 /* ScalarType.DOUBLE */ \n        },\n        {\n            no: 24,\n            name: \"gap_histogram\",\n            kind: \"map\",\n            K: 5 /* ScalarType.INT32 */ ,\n            V: {\n                kind: \"scalar\",\n                T: 13 /* ScalarType.UINT32 */ \n            }\n        },\n        {\n            no: 25,\n            name: \"nacks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 37,\n            name: \"nack_acks\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 26,\n            name: \"nack_misses\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 38,\n            name: \"nack_repeated\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 27,\n            name: \"plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 28,\n            name: \"last_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 29,\n            name: \"firs\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 30,\n            name: \"last_fir\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 31,\n            name: \"rtt_current\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 32,\n            name: \"rtt_max\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 33,\n            name: \"key_frames\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 34,\n            name: \"last_key_frame\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 35,\n            name: \"layer_lock_plis\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 36,\n            name: \"last_layer_lock_pli\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 44,\n            name: \"packet_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        },\n        {\n            no: 45,\n            name: \"report_drift\",\n            kind: \"message\",\n            T: RTPDrift\n        }\n    ]);\n/**\n * @generated from message livekit.TimedVersion\n */ class TimedVersion extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 unix_micro = 1;\n     */ this.unixMicro = protoInt64.zero;\n        /**\n     * @generated from field: int32 ticks = 2;\n     */ this.ticks = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TimedVersion().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TimedVersion().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TimedVersion().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TimedVersion, a, b);\n    }\n}\nTimedVersion.runtime = proto3;\nTimedVersion.typeName = \"livekit.TimedVersion\";\nTimedVersion.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar R = typeof Reflect === \"object\" ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === \"function\") {\n    ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n} else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n        return Object.getOwnPropertyNames(target);\n    };\n}\nfunction ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction EventEmitter() {\n    EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n    if (typeof listener !== \"function\") {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n}\nObject.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n    enumerable: true,\n    get: function() {\n        return defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n        }\n        defaultMaxListeners = arg;\n    }\n});\nEventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n        throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n    }\n    this._maxListeners = n;\n    return this;\n};\nfunction _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === \"error\";\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n        }\n        // At least give some kind of context to the user\n        var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === \"function\") {\n        ReflectApply(handler, this, args);\n    } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === \"function\") {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [\n                listener,\n                existing\n            ] : [\n                existing,\n                listener\n            ];\n        // If we've already got an array, just append.\n        } else if (prepend) {\n            existing.unshift(listener);\n        } else {\n            existing.push(listener);\n        }\n        // Check for listener leak\n        m = _getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners \" + \"added. Use emitter.setMaxListeners() to \" + \"increase limit\");\n            w.name = \"MaxListenersExceededWarning\";\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction _onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit(\"removeListener\", type, list.listener || listener);\n        }\n    } else if (typeof list !== \"function\") {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--){\n            if (list[i] === listener || list[i].listener === listener) {\n                originalListener = list[i].listener;\n                position = i;\n                break;\n            }\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else {\n            spliceOne(list, position);\n        }\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit(\"removeListener\", type, originalListener || listener);\n    }\n    return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === \"removeListener\") continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners(\"removeListener\");\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === \"function\") {\n        this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n        // LIFO order\n        for(i = listeners.length - 1; i >= 0; i--){\n            this.removeListener(type, listeners[i]);\n        }\n    }\n    return this;\n};\nfunction _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === \"function\") return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === \"function\") {\n        return emitter.listenerCount(type);\n    } else {\n        return listenerCount.call(emitter, type);\n    }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === \"function\") {\n            return 1;\n        } else if (evlistener !== undefined) {\n            return evlistener.length;\n        }\n    }\n    return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i){\n        ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n}\nfunction once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === \"function\") {\n                emitter.removeListener(\"error\", errorListener);\n            }\n            resolve([].slice.call(arguments));\n        }\n        eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== \"error\") {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                once: true\n            });\n        }\n    });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === \"function\") {\n        eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n    }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === \"function\") {\n        if (flags.once) {\n            emitter.once(name, listener);\n        } else {\n            emitter.on(name, listener);\n        }\n    } else if (typeof emitter.addEventListener === \"function\") {\n        // EventTarget does not have `error` event semantics like Node\n        // EventEmitters, we do not listen for `error` events here.\n        emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n                emitter.removeEventListener(name, wrapListener);\n            }\n            listener(arg);\n        });\n    } else {\n        throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n}\nvar eventsExports = events.exports;\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n        get () {\n            return this[\"_on\" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this[\"_on\" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n                delete this[\"_on\" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    logDisabled_ = bool;\n    return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    deprecationWarnings_ = !bool;\n    return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === \"undefined\" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = \"Not a browser.\";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = \"firefox\";\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = \"chrome\";\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = \"safari\";\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && \"currentDirection\" in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = \"Not a supported browser.\";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith(\"Id\")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith(\"Ids\")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === \"track\" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== \"object\" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n                return;\n            }\n            const r = typeof c[key] === \"object\" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === \"number\") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === \"deviceId\" ? \"sourceId\" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === \"number\") {\n                    oc[oldname_(\"min\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_(\"max\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_(\"\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== \"number\") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_(\"\", key)] = r.exact;\n            } else {\n                [\n                    \"min\",\n                    \"max\"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === \"object\") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n            remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === \"object\") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === \"object\" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === \"environment\" || face.ideal === \"environment\") {\n                    matches = [\n                        \"back\",\n                        \"rear\"\n                    ];\n                } else if (face.exact === \"user\" || face.ideal === \"user\") {\n                    matches = [\n                        \"front\"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === \"videoinput\");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes(\"back\")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging(\"chrome: \" + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging(\"chrome: \" + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && \": \") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException(\"\", \"NotFoundError\");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia$1(window1, getSourceId) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    // getSourceId is a function that returns a promise resolving with\n    // the sourceId of the screen/window/tab to be shared.\n    if (typeof getSourceId !== \"function\") {\n        console.error(\"shimGetDisplayMedia: getSourceId argument is not \" + \"a function\");\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        return getSourceId(constraints).then((sourceId)=>{\n            const widthSpecified = constraints.video && constraints.video.width;\n            const heightSpecified = constraints.video && constraints.video.height;\n            const frameRateSpecified = constraints.video && constraints.video.frameRate;\n            constraints.video = {\n                mandatory: {\n                    chromeMediaSource: \"desktop\",\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: frameRateSpecified || 3\n                }\n            };\n            if (widthSpecified) {\n                constraints.video.mandatory.maxWidth = widthSpecified;\n            }\n            if (heightSpecified) {\n                constraints.video.mandatory.maxHeight = heightSpecified;\n            }\n            return window1.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"ontrack\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"ontrack\", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener(\"track\", this._ontrack);\n                }\n                this.addEventListener(\"track\", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener(\"addtrack\", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener(\"addstream\", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, \"transceiver\", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"getSenders\" in window1.RTCPeerConnection.prototype) && \"createDTMFSender\" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === \"audio\") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === \"object\" && window1.RTCPeerConnection && \"getSenders\" in window1.RTCPeerConnection.prototype && \"createDTMFSender\" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !(\"dtmf\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, \"dtmf\", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === \"audio\") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimGetStats(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        // If selector is a function then we are in the old style stats so just\n        // pass back the original getStats format to avoid breaking old users.\n        if (arguments.length > 0 && typeof selector === \"function\") {\n            return origGetStats.apply(this, arguments);\n        }\n        // When spec-style getStats is supported, return those when called with\n        // either no arguments or the selector argument is null.\n        if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== \"function\")) {\n            return origGetStats.apply(this, []);\n        }\n        const fixChromeStats_ = function(response) {\n            const standardReport = {};\n            const reports = response.result();\n            reports.forEach((report)=>{\n                const standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                        localcandidate: \"local-candidate\",\n                        remotecandidate: \"remote-candidate\"\n                    }[report.type] || report.type\n                };\n                report.names().forEach((name)=>{\n                    standardStats[name] = report.stat(name);\n                });\n                standardReport[standardStats.id] = standardStats;\n            });\n            return standardReport;\n        };\n        // shim getStats with maplike support\n        const makeMapStats = function(stats) {\n            return new Map(Object.keys(stats).map((key)=>[\n                    key,\n                    stats[key]\n                ]));\n        };\n        if (arguments.length >= 2) {\n            const successCallbackWrapper_ = function(response) {\n                onSucc(makeMapStats(fixChromeStats_(response)));\n            };\n            return origGetStats.apply(this, [\n                successCallbackWrapper_,\n                selector\n            ]);\n        }\n        // promise-support\n        return new Promise((resolve, reject)=>{\n            origGetStats.apply(this, [\n                function(response) {\n                    resolve(makeMapStats(fixChromeStats_(response)));\n                },\n                reject\n            ]);\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!(\"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype && \"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException(\"The adapter.js addTrack polyfill only supports a single \" + \" stream which is associated with the specified track.\", \"NotSupportedError\");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event(\"negotiationneeded\"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        \"createOffer\",\n        \"createAnswer\"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, \"localDescription\", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === \"\") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack \" + \"does not implement interface RTCRtpSender.\", \"TypeError\");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event(\"negotiationneeded\"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, \"negotiationneeded\", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n            if (pc.signalingState !== \"stable\") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetDisplayMedia: shimGetDisplayMedia$1,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetStats: shimGetStats,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === \"object\" && typeof c.audio === \"object\") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n                remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n                remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === \"audio\" && typeof c === \"object\") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n                    remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException(\"getDisplayMedia without video \" + \"constraints is undefined\");\n            err.name = \"NotFoundError\";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== \"object\" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== \"TypeError\") {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || \"removeStream\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated(\"removeStream\", \"removeTrack\");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if (\"rid\" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError(\"Invalid RID value provided.\");\n                        }\n                    }\n                    if (\"scaleResolutionDownBy\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n                        }\n                    }\n                    if (\"maxFramerate\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError(\"max_framerate must be >= 0.0\");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!(\"encodings\" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getLocalStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!(\"addStream\" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!(\"removeStream\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getRemoteStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!(\"onaddstream\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"onaddstream\", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener(\"addstream\", this._onaddstream);\n                    this.removeEventListener(\"track\", this._onaddstreampoly);\n                }\n                this.addEventListener(\"addstream\", this._onaddstream = f);\n                this.addEventListener(\"track\", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if (\"generateCertificate\" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, \"generateCertificate\", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"audio\");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === \"sendrecv\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        audioTransceiver.direction = \"sendonly\";\n                    }\n                } else if (audioTransceiver.direction === \"recvonly\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"inactive\");\n                    } else {\n                        audioTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver(\"audio\", {\n                    direction: \"recvonly\"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"video\");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === \"sendrecv\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        videoTransceiver.direction = \"sendonly\";\n                    }\n                } else if (videoTransceiver.direction === \"recvonly\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"inactive\");\n                    } else {\n                        videoTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver(\"video\", {\n                    direction: \"recvonly\"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== \"object\" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ (function(module) {\n    // SDP helpers.\n    const SDPUtils = {};\n    // Generate an alphanumeric identifier for cname or mids.\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n    SDPUtils.generateIdentifier = function() {\n        return Math.random().toString(36).substring(2, 12);\n    };\n    // The RTCP CNAME used by all peerconnections from the same JS.\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\n    // Splits SDP into lines, dealing with both CRLF and LF.\n    SDPUtils.splitLines = function(blob) {\n        return blob.trim().split(\"\\n\").map((line)=>line.trim());\n    };\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n    SDPUtils.splitSections = function(blob) {\n        const parts = blob.split(\"\\nm=\");\n        return parts.map((part, index)=>(index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n    };\n    // Returns the session description.\n    SDPUtils.getDescription = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        return sections && sections[0];\n    };\n    // Returns the individual media sections.\n    SDPUtils.getMediaSections = function(blob) {\n        const sections = SDPUtils.splitSections(blob);\n        sections.shift();\n        return sections;\n    };\n    // Returns lines that start with a certain prefix.\n    SDPUtils.matchPrefix = function(blob, prefix) {\n        return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n    };\n    // Parses an ICE candidate line. Sample input:\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n    // rport 55996\"\n    // Input can be prefixed with a=.\n    SDPUtils.parseCandidate = function(line) {\n        let parts;\n        // Parse both variants.\n        if (line.indexOf(\"a=candidate:\") === 0) {\n            parts = line.substring(12).split(\" \");\n        } else {\n            parts = line.substring(10).split(\" \");\n        }\n        const candidate = {\n            foundation: parts[0],\n            component: {\n                1: \"rtp\",\n                2: \"rtcp\"\n            }[parts[1]] || parts[1],\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            address: parts[4],\n            // address is an alias for ip.\n            port: parseInt(parts[5], 10),\n            // skip parts[6] == 'typ'\n            type: parts[7]\n        };\n        for(let i = 8; i < parts.length; i += 2){\n            switch(parts[i]){\n                case \"raddr\":\n                    candidate.relatedAddress = parts[i + 1];\n                    break;\n                case \"rport\":\n                    candidate.relatedPort = parseInt(parts[i + 1], 10);\n                    break;\n                case \"tcptype\":\n                    candidate.tcpType = parts[i + 1];\n                    break;\n                case \"ufrag\":\n                    candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                    candidate.usernameFragment = parts[i + 1];\n                    break;\n                default:\n                    // extension handling, in particular ufrag. Don't overwrite.\n                    if (candidate[parts[i]] === undefined) {\n                        candidate[parts[i]] = parts[i + 1];\n                    }\n                    break;\n            }\n        }\n        return candidate;\n    };\n    // Translates a candidate object into SDP candidate attribute.\n    // This does not include the a= prefix!\n    SDPUtils.writeCandidate = function(candidate) {\n        const sdp = [];\n        sdp.push(candidate.foundation);\n        const component = candidate.component;\n        if (component === \"rtp\") {\n            sdp.push(1);\n        } else if (component === \"rtcp\") {\n            sdp.push(2);\n        } else {\n            sdp.push(component);\n        }\n        sdp.push(candidate.protocol.toUpperCase());\n        sdp.push(candidate.priority);\n        sdp.push(candidate.address || candidate.ip);\n        sdp.push(candidate.port);\n        const type = candidate.type;\n        sdp.push(\"typ\");\n        sdp.push(type);\n        if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n            sdp.push(\"raddr\");\n            sdp.push(candidate.relatedAddress);\n            sdp.push(\"rport\");\n            sdp.push(candidate.relatedPort);\n        }\n        if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n            sdp.push(\"tcptype\");\n            sdp.push(candidate.tcpType);\n        }\n        if (candidate.usernameFragment || candidate.ufrag) {\n            sdp.push(\"ufrag\");\n            sdp.push(candidate.usernameFragment || candidate.ufrag);\n        }\n        return \"candidate:\" + sdp.join(\" \");\n    };\n    // Parses an ice-options line, returns an array of option tags.\n    // Sample input:\n    // a=ice-options:foo bar\n    SDPUtils.parseIceOptions = function(line) {\n        return line.substring(14).split(\" \");\n    };\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n    // a=rtpmap:111 opus/48000/2\n    SDPUtils.parseRtpMap = function(line) {\n        let parts = line.substring(9).split(\" \");\n        const parsed = {\n            payloadType: parseInt(parts.shift(), 10) // was: id\n        };\n        parts = parts[0].split(\"/\");\n        parsed.name = parts[0];\n        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n        // legacy alias, got renamed back to channels in ORTC.\n        parsed.numChannels = parsed.channels;\n        return parsed;\n    };\n    // Generates a rtpmap line from RTCRtpCodecCapability or\n    // RTCRtpCodecParameters.\n    SDPUtils.writeRtpMap = function(codec) {\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        const channels = codec.channels || codec.numChannels || 1;\n        return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n    };\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n    SDPUtils.parseExtmap = function(line) {\n        const parts = line.substring(9).split(\" \");\n        return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n            uri: parts[1],\n            attributes: parts.slice(2).join(\" \")\n        };\n    };\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n    // RTCRtpHeaderExtension.\n    SDPUtils.writeExtmap = function(headerExtension) {\n        return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n    };\n    // Parses a fmtp line, returns dictionary. Sample input:\n    // a=fmtp:96 vbr=on;cng=on\n    // Also deals with vbr=on; cng=on\n    SDPUtils.parseFmtp = function(line) {\n        const parsed = {};\n        let kv;\n        const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n        for(let j = 0; j < parts.length; j++){\n            kv = parts[j].trim().split(\"=\");\n            parsed[kv[0].trim()] = kv[1];\n        }\n        return parsed;\n    };\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeFmtp = function(codec) {\n        let line = \"\";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.parameters && Object.keys(codec.parameters).length) {\n            const params = [];\n            Object.keys(codec.parameters).forEach((param)=>{\n                if (codec.parameters[param] !== undefined) {\n                    params.push(param + \"=\" + codec.parameters[param]);\n                } else {\n                    params.push(param);\n                }\n            });\n            line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n        }\n        return line;\n    };\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n    // a=rtcp-fb:98 nack rpsi\n    SDPUtils.parseRtcpFb = function(line) {\n        const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n        return {\n            type: parts.shift(),\n            parameter: parts.join(\" \")\n        };\n    };\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n    SDPUtils.writeRtcpFb = function(codec) {\n        let lines = \"\";\n        let pt = codec.payloadType;\n        if (codec.preferredPayloadType !== undefined) {\n            pt = codec.preferredPayloadType;\n        }\n        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n            // FIXME: special handling for trr-int?\n            codec.rtcpFeedback.forEach((fb)=>{\n                lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n            });\n        }\n        return lines;\n    };\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\n    // a=ssrc:3735928559 cname:something\n    SDPUtils.parseSsrcMedia = function(line) {\n        const sp = line.indexOf(\" \");\n        const parts = {\n            ssrc: parseInt(line.substring(7, sp), 10)\n        };\n        const colon = line.indexOf(\":\", sp);\n        if (colon > -1) {\n            parts.attribute = line.substring(sp + 1, colon);\n            parts.value = line.substring(colon + 1);\n        } else {\n            parts.attribute = line.substring(sp + 1);\n        }\n        return parts;\n    };\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\n    // a=ssrc-group:semantics 12 34\n    SDPUtils.parseSsrcGroup = function(line) {\n        const parts = line.substring(13).split(\" \");\n        return {\n            semantics: parts.shift(),\n            ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n        };\n    };\n    // Extracts the MID (RFC 5888) from a media section.\n    // Returns the MID or undefined if no mid line was found.\n    SDPUtils.getMid = function(mediaSection) {\n        const mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n        if (mid) {\n            return mid.substring(6);\n        }\n    };\n    // Parses a fingerprint line for DTLS-SRTP.\n    SDPUtils.parseFingerprint = function(line) {\n        const parts = line.substring(14).split(\" \");\n        return {\n            algorithm: parts[0].toLowerCase(),\n            // algorithm is case-sensitive in Edge.\n            value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n        };\n    };\n    // Extracts DTLS parameters from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the fingerprint line as input. See also getIceParameters.\n    SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n        // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n        return {\n            role: \"auto\",\n            fingerprints: lines.map(SDPUtils.parseFingerprint)\n        };\n    };\n    // Serializes DTLS parameters to SDP.\n    SDPUtils.writeDtlsParameters = function(params, setupType) {\n        let sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n        params.fingerprints.forEach((fp)=>{\n            sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n        });\n        return sdp;\n    };\n    // Parses a=crypto lines into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n    SDPUtils.parseCryptoLine = function(line) {\n        const parts = line.substring(9).split(\" \");\n        return {\n            tag: parseInt(parts[0], 10),\n            cryptoSuite: parts[1],\n            keyParams: parts[2],\n            sessionParams: parts.slice(3)\n        };\n    };\n    SDPUtils.writeCryptoLine = function(parameters) {\n        return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n    };\n    // Parses the crypto key parameters into\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n    SDPUtils.parseCryptoKeyParams = function(keyParams) {\n        if (keyParams.indexOf(\"inline:\") !== 0) {\n            return null;\n        }\n        const parts = keyParams.substring(7).split(\"|\");\n        return {\n            keyMethod: \"inline\",\n            keySalt: parts[0],\n            lifeTime: parts[1],\n            mkiValue: parts[2] ? parts[2].split(\":\")[0] : undefined,\n            mkiLength: parts[2] ? parts[2].split(\":\")[1] : undefined\n        };\n    };\n    SDPUtils.writeCryptoKeyParams = function(keyParams) {\n        return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n    };\n    // Extracts all SDES parameters.\n    SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n        const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n        return lines.map(SDPUtils.parseCryptoLine);\n    };\n    // Parses ICE information from SDP media section or sessionpart.\n    // FIXME: for consistency with other functions this should only\n    //   get the ice-ufrag and ice-pwd lines as input.\n    SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n        const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n        const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n        if (!(ufrag && pwd)) {\n            return null;\n        }\n        return {\n            usernameFragment: ufrag.substring(12),\n            password: pwd.substring(10)\n        };\n    };\n    // Serializes ICE parameters to SDP.\n    SDPUtils.writeIceParameters = function(params) {\n        let sdp = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\n\" + \"a=ice-pwd:\" + params.password + \"\\r\\n\";\n        if (params.iceLite) {\n            sdp += \"a=ice-lite\\r\\n\";\n        }\n        return sdp;\n    };\n    // Parses the SDP media section and returns RTCRtpParameters.\n    SDPUtils.parseRtpParameters = function(mediaSection) {\n        const description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n        };\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(\" \");\n        description.profile = mline[2];\n        for(let i = 3; i < mline.length; i++){\n            // find all codecs from mline[3..]\n            const pt = mline[i];\n            const rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n            if (rtpmapline) {\n                const codec = SDPUtils.parseRtpMap(rtpmapline);\n                const fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n                // Only the first a=fmtp:<pt> is considered.\n                codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb);\n                description.codecs.push(codec);\n                // parse FEC mechanisms from rtpmap lines.\n                switch(codec.name.toUpperCase()){\n                    case \"RED\":\n                    case \"ULPFEC\":\n                        description.fecMechanisms.push(codec.name.toUpperCase());\n                        break;\n                }\n            }\n        }\n        SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach((line)=>{\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n        });\n        const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils.parseRtcpFb);\n        description.codecs.forEach((codec)=>{\n            wildcardRtcpFb.forEach((fb)=>{\n                const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                    return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                });\n                if (!duplicate) {\n                    codec.rtcpFeedback.push(fb);\n                }\n            });\n        });\n        // FIXME: parse rtcp.\n        return description;\n    };\n    // Generates parts of the SDP media section describing the capabilities /\n    // parameters.\n    SDPUtils.writeRtpDescription = function(kind, caps) {\n        let sdp = \"\";\n        // Build the mline.\n        sdp += \"m=\" + kind + \" \";\n        sdp += caps.codecs.length > 0 ? \"9\" : \"0\"; // reject if no codecs.\n        sdp += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n        sdp += caps.codecs.map((codec)=>{\n            if (codec.preferredPayloadType !== undefined) {\n                return codec.preferredPayloadType;\n            }\n            return codec.payloadType;\n        }).join(\" \") + \"\\r\\n\";\n        sdp += \"c=IN IP4 0.0.0.0\\r\\n\";\n        sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n        caps.codecs.forEach((codec)=>{\n            sdp += SDPUtils.writeRtpMap(codec);\n            sdp += SDPUtils.writeFmtp(codec);\n            sdp += SDPUtils.writeRtcpFb(codec);\n        });\n        let maxptime = 0;\n        caps.codecs.forEach((codec)=>{\n            if (codec.maxptime > maxptime) {\n                maxptime = codec.maxptime;\n            }\n        });\n        if (maxptime > 0) {\n            sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n        }\n        if (caps.headerExtensions) {\n            caps.headerExtensions.forEach((extension)=>{\n                sdp += SDPUtils.writeExtmap(extension);\n            });\n        }\n        // FIXME: write fecMechanisms.\n        return sdp;\n    };\n    // Parses the SDP media section and returns an array of\n    // RTCRtpEncodingParameters.\n    SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n        const encodingParameters = [];\n        const description = SDPUtils.parseRtpParameters(mediaSection);\n        const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n        const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n        // filter a=ssrc:... cname:, ignore PlanB-msid\n        const ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === \"cname\");\n        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n        let secondarySsrc;\n        const flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line)=>{\n            const parts = line.substring(17).split(\" \");\n            return parts.map((part)=>parseInt(part, 10));\n        });\n        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n            secondarySsrc = flows[0][1];\n        }\n        description.codecs.forEach((codec)=>{\n            if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n                let encParam = {\n                    ssrc: primarySsrc,\n                    codecPayloadType: parseInt(codec.parameters.apt, 10)\n                };\n                if (primarySsrc && secondarySsrc) {\n                    encParam.rtx = {\n                        ssrc: secondarySsrc\n                    };\n                }\n                encodingParameters.push(encParam);\n                if (hasRed) {\n                    encParam = JSON.parse(JSON.stringify(encParam));\n                    encParam.fec = {\n                        ssrc: primarySsrc,\n                        mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n                    };\n                    encodingParameters.push(encParam);\n                }\n            }\n        });\n        if (encodingParameters.length === 0 && primarySsrc) {\n            encodingParameters.push({\n                ssrc: primarySsrc\n            });\n        }\n        // we support both b=AS and b=TIAS but interpret AS as TIAS.\n        let bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n        if (bandwidth.length) {\n            if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n                bandwidth = parseInt(bandwidth[0].substring(7), 10);\n            } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n                // use formula from JSEP to convert b=AS to TIAS value.\n                bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n            } else {\n                bandwidth = undefined;\n            }\n            encodingParameters.forEach((params)=>{\n                params.maxBitrate = bandwidth;\n            });\n        }\n        return encodingParameters;\n    };\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\n    SDPUtils.parseRtcpParameters = function(mediaSection) {\n        const rtcpParameters = {};\n        // Gets the first SSRC. Note that with RTX there might be multiple\n        // SSRCs.\n        const remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === \"cname\")[0];\n        if (remoteSsrc) {\n            rtcpParameters.cname = remoteSsrc.value;\n            rtcpParameters.ssrc = remoteSsrc.ssrc;\n        }\n        // Edge uses the compound attribute instead of reducedSize\n        // compound is !reducedSize\n        const rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n        rtcpParameters.reducedSize = rsize.length > 0;\n        rtcpParameters.compound = rsize.length === 0;\n        // parses the rtcp-mux attrbute.\n        // Note that Edge does not support unmuxed RTCP.\n        const mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n        rtcpParameters.mux = mux.length > 0;\n        return rtcpParameters;\n    };\n    SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n        let sdp = \"\";\n        if (rtcpParameters.reducedSize) {\n            sdp += \"a=rtcp-rsize\\r\\n\";\n        }\n        if (rtcpParameters.mux) {\n            sdp += \"a=rtcp-mux\\r\\n\";\n        }\n        if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n            sdp += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n        }\n        return sdp;\n    };\n    // parses either a=msid: or a=ssrc:... msid lines and returns\n    // the id of the MediaStream and MediaStreamTrack.\n    SDPUtils.parseMsid = function(mediaSection) {\n        let parts;\n        const spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n        if (spec.length === 1) {\n            parts = spec[0].substring(7).split(\" \");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n        const planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === \"msid\");\n        if (planB.length > 0) {\n            parts = planB[0].value.split(\" \");\n            return {\n                stream: parts[0],\n                track: parts[1]\n            };\n        }\n    };\n    // SCTP\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n    // to draft-ietf-mmusic-sctp-sdp-05\n    SDPUtils.parseSctpDescription = function(mediaSection) {\n        const mline = SDPUtils.parseMLine(mediaSection);\n        const maxSizeLine = SDPUtils.matchPrefix(mediaSection, \"a=max-message-size:\");\n        let maxMessageSize;\n        if (maxSizeLine.length > 0) {\n            maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n        }\n        if (isNaN(maxMessageSize)) {\n            maxMessageSize = 65536;\n        }\n        const sctpPort = SDPUtils.matchPrefix(mediaSection, \"a=sctp-port:\");\n        if (sctpPort.length > 0) {\n            return {\n                port: parseInt(sctpPort[0].substring(12), 10),\n                protocol: mline.fmt,\n                maxMessageSize\n            };\n        }\n        const sctpMapLines = SDPUtils.matchPrefix(mediaSection, \"a=sctpmap:\");\n        if (sctpMapLines.length > 0) {\n            const parts = sctpMapLines[0].substring(10).split(\" \");\n            return {\n                port: parseInt(parts[0], 10),\n                protocol: parts[1],\n                maxMessageSize\n            };\n        }\n    };\n    // SCTP\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n    // support by now receiving in this format, unless we originally parsed\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n    SDPUtils.writeSctpDescription = function(media, sctp) {\n        let output = [];\n        if (media.protocol !== \"DTLS/SCTP\") {\n            output = [\n                \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\",\n                \"c=IN IP4 0.0.0.0\\r\\n\",\n                \"a=sctp-port:\" + sctp.port + \"\\r\\n\"\n            ];\n        } else {\n            output = [\n                \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\",\n                \"c=IN IP4 0.0.0.0\\r\\n\",\n                \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"\n            ];\n        }\n        if (sctp.maxMessageSize !== undefined) {\n            output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n        }\n        return output.join(\"\");\n    };\n    // Generate a session ID for SDP.\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n    // recommends using a cryptographically random +ve 64-bit value\n    // but right now this should be acceptable and within the right range\n    SDPUtils.generateSessionId = function() {\n        return Math.random().toString().substr(2, 22);\n    };\n    // Write boiler plate for start of SDP\n    // sessId argument is optional - if not supplied it will\n    // be generated randomly\n    // sessVersion is optional and defaults to 2\n    // sessUser is optional and defaults to 'thisisadapterortc'\n    SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n        let sessionId;\n        const version = sessVer !== undefined ? sessVer : 2;\n        if (sessId) {\n            sessionId = sessId;\n        } else {\n            sessionId = SDPUtils.generateSessionId();\n        }\n        const user = sessUser || \"thisisadapterortc\";\n        // FIXME: sess-id should be an NTP timestamp.\n        return \"v=0\\r\\n\" + \"o=\" + user + \" \" + sessionId + \" \" + version + \" IN IP4 127.0.0.1\\r\\n\" + \"s=-\\r\\n\" + \"t=0 0\\r\\n\";\n    };\n    // Gets the direction from the mediaSection or the sessionpart.\n    SDPUtils.getDirection = function(mediaSection, sessionpart) {\n        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n        const lines = SDPUtils.splitLines(mediaSection);\n        for(let i = 0; i < lines.length; i++){\n            switch(lines[i]){\n                case \"a=sendrecv\":\n                case \"a=sendonly\":\n                case \"a=recvonly\":\n                case \"a=inactive\":\n                    return lines[i].substring(2);\n            }\n        }\n        if (sessionpart) {\n            return SDPUtils.getDirection(sessionpart);\n        }\n        return \"sendrecv\";\n    };\n    SDPUtils.getKind = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const mline = lines[0].split(\" \");\n        return mline[0].substring(2);\n    };\n    SDPUtils.isRejected = function(mediaSection) {\n        return mediaSection.split(\" \", 2)[1] === \"0\";\n    };\n    SDPUtils.parseMLine = function(mediaSection) {\n        const lines = SDPUtils.splitLines(mediaSection);\n        const parts = lines[0].substring(2).split(\" \");\n        return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(\" \")\n        };\n    };\n    SDPUtils.parseOLine = function(mediaSection) {\n        const line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0];\n        const parts = line.substring(2).split(\" \");\n        return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n        };\n    };\n    // a very naive interpretation of a valid SDP.\n    SDPUtils.isValidSDP = function(blob) {\n        if (typeof blob !== \"string\" || blob.length === 0) {\n            return false;\n        }\n        const lines = SDPUtils.splitLines(blob);\n        for(let i = 0; i < lines.length; i++){\n            if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n                return false;\n            }\n        // TODO: check the modifier a bit more.\n        }\n        return true;\n    };\n    // Expose public methods.\n    {\n        module.exports = SDPUtils;\n    }\n})(sdp$1);\nvar sdpExports = sdp$1.exports;\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"foundation\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, \"candidate\", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: \"false\"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"relayProtocol\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === \"relay\") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: \"tls\",\n                    1: \"tcp\",\n                    2: \"udp\"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"sctp\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"sctp\", {\n            get () {\n                return typeof this._sctp === \"undefined\" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === \"firefox\") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === \"plan-b\") {\n                Object.defineProperty(this, \"sctp\", {\n                    get () {\n                        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, \"maxMessageSize\", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && \"createDataChannel\" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, \"datachannel\", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || \"connectionState\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, \"connectionState\", {\n        get () {\n            return ({\n                completed: \"connected\",\n                checking: \"connecting\"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, \"onconnectionstatechange\", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        \"setLocalDescription\",\n        \"setRemoteDescription\"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event(\"connectionstatechange\", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n            const sdp = desc.sdp.split(\"\\n\").filter((line)=>{\n                return line.trim() !== \"a=extmap-allow-mixed\";\n            }).join(\"\\n\");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case \"stable\":\n                case \"have-local-offer\":\n                case \"have-remote-pranswer\":\n                    desc.type = \"offer\";\n                    break;\n                default:\n                    desc.type = \"answer\";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case \"chrome\":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging(\"Chrome shim is not included in this adapter release.\");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging(\"Chrome shim can not determine version, not shimming.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming chrome.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimGetStats(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case \"firefox\":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging(\"Firefox shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming firefox.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case \"safari\":\n            if (!safariShim || !options.shimSafari) {\n                logging(\"Safari shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming safari.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging(\"Unsupported browser!\");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = \"lk_e2ee\";\nconst SALT = \"LKFrameEncryptionKey\";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== \"undefined\";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== \"undefined\" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== \"undefined\";\n}\nfunction isVideoFrame(frame) {\n    return \"type\" in frame;\n}\nfunction importKey(keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"encrypt\";\n    return __awaiter(this, void 0, void 0, function*() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n        return crypto.subtle.importKey(\"raw\", keyBytes, algorithm, false, usage === \"derive\" ? [\n            \"deriveBits\",\n            \"deriveKey\"\n        ] : [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", enc.encode(password), {\n            name: \"PBKDF2\"\n        }, false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", cryptoBuffer, \"HKDF\", false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case \"HKDF\":\n            return {\n                name: \"HKDF\",\n                salt: encodedSalt,\n                hash: \"SHA-256\",\n                info: new ArrayBuffer(128)\n            };\n        case \"PBKDF2\":\n            {\n                return {\n                    name: \"PBKDF2\",\n                    salt: encodedSalt,\n                    hash: \"SHA-256\",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug(\"key ratcheted event received\", {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : \"shared\", \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === \"string\" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || \"an error has occured\");\n        this.code = code;\n    }\n}\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status){\n        super(1, message);\n        this.status = status;\n        this.reason = reason;\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to publish data\");\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && \"name\" in error) {\n            if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * @deprecated StateChanged has been renamed to ConnectionStateChanged\n   */ RoomEvent[\"StateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed. Currently only fired on LocalParticipant.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n})(TrackEvent || (TrackEvent = {}));\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === \"undefined\" && typeof navigator === \"undefined\") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: \"Firefox\",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"fxios\") ? \"iOS\" : undefined\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: \"Chrome\",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"crios\") ? \"iOS\" : undefined\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: \"Safari\",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes(\"mobile/\") ? \"iOS\" : \"macOS\"\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || \"\";\n}\nvar version$1 = \"1.15.5\";\nconst version = version$1;\nconst protocolVersion = 11;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\nCriticalTimers.setInterval = function() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nclass VideoPreset {\n    constructor(width, height, maxBitrate, maxFramerate, priority){\n        this.width = width;\n        this.height = height;\n        this.encoding = {\n            maxBitrate,\n            maxFramerate,\n            priority\n        };\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.width / this.height\n        };\n    }\n}\nconst backupCodecs = [\n    \"vp8\",\n    \"h264\"\n];\nconst videoCodecs = [\n    \"vp8\",\n    \"h264\",\n    \"vp9\",\n    \"av1\"\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 20000\n    };\n    AudioPresets.music = {\n        maxBitrate: 32000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 96000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, \"medium\"),\n    h720fps5: new VideoPreset(1280, 720, 400000, 5, \"medium\"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, \"medium\"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, \"medium\"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, \"medium\"),\n    h1080fps30: new VideoPreset(1920, 1080, 4000000, 30, \"medium\")\n};\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * @generated from enum livekit.SignalTarget\n */ var SignalTarget;\n(function(SignalTarget) {\n    /**\n   * @generated from enum value: PUBLISHER = 0;\n   */ SignalTarget[SignalTarget[\"PUBLISHER\"] = 0] = \"PUBLISHER\";\n    /**\n   * @generated from enum value: SUBSCRIBER = 1;\n   */ SignalTarget[SignalTarget[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(SignalTarget || (SignalTarget = {}));\n// Retrieve enum metadata with: proto3.getEnumType(SignalTarget)\nproto3.util.setEnumType(SignalTarget, \"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\n/**\n * @generated from enum livekit.StreamState\n */ var StreamState;\n(function(StreamState) {\n    /**\n   * @generated from enum value: ACTIVE = 0;\n   */ StreamState[StreamState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    /**\n   * @generated from enum value: PAUSED = 1;\n   */ StreamState[StreamState[\"PAUSED\"] = 1] = \"PAUSED\";\n})(StreamState || (StreamState = {}));\n// Retrieve enum metadata with: proto3.getEnumType(StreamState)\nproto3.util.setEnumType(StreamState, \"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\n/**\n * @generated from enum livekit.CandidateProtocol\n */ var CandidateProtocol;\n(function(CandidateProtocol) {\n    /**\n   * @generated from enum value: UDP = 0;\n   */ CandidateProtocol[CandidateProtocol[\"UDP\"] = 0] = \"UDP\";\n    /**\n   * @generated from enum value: TCP = 1;\n   */ CandidateProtocol[CandidateProtocol[\"TCP\"] = 1] = \"TCP\";\n    /**\n   * @generated from enum value: TLS = 2;\n   */ CandidateProtocol[CandidateProtocol[\"TLS\"] = 2] = \"TLS\";\n})(CandidateProtocol || (CandidateProtocol = {}));\n// Retrieve enum metadata with: proto3.getEnumType(CandidateProtocol)\nproto3.util.setEnumType(CandidateProtocol, \"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\n/**\n * @generated from message livekit.SignalRequest\n */ class SignalRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalRequest.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalRequest, a, b);\n    }\n}\nSignalRequest.runtime = proto3;\nSignalRequest.typeName = \"livekit.SignalRequest\";\nSignalRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SignalResponse\n */ class SignalResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SignalResponse.message\n     */ this.message = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SignalResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SignalResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SignalResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SignalResponse, a, b);\n    }\n}\nSignalResponse.runtime = proto3;\nSignalResponse.typeName = \"livekit.SignalResponse\";\nSignalResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        }\n    ]);\n/**\n * @generated from message livekit.SimulcastCodec\n */ class SimulcastCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: string cid = 2;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulcastCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulcastCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulcastCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulcastCodec, a, b);\n    }\n}\nSimulcastCodec.runtime = proto3;\nSimulcastCodec.typeName = \"livekit.SimulcastCodec\";\nSimulcastCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.AddTrackRequest\n */ class AddTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * client ID of track, to match it when RTC track is received\n     *\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        /**\n     * @generated from field: livekit.TrackType type = 3;\n     */ this.type = TrackType.AUDIO;\n        /**\n     * to be deprecated in favor of layers\n     *\n     * @generated from field: uint32 width = 4;\n     */ this.width = 0;\n        /**\n     * @generated from field: uint32 height = 5;\n     */ this.height = 0;\n        /**\n     * true to add track and initialize to muted\n     *\n     * @generated from field: bool muted = 6;\n     */ this.muted = false;\n        /**\n     * true if DTX (Discontinuous Transmission) is disabled for audio\n     *\n     * @generated from field: bool disable_dtx = 7;\n     */ this.disableDtx = false;\n        /**\n     * @generated from field: livekit.TrackSource source = 8;\n     */ this.source = TrackSource.UNKNOWN;\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 9;\n     */ this.layers = [];\n        /**\n     * @generated from field: repeated livekit.SimulcastCodec simulcast_codecs = 10;\n     */ this.simulcastCodecs = [];\n        /**\n     * server ID of track, publish new codec to exist track\n     *\n     * @generated from field: string sid = 11;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool stereo = 12;\n     */ this.stereo = false;\n        /**\n     * true if RED (Redundant Encoding) is disabled for audio\n     *\n     * @generated from field: bool disable_red = 13;\n     */ this.disableRed = false;\n        /**\n     * @generated from field: livekit.Encryption.Type encryption = 14;\n     */ this.encryption = Encryption_Type.NONE;\n        /**\n     * which stream the track belongs to, used to group tracks together.\n     * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together\n     *\n     * @generated from field: string stream = 15;\n     */ this.stream = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new AddTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new AddTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new AddTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(AddTrackRequest, a, b);\n    }\n}\nAddTrackRequest.runtime = proto3;\nAddTrackRequest.typeName = \"livekit.AddTrackRequest\";\nAddTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.TrickleRequest\n */ class TrickleRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string candidateInit = 1;\n     */ this.candidateInit = \"\";\n        /**\n     * @generated from field: livekit.SignalTarget target = 2;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrickleRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrickleRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrickleRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrickleRequest, a, b);\n    }\n}\nTrickleRequest.runtime = proto3;\nTrickleRequest.typeName = \"livekit.TrickleRequest\";\nTrickleRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.MuteTrackRequest\n */ class MuteTrackRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string sid = 1;\n     */ this.sid = \"\";\n        /**\n     * @generated from field: bool muted = 2;\n     */ this.muted = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new MuteTrackRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new MuteTrackRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new MuteTrackRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(MuteTrackRequest, a, b);\n    }\n}\nMuteTrackRequest.runtime = proto3;\nMuteTrackRequest.typeName = \"livekit.MuteTrackRequest\";\nMuteTrackRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.JoinResponse\n */ class JoinResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo other_participants = 3;\n     */ this.otherParticipants = [];\n        /**\n     * deprecated. use server_info.version instead.\n     *\n     * @generated from field: string server_version = 4;\n     */ this.serverVersion = \"\";\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 5;\n     */ this.iceServers = [];\n        /**\n     * use subscriber as the primary PeerConnection\n     *\n     * @generated from field: bool subscriber_primary = 6;\n     */ this.subscriberPrimary = false;\n        /**\n     * when the current server isn't available, return alternate url to retry connection\n     * when this is set, the other fields will be largely empty\n     *\n     * @generated from field: string alternative_url = 7;\n     */ this.alternativeUrl = \"\";\n        /**\n     * deprecated. use server_info.region instead.\n     *\n     * @generated from field: string server_region = 9;\n     */ this.serverRegion = \"\";\n        /**\n     * @generated from field: int32 ping_timeout = 10;\n     */ this.pingTimeout = 0;\n        /**\n     * @generated from field: int32 ping_interval = 11;\n     */ this.pingInterval = 0;\n        /**\n     * Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled\n     *\n     * @generated from field: bytes sif_trailer = 13;\n     */ this.sifTrailer = new Uint8Array(0);\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new JoinResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new JoinResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new JoinResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(JoinResponse, a, b);\n    }\n}\nJoinResponse.runtime = proto3;\nJoinResponse.typeName = \"livekit.JoinResponse\";\nJoinResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12 /* ScalarType.BYTES */ \n        }\n    ]);\n/**\n * @generated from message livekit.ReconnectResponse\n */ class ReconnectResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ICEServer ice_servers = 1;\n     */ this.iceServers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ReconnectResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ReconnectResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ReconnectResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ReconnectResponse, a, b);\n    }\n}\nReconnectResponse.runtime = proto3;\nReconnectResponse.typeName = \"livekit.ReconnectResponse\";\nReconnectResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPublishedResponse\n */ class TrackPublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string cid = 1;\n     */ this.cid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPublishedResponse, a, b);\n    }\n}\nTrackPublishedResponse.runtime = proto3;\nTrackPublishedResponse.typeName = \"livekit.TrackPublishedResponse\";\nTrackPublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\n/**\n * @generated from message livekit.TrackUnpublishedResponse\n */ class TrackUnpublishedResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackUnpublishedResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackUnpublishedResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackUnpublishedResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackUnpublishedResponse, a, b);\n    }\n}\nTrackUnpublishedResponse.runtime = proto3;\nTrackUnpublishedResponse.typeName = \"livekit.TrackUnpublishedResponse\";\nTrackUnpublishedResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SessionDescription\n */ class SessionDescription extends Message {\n    constructor(data){\n        super();\n        /**\n     * \"answer\" | \"offer\" | \"pranswer\" | \"rollback\"\n     *\n     * @generated from field: string type = 1;\n     */ this.type = \"\";\n        /**\n     * @generated from field: string sdp = 2;\n     */ this.sdp = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SessionDescription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SessionDescription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SessionDescription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SessionDescription, a, b);\n    }\n}\nSessionDescription.runtime = proto3;\nSessionDescription.typeName = \"livekit.SessionDescription\";\nSessionDescription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ParticipantUpdate\n */ class ParticipantUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ParticipantInfo participants = 1;\n     */ this.participants = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ParticipantUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ParticipantUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ParticipantUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ParticipantUpdate, a, b);\n    }\n}\nParticipantUpdate.runtime = proto3;\nParticipantUpdate.typeName = \"livekit.ParticipantUpdate\";\nParticipantUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateSubscription\n */ class UpdateSubscription extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: bool subscribe = 2;\n     */ this.subscribe = false;\n        /**\n     * @generated from field: repeated livekit.ParticipantTracks participant_tracks = 3;\n     */ this.participantTracks = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateSubscription().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateSubscription().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateSubscription().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateSubscription, a, b);\n    }\n}\nUpdateSubscription.runtime = proto3;\nUpdateSubscription.typeName = \"livekit.UpdateSubscription\";\nUpdateSubscription.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateTrackSettings\n */ class UpdateTrackSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string track_sids = 1;\n     */ this.trackSids = [];\n        /**\n     * when true, the track is placed in a paused state, with no new data returned\n     *\n     * @generated from field: bool disabled = 3;\n     */ this.disabled = false;\n        /**\n     * deprecated in favor of width & height\n     *\n     * @generated from field: livekit.VideoQuality quality = 4;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * for video, width to receive\n     *\n     * @generated from field: uint32 width = 5;\n     */ this.width = 0;\n        /**\n     * for video, height to receive\n     *\n     * @generated from field: uint32 height = 6;\n     */ this.height = 0;\n        /**\n     * @generated from field: uint32 fps = 7;\n     */ this.fps = 0;\n        /**\n     * subscription priority. 1 being the highest (0 is unset)\n     * when unset, server sill assign priority based on the order of subscription\n     * server will use priority in the following ways:\n     * 1. when subscribed tracks exceed per-participant subscription limit, server will\n     *    pause the lowest priority tracks\n     * 2. when the network is congested, server will assign available bandwidth to\n     *    higher priority tracks first. lowest priority tracks can be paused\n     *\n     * @generated from field: uint32 priority = 8;\n     */ this.priority = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateTrackSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateTrackSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateTrackSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateTrackSettings, a, b);\n    }\n}\nUpdateTrackSettings.runtime = proto3;\nUpdateTrackSettings.typeName = \"livekit.UpdateTrackSettings\";\nUpdateTrackSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        }\n    ]);\n/**\n * @generated from message livekit.LeaveRequest\n */ class LeaveRequest extends Message {\n    constructor(data){\n        super();\n        /**\n     * sent when server initiates the disconnect due to server-restart\n     * indicates clients should attempt full-reconnect sequence\n     *\n     * @generated from field: bool can_reconnect = 1;\n     */ this.canReconnect = false;\n        /**\n     * @generated from field: livekit.DisconnectReason reason = 2;\n     */ this.reason = DisconnectReason.UNKNOWN_REASON;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new LeaveRequest().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new LeaveRequest().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new LeaveRequest().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(LeaveRequest, a, b);\n    }\n}\nLeaveRequest.runtime = proto3;\nLeaveRequest.typeName = \"livekit.LeaveRequest\";\nLeaveRequest.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        }\n    ]);\n/**\n * message to indicate published video track dimensions are changing\n *\n * @generated from message livekit.UpdateVideoLayers\n */ class UpdateVideoLayers extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.VideoLayer layers = 2;\n     */ this.layers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateVideoLayers().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateVideoLayers().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateVideoLayers().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateVideoLayers, a, b);\n    }\n}\nUpdateVideoLayers.runtime = proto3;\nUpdateVideoLayers.typeName = \"livekit.UpdateVideoLayers\";\nUpdateVideoLayers.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.UpdateParticipantMetadata\n */ class UpdateParticipantMetadata extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string metadata = 1;\n     */ this.metadata = \"\";\n        /**\n     * @generated from field: string name = 2;\n     */ this.name = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new UpdateParticipantMetadata().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new UpdateParticipantMetadata().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new UpdateParticipantMetadata().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(UpdateParticipantMetadata, a, b);\n    }\n}\nUpdateParticipantMetadata.runtime = proto3;\nUpdateParticipantMetadata.typeName = \"livekit.UpdateParticipantMetadata\";\nUpdateParticipantMetadata.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.ICEServer\n */ class ICEServer extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated string urls = 1;\n     */ this.urls = [];\n        /**\n     * @generated from field: string username = 2;\n     */ this.username = \"\";\n        /**\n     * @generated from field: string credential = 3;\n     */ this.credential = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ICEServer().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ICEServer().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ICEServer().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ICEServer, a, b);\n    }\n}\nICEServer.runtime = proto3;\nICEServer.typeName = \"livekit.ICEServer\";\nICEServer.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SpeakersChanged\n */ class SpeakersChanged extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.SpeakerInfo speakers = 1;\n     */ this.speakers = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SpeakersChanged().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SpeakersChanged().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SpeakersChanged().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SpeakersChanged, a, b);\n    }\n}\nSpeakersChanged.runtime = proto3;\nSpeakersChanged.typeName = \"livekit.SpeakersChanged\";\nSpeakersChanged.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RoomUpdate\n */ class RoomUpdate extends Message {\n    constructor(data){\n        super();\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RoomUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RoomUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RoomUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RoomUpdate, a, b);\n    }\n}\nRoomUpdate.runtime = proto3;\nRoomUpdate.typeName = \"livekit.RoomUpdate\";\nRoomUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityInfo\n */ class ConnectionQualityInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: livekit.ConnectionQuality quality = 2;\n     */ this.quality = ConnectionQuality$1.POOR;\n        /**\n     * @generated from field: float score = 3;\n     */ this.score = 0;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityInfo, a, b);\n    }\n}\nConnectionQualityInfo.runtime = proto3;\nConnectionQualityInfo.typeName = \"livekit.ConnectionQualityInfo\";\nConnectionQualityInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2 /* ScalarType.FLOAT */ \n        }\n    ]);\n/**\n * @generated from message livekit.ConnectionQualityUpdate\n */ class ConnectionQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.ConnectionQualityInfo updates = 1;\n     */ this.updates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new ConnectionQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new ConnectionQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new ConnectionQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(ConnectionQualityUpdate, a, b);\n    }\n}\nConnectionQualityUpdate.runtime = proto3;\nConnectionQualityUpdate.typeName = \"livekit.ConnectionQualityUpdate\";\nConnectionQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateInfo\n */ class StreamStateInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.StreamState state = 3;\n     */ this.state = StreamState.ACTIVE;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateInfo, a, b);\n    }\n}\nStreamStateInfo.runtime = proto3;\nStreamStateInfo.typeName = \"livekit.StreamStateInfo\";\nStreamStateInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\n/**\n * @generated from message livekit.StreamStateUpdate\n */ class StreamStateUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.StreamStateInfo stream_states = 1;\n     */ this.streamStates = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new StreamStateUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new StreamStateUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new StreamStateUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(StreamStateUpdate, a, b);\n    }\n}\nStreamStateUpdate.runtime = proto3;\nStreamStateUpdate.typeName = \"livekit.StreamStateUpdate\";\nStreamStateUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQuality\n */ class SubscribedQuality extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: livekit.VideoQuality quality = 1;\n     */ this.quality = VideoQuality.LOW;\n        /**\n     * @generated from field: bool enabled = 2;\n     */ this.enabled = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQuality().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQuality().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQuality().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQuality, a, b);\n    }\n}\nSubscribedQuality.runtime = proto3;\nSubscribedQuality.typeName = \"livekit.SubscribedQuality\";\nSubscribedQuality.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedCodec\n */ class SubscribedCodec extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string codec = 1;\n     */ this.codec = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality qualities = 2;\n     */ this.qualities = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedCodec().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedCodec().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedCodec().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedCodec, a, b);\n    }\n}\nSubscribedCodec.runtime = proto3;\nSubscribedCodec.typeName = \"livekit.SubscribedCodec\";\nSubscribedCodec.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscribedQualityUpdate\n */ class SubscribedQualityUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: repeated livekit.SubscribedQuality subscribed_qualities = 2;\n     */ this.subscribedQualities = [];\n        /**\n     * @generated from field: repeated livekit.SubscribedCodec subscribed_codecs = 3;\n     */ this.subscribedCodecs = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscribedQualityUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscribedQualityUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscribedQualityUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscribedQualityUpdate, a, b);\n    }\n}\nSubscribedQualityUpdate.runtime = proto3;\nSubscribedQualityUpdate.typeName = \"livekit.SubscribedQualityUpdate\";\nSubscribedQualityUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.TrackPermission\n */ class TrackPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * permission could be granted either by participant sid or identity\n     *\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: bool all_tracks = 2;\n     */ this.allTracks = false;\n        /**\n     * @generated from field: repeated string track_sids = 3;\n     */ this.trackSids = [];\n        /**\n     * @generated from field: string participant_identity = 4;\n     */ this.participantIdentity = \"\";\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new TrackPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new TrackPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new TrackPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(TrackPermission, a, b);\n    }\n}\nTrackPermission.runtime = proto3;\nTrackPermission.typeName = \"livekit.TrackPermission\";\nTrackPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ ,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermission\n */ class SubscriptionPermission extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: bool all_participants = 1;\n     */ this.allParticipants = false;\n        /**\n     * @generated from field: repeated livekit.TrackPermission track_permissions = 2;\n     */ this.trackPermissions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermission().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermission().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermission().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermission, a, b);\n    }\n}\nSubscriptionPermission.runtime = proto3;\nSubscriptionPermission.typeName = \"livekit.SubscriptionPermission\";\nSubscriptionPermission.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionPermissionUpdate\n */ class SubscriptionPermissionUpdate extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string participant_sid = 1;\n     */ this.participantSid = \"\";\n        /**\n     * @generated from field: string track_sid = 2;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: bool allowed = 3;\n     */ this.allowed = false;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionPermissionUpdate().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionPermissionUpdate().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionPermissionUpdate().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionPermissionUpdate, a, b);\n    }\n}\nSubscriptionPermissionUpdate.runtime = proto3;\nSubscriptionPermissionUpdate.typeName = \"livekit.SubscriptionPermissionUpdate\";\nSubscriptionPermissionUpdate.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ \n        }\n    ]);\n/**\n * @generated from message livekit.SyncState\n */ class SyncState extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.TrackPublishedResponse publish_tracks = 3;\n     */ this.publishTracks = [];\n        /**\n     * @generated from field: repeated livekit.DataChannelInfo data_channels = 4;\n     */ this.dataChannels = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SyncState().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SyncState().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SyncState().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SyncState, a, b);\n    }\n}\nSyncState.runtime = proto3;\nSyncState.typeName = \"livekit.SyncState\";\nSyncState.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        }\n    ]);\n/**\n * @generated from message livekit.DataChannelInfo\n */ class DataChannelInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string label = 1;\n     */ this.label = \"\";\n        /**\n     * @generated from field: uint32 id = 2;\n     */ this.id = 0;\n        /**\n     * @generated from field: livekit.SignalTarget target = 3;\n     */ this.target = SignalTarget.PUBLISHER;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new DataChannelInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new DataChannelInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new DataChannelInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(DataChannelInfo, a, b);\n    }\n}\nDataChannelInfo.runtime = proto3;\nDataChannelInfo.typeName = \"livekit.DataChannelInfo\";\nDataChannelInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13 /* ScalarType.UINT32 */ \n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\n/**\n * @generated from message livekit.SimulateScenario\n */ class SimulateScenario extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from oneof livekit.SimulateScenario.scenario\n     */ this.scenario = {\n            case: undefined\n        };\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SimulateScenario().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SimulateScenario().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SimulateScenario().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SimulateScenario, a, b);\n    }\n}\nSimulateScenario.runtime = proto3;\nSimulateScenario.typeName = \"livekit.SimulateScenario\";\nSimulateScenario.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8 /* ScalarType.BOOL */ ,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ ,\n            oneof: \"scenario\"\n        }\n    ]);\n/**\n * @generated from message livekit.Ping\n */ class Ping extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: int64 timestamp = 1;\n     */ this.timestamp = protoInt64.zero;\n        /**\n     * rtt in milliseconds calculated by client\n     *\n     * @generated from field: int64 rtt = 2;\n     */ this.rtt = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Ping().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Ping().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Ping().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Ping, a, b);\n    }\n}\nPing.runtime = proto3;\nPing.typeName = \"livekit.Ping\";\nPing.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.Pong\n */ class Pong extends Message {\n    constructor(data){\n        super();\n        /**\n     * timestamp field of last received ping request\n     *\n     * @generated from field: int64 last_ping_timestamp = 1;\n     */ this.lastPingTimestamp = protoInt64.zero;\n        /**\n     * @generated from field: int64 timestamp = 2;\n     */ this.timestamp = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new Pong().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Pong().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Pong().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Pong, a, b);\n    }\n}\nPong.runtime = proto3;\nPong.typeName = \"livekit.Pong\";\nPong.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.RegionSettings\n */ class RegionSettings extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: repeated livekit.RegionInfo regions = 1;\n     */ this.regions = [];\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionSettings().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionSettings().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionSettings().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionSettings, a, b);\n    }\n}\nRegionSettings.runtime = proto3;\nRegionSettings.typeName = \"livekit.RegionSettings\";\nRegionSettings.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\n/**\n * @generated from message livekit.RegionInfo\n */ class RegionInfo extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string region = 1;\n     */ this.region = \"\";\n        /**\n     * @generated from field: string url = 2;\n     */ this.url = \"\";\n        /**\n     * @generated from field: int64 distance = 3;\n     */ this.distance = protoInt64.zero;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new RegionInfo().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new RegionInfo().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new RegionInfo().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(RegionInfo, a, b);\n    }\n}\nRegionInfo.runtime = proto3;\nRegionInfo.typeName = \"livekit.RegionInfo\";\nRegionInfo.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        }\n    ]);\n/**\n * @generated from message livekit.SubscriptionResponse\n */ class SubscriptionResponse extends Message {\n    constructor(data){\n        super();\n        /**\n     * @generated from field: string track_sid = 1;\n     */ this.trackSid = \"\";\n        /**\n     * @generated from field: livekit.SubscriptionError err = 2;\n     */ this.err = SubscriptionError.SE_UNKNOWN;\n        proto3.util.initPartial(data, this);\n    }\n    static fromBinary(bytes, options) {\n        return new SubscriptionResponse().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new SubscriptionResponse().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new SubscriptionResponse().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(SubscriptionResponse, a, b);\n    }\n}\nSubscriptionResponse.runtime = proto3;\nSubscriptionResponse.typeName = \"livekit.SubscriptionResponse\";\nSubscriptionResponse.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9 /* ScalarType.STRING */ \n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nfunction cloneDeep(value) {\n    if (typeof value === \"undefined\") {\n        return;\n    }\n    if (typeof structuredClone === \"function\") {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === \"hidden\") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = \"audio\";\n        if (this.kind === Track.Kind.Video) {\n            elementType = \"video\";\n        }\n        if (this.attachedElements.length === 0 && Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === \"audio\") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === \"audio\");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === \"NotAllowedError\") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === \"AbortError\") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? \"audio\" : \"video\"), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === \"hidden\";\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === \"audio\") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a;\n    const opts = (_a = cloneDeep(options)) !== null && _a !== void 0 ? _a : {};\n    if (opts.audio === true) opts.audio = {};\n    if (opts.video === true) opts.video = {};\n    // use defaults\n    if (opts.audio) {\n        mergeObjectWithoutOverwriting(opts.audio, audioDefaults);\n    }\n    if (opts.video) {\n        mergeObjectWithoutOverwriting(opts.video, videoDefaults);\n    }\n    return opts;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === \"object\") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case \"resolution\":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n        } else {\n            constraints.video = options.video;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === \"object\") {\n            constraints.audio = options.audio;\n        } else {\n            constraints.audio = true;\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track) {\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n    return __awaiter(this, void 0, void 0, function*() {\n        const ctx = getNewAudioContext();\n        if (ctx) {\n            const analyser = ctx.createAnalyser();\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n            const dataArray = new Uint8Array(bufferLength);\n            const source = ctx.createMediaStreamSource(new MediaStream([\n                track.mediaStreamTrack\n            ]));\n            source.connect(analyser);\n            yield sleep(timeOffset);\n            analyser.getByteTimeDomainData(dataArray);\n            const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n            ctx.close();\n            return !someNoise;\n        }\n        return false;\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        return new AudioContext1({\n            latencyHint: \"interactive\"\n        });\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return \"audioinput\";\n    } else if (source === Track.Source.Camera) {\n        return \"videoinput\";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    if (options.resolution) {\n        videoConstraints = typeof videoConstraints === \"boolean\" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    const codec = mimeType.split(\"/\")[1].toLowerCase();\n    if (!videoCodecs.includes(codec)) {\n        throw Error(\"Video codec not supported: \".concat(codec));\n    }\n    return codec;\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nconst separator = \"|\";\nconst ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        \"\"\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/AV1\") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, \"16\") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/VP9\") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement(\"audio\");\n    }\n    return \"setSinkId\" in elm;\n}\nconst setCodecPreferencesVersions = {\n    Chrome: \"100\",\n    Safari: \"15\",\n    Firefox: \"100\"\n};\nfunction supportsSetCodecPreferences(transceiver) {\n    if (!isWeb()) {\n        return false;\n    }\n    if (!(\"setCodecPreferences\" in transceiver)) {\n        return false;\n    }\n    const browser = getBrowser();\n    if (!(browser === null || browser === void 0 ? void 0 : browser.name) || !browser.version) {\n        // version is required\n        return false;\n    }\n    const v = setCodecPreferencesVersions[browser.name];\n    if (v) {\n        return compareVersions(browser.version, v) >= 0;\n    }\n    return false;\n}\nfunction isBrowserSupported() {\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Firefox\";\n}\nfunction isChromiumBased() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Chrome\";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Safari\";\n}\nfunction isMobile() {\n    if (!isWeb()) return false;\n    return /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent);\n}\nfunction isWeb() {\n    return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(\".livekit.cloud\") || serverUrl.hostname.endsWith(\".livekit.run\");\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split(\".\");\n    const parts2 = v2.split(\".\");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === \"\" && v2 !== \"\") {\n        return -1;\n    } else if (v2 === \"\") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: \"0px\"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement(\"canvas\");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = \"grey\";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error(\"Could not get empty media stream video track\");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error(\"Could not get empty media stream audio track\");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error(\"Audio Context not supported on this browser\");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nclass Mutex {\n    constructor(){\n        this._locking = Promise.resolve();\n        this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let unlockNext;\n        const willLock = new Promise((resolve)=>unlockNext = ()=>{\n                this._locks -= 1;\n                resolve();\n            });\n        const willUnlock = this._locking.then(()=>unlockNext);\n        this._locking = this._locking.then(()=>willLock);\n        return willUnlock;\n    }\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === \"string\") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error(\"could not unwrap constraint\");\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith(\"http\")) {\n        return url.replace(/^(http)/, \"ws\");\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith(\"ws\")) {\n        return url.replace(/^(ws)/, \"http\");\n    }\n    return url;\n}\nconst defaultId = \"default\";\nclass DeviceManager {\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    getDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                livekitLogger.debug(\"awaiting getUserMedia promise\");\n                try {\n                    if (kind) {\n                        yield DeviceManager.userMediaPromiseMap.get(kind);\n                    } else {\n                        yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                    }\n                } catch (e) {\n                    livekitLogger.warn(\"error waiting for media permissons\");\n                }\n            }\n            let devices = yield navigator.mediaDevices.enumerateDevices();\n            if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n            !(isSafari() && this.hasDeviceInUse(kind))) {\n                const isDummyDeviceOrEmpty = devices.length === 0 || devices.some((device)=>{\n                    const noLabel = device.label === \"\";\n                    const isRelevant = kind ? device.kind === kind : true;\n                    return noLabel && isRelevant;\n                });\n                if (isDummyDeviceOrEmpty) {\n                    const permissionsToAcquire = {\n                        video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n                        audio: kind !== \"videoinput\"\n                    };\n                    const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                    devices = yield navigator.mediaDevices.enumerateDevices();\n                    stream.getTracks().forEach((track)=>{\n                        track.stop();\n                    });\n                }\n            }\n            if (kind) {\n                devices = devices.filter((device)=>device.kind === kind);\n            }\n            return devices;\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const device = devices.find((d)=>d.groupId === groupId && d.deviceId !== defaultId);\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    \"audioinput\",\n    \"audiooutput\",\n    \"videoinput\"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        super(mediaTrack, kind);\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>livekitLogger.debug(\"track mute bounce got cancelled by an unmute event\"));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel(\"unmute\");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new Mutex();\n        this.pauseUpstreamLock = new Mutex();\n        this.processorLock = new Mutex();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel(\"new-track\");\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                    this._mediaStreamTrack.stop();\n                }\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener(\"mute\", this.handleTrackMuteEvent);\n                newTrack.addEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack && this.processorElement) {\n                livekitLogger.debug(\"restarting processor\");\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                attachToElement(newTrack, this.processorElement);\n                yield this.processor.restart({\n                    track: newTrack,\n                    kind: this.kind,\n                    element: this.processorElement\n                });\n                processedTrack = this.processor.processedTrack;\n            }\n            if (this.sender) {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.kind === Track.Kind.Audio) {\n                throw new Error(\"cannot get dimensions for audio tracks\");\n            }\n            if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === \"iOS\") {\n                // browsers report wrong initial resolution on iOS.\n                // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                yield sleep(10);\n            }\n            const started = Date.now();\n            while(Date.now() - started < timeout){\n                const dims = this.dimensions;\n                if (dims) {\n                    return dims;\n                }\n                yield sleep(50);\n            }\n            throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // screen share doesn't have a usable device id\n            if (this.source === Track.Source.ScreenShare) {\n                return;\n            }\n            const { deviceId, groupId } = this._mediaStreamTrack.getSettings();\n            const kind = this.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n            return DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId);\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track) {\n        let userProvidedTrack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError(\"unable to replace an unpublished track\");\n            }\n            livekitLogger.debug(\"replace MediaStreamTrack\");\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            this.providedByUser = userProvidedTrack;\n            if (this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!constraints) {\n                constraints = this._constraints;\n            }\n            livekitLogger.debug(\"restarting track with constraints\", constraints);\n            const streamConstraints = {\n                audio: false,\n                video: false\n            };\n            if (this.kind === Track.Kind.Video) {\n                streamConstraints.video = constraints;\n            } else {\n                streamConstraints.audio = constraints;\n            }\n            // these steps are duplicated from setMediaStreamTrack because we must stop\n            // the previous tracks before new tracks can be acquired\n            this.attachedElements.forEach((el)=>{\n                detachTrack(this.mediaStreamTrack, el);\n            });\n            this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n            // on Safari, the old audio track must be stopped before attempting to acquire\n            // the new track, otherwise the new track will stop with\n            // 'A MediaStreamTrack ended due to a capture failure`\n            this._mediaStreamTrack.stop();\n            // create new track and attach\n            const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n            const newTrack = mediaStream.getTracks()[0];\n            newTrack.addEventListener(\"ended\", this.handleEnded);\n            livekitLogger.debug(\"re-acquired MediaStreamTrack\");\n            yield this.setMediaStreamTrack(newTrack);\n            this._constraints = constraints;\n            this.emit(TrackEvent.Restarted, this);\n            return this;\n        });\n    }\n    setTrackMuted(muted) {\n        livekitLogger.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"));\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            livekitLogger.debug(\"visibility changed, is in Background: \".concat(this.isInBackground));\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                livekitLogger.debug(\"track needs to be reacquired, restarting \".concat(this.source));\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    livekitLogger.warn(\"unable to pause upstream for an unpublished track\");\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"12.0\") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n                }\n                yield this.sender.replaceTrack(null);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    livekitLogger.warn(\"unable to resume upstream for an unpublished track\");\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                // this operation is noop if mediastreamtrack is already being sent\n                yield this.sender.replaceTrack(this._mediaStreamTrack);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                livekitLogger.debug(\"setting up processor\");\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                this.processorElement = (_a = this.processorElement) !== null && _a !== void 0 ? _a : document.createElement(this.kind);\n                this.processorElement.muted = true;\n                attachToElement(this._mediaStreamTrack, this.processorElement);\n                this.processorElement.play().catch((error)=>livekitLogger.error(\"failed to play processor element\", {\n                        error\n                    }));\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    element: this.processorElement\n                };\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    for (const el of this.attachedElements){\n                        if (el !== this.processorElement && showProcessedStreamLocally) {\n                            detachTrack(this._mediaStreamTrack, el);\n                            attachToElement(this.processor.processedTrack, el);\n                        }\n                    }\n                    yield (_b = this.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.processor) return;\n            livekitLogger.debug(\"stopping processor\");\n            (_a = this.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n            yield this.processor.destroy();\n            this.processor = undefined;\n            (_b = this.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n            this.processorElement = undefined;\n            yield this.restart();\n        });\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case \"error\":\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case \"initAck\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"enable\":\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    if (this.encryptionEnabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"ratchetKey\":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error(\"e2ee worker encountered an error:\", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n        }\n        livekitLogger.info(\"setting up e2ee\");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: \"init\",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.participants.forEach((participant)=>{\n                    participant.tracks.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: \"removeTransform\",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error(\"could not ratchet key, worker is missing\");\n        }\n        const msg = {\n            kind: \"ratchetRequest\",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error(\"could not set key, worker is missing\");\n        }\n        const msg = {\n            kind: \"setKey\",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: \"enable\",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError(\"could not post rtp map, worker is missing\");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError(\"could not post rtp map, local participant identity is missing\");\n        }\n        const msg = {\n            kind: \"setRTPMap\",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error(\"could not post SIF trailer, worker is missing\");\n        }\n        const msg = {\n            kind: \"setSifTrailer\",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === \"\") {\n            throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === \"video\" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!(track instanceof LocalTrack) || !sender) {\n            if (!sender) livekitLogger.warn(\"early return because sender is not ready\");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: \"decode\",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: \"updateCodec\",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: \"decode\",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === \"\") {\n            throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info(\"initialize script transform\");\n            const options = {\n                kind: \"encode\",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info(\"initialize encoded streams\");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: \"encode\",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new Mutex();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nconst passThroughQueueSignals = [\n    \"syncState\",\n    \"trickle\",\n    \"offer\",\n    \"answer\",\n    \"simulate\",\n    \"leave\"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace(\"request allowed to bypass queue:\", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new Mutex();\n        this.connectionLock = new Mutex();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                livekitLogger.warn(\"attempted to reconnect without signal options being set, ignoring\");\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        url = toWebsocketUrl(url);\n        // strip trailing slash\n        url = url.replace(/\\/$/, \"\");\n        url += \"/rtc\";\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled (signal)\"));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError(\"room connection has timed out (signal)\"));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n                    livekitLogger.debug(\"connecting to \".concat(url + params));\n                    if (this.ws) {\n                        yield this.close();\n                    }\n                    this.ws = new WebSocket(url + params);\n                    this.ws.binaryType = \"arraybuffer\";\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(\"http\".concat(url.substring(2), \"/validate\").concat(params));\n                                    if (resp.status.toFixed(0).startsWith(\"4\")) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, 0 /* ConnectionErrorReason.NotAllowed */ , resp.status));\n                                    } else {\n                                        reject(new ConnectionError(\"Internal error\", 2 /* ConnectionErrorReason.InternalError */ , resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError(\"server was not reachable\", 1 /* ConnectionErrorReason.ServerUnreachable */ ));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c, _d;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === \"string\") {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json);\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                livekitLogger.error(\"could not decode websocket message: \".concat(typeof ev.data));\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === \"join\") {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        livekitLogger.debug(\"ping config\", {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        });\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING) {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === \"reconnect\") {\n                                        resolve((_c = resp.message) === null || _c === void 0 ? void 0 : _c.value);\n                                    } else {\n                                        resolve();\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_d = resp.message) === null || _d === void 0 ? void 0 : _d.case, \" instead\")));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        livekitLogger.warn(\"websocket closed\", {\n                            ev\n                        });\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            try {\n                this.state = SignalConnectionState.DISCONNECTING;\n                if (this.ws) {\n                    this.ws.onmessage = null;\n                    this.ws.onopen = null;\n                    this.ws.onclose = null;\n                    // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                    const closePromise = new Promise((resolve)=>{\n                        if (this.ws) {\n                            this.ws.onclose = ()=>{\n                                resolve();\n                            };\n                        } else {\n                            resolve();\n                        }\n                    });\n                    if (this.ws.readyState < this.ws.CLOSING) {\n                        this.ws.close();\n                        // 250ms grace period for ws to close gracefully\n                        yield Promise.race([\n                            closePromise,\n                            sleep(250)\n                        ]);\n                    }\n                    this.ws = undefined;\n                }\n            } finally{\n                this.state = SignalConnectionState.DISCONNECTED;\n                this.clearPingInterval();\n                unlock();\n            }\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        livekitLogger.debug(\"sending offer\", offer);\n        this.sendRequest({\n            case: \"offer\",\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        livekitLogger.debug(\"sending answer\");\n        return this.sendRequest({\n            case: \"answer\",\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        livekitLogger.trace(\"sending ice candidate\", candidate);\n        return this.sendRequest({\n            case: \"trickle\",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: \"mute\",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: \"addTrack\",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata, name) {\n        return this.sendRequest({\n            case: \"updateMetadata\",\n            value: new UpdateParticipantMetadata({\n                metadata,\n                name\n            })\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: \"trackSetting\",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: \"subscription\",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: \"syncState\",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: \"updateLayers\",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: \"subscriptionPermission\",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: \"simulate\",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: \"ping\",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: \"pingReq\",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: \"leave\",\n            value: new LeaveRequest({\n                canReconnect: false,\n                reason: DisconnectReason.CLIENT_INITIATED\n            })\n        });\n    }\n    sendRequest(message) {\n        let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return __awaiter(this, void 0, void 0, function*() {\n            // capture all requests while reconnecting and put them in a queue\n            // unless the request originates from the queue, then don't enqueue again\n            const canQueue = !fromQueue && !canPassThroughQueue(message);\n            if (canQueue && this.state === SignalConnectionState.RECONNECTING) {\n                this.queuedRequests.push(()=>__awaiter(this, void 0, void 0, function*() {\n                        yield this.sendRequest(message, true);\n                    }));\n                return;\n            }\n            // make sure previously queued requests are being sent first\n            if (!fromQueue) {\n                yield this.requestQueue.flush();\n            }\n            if (this.signalLatency) {\n                yield sleep(this.signalLatency);\n            }\n            if (!this.ws || this.ws.readyState !== this.ws.OPEN) {\n                livekitLogger.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case));\n                return;\n            }\n            const req = new SignalRequest({\n                message\n            });\n            try {\n                if (this.useJSON) {\n                    this.ws.send(req.toJsonString());\n                } else {\n                    this.ws.send(req.toBinary());\n                }\n            } catch (e) {\n                livekitLogger.error(\"error sending signal message\", {\n                    error: e\n                });\n            }\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            livekitLogger.debug(\"received unsupported message\");\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === \"answer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === \"offer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === \"trickle\") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === \"update\") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === \"trackPublished\") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === \"speakersChanged\") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === \"leave\") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === \"mute\") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === \"roomUpdate\") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === \"connectionQuality\") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === \"streamStateUpdate\") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscribedQualityUpdate\") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscriptionPermissionUpdate\") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === \"refreshToken\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === \"trackUnpublished\") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === \"subscriptionResponse\") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === \"pong\") ;\n        else if (msg.case === \"pongResp\") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else {\n            livekitLogger.debug(\"unsupported message\", msg);\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            livekitLogger.debug(\"websocket connection closed: \".concat(reason));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        livekitLogger.error(\"websocket error\", ev);\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            livekitLogger.warn(\"ping timeout duration not set\");\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            livekitLogger.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()));\n            this.handleOnClose(\"ping timeout\");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            livekitLogger.warn(\"ping interval duration not set\");\n            return;\n        }\n        livekitLogger.debug(\"start ping interval\");\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        livekitLogger.debug(\"clearing ping interval\");\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: \"offer\",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case \"answer\":\n        case \"offer\":\n        case \"pranswer\":\n        case \"rollback\":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    // opts\n    if (opts.reconnect) {\n        params.set(\"reconnect\", \"1\");\n        if (opts.sid) {\n            params.set(\"sid\", opts.sid);\n        }\n    }\n    params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n    // ClientInfo\n    params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n    params.set(\"version\", info.version);\n    params.set(\"protocol\", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set(\"device_model\", info.deviceModel);\n    }\n    if (info.os) {\n        params.set(\"os\", info.os);\n    }\n    if (info.osVersion) {\n        params.set(\"os_version\", info.osVersion);\n    }\n    if (info.browser) {\n        params.set(\"browser\", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set(\"browser_version\", info.browserVersion);\n    }\n    if (opts.publishOnly !== undefined) {\n        params.set(\"publish\", opts.publishOnly);\n    }\n    if (opts.adaptiveStream) {\n        params.set(\"adaptive_stream\", \"1\");\n    }\n    if (opts.reconnectReason) {\n        params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set(\"network\", navigator.connection.type);\n    }\n    return \"?\".concat(params.toString());\n}\nvar parser$1 = {};\nvar grammar$2 = {\n    exports: {}\n};\nvar grammar$1 = grammar$2.exports = {\n    v: [\n        {\n            name: \"version\",\n            reg: /^(\\d*)$/\n        }\n    ],\n    o: [\n        {\n            // o=- 20518 0 IN IP4 203.0.113.1\n            // NB: sessionId will be a String in most cases because it is huge\n            name: \"origin\",\n            reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n            names: [\n                \"username\",\n                \"sessionId\",\n                \"sessionVersion\",\n                \"netType\",\n                \"ipVer\",\n                \"address\"\n            ],\n            format: \"%s %s %d %s IP%d %s\"\n        }\n    ],\n    // default parsing of these only (though some of these feel outdated)\n    s: [\n        {\n            name: \"name\"\n        }\n    ],\n    i: [\n        {\n            name: \"description\"\n        }\n    ],\n    u: [\n        {\n            name: \"uri\"\n        }\n    ],\n    e: [\n        {\n            name: \"email\"\n        }\n    ],\n    p: [\n        {\n            name: \"phone\"\n        }\n    ],\n    z: [\n        {\n            name: \"timezones\"\n        }\n    ],\n    // TODO: this one can actually be parsed properly...\n    r: [\n        {\n            name: \"repeats\"\n        }\n    ],\n    // TODO: this one can also be parsed properly\n    // k: [{}], // outdated thing ignored\n    t: [\n        {\n            // t=0 0\n            name: \"timing\",\n            reg: /^(\\d*) (\\d*)/,\n            names: [\n                \"start\",\n                \"stop\"\n            ],\n            format: \"%d %d\"\n        }\n    ],\n    c: [\n        {\n            // c=IN IP4 10.47.197.26\n            name: \"connection\",\n            reg: /^IN IP(\\d) (\\S*)/,\n            names: [\n                \"version\",\n                \"ip\"\n            ],\n            format: \"IN IP%d %s\"\n        }\n    ],\n    b: [\n        {\n            // b=AS:4000\n            push: \"bandwidth\",\n            reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n            names: [\n                \"type\",\n                \"limit\"\n            ],\n            format: \"%s:%s\"\n        }\n    ],\n    m: [\n        {\n            // m=video 51744 RTP/AVP 126 97 98 34 31\n            // NB: special - pushes to session\n            // TODO: rtp/fmtp should be filtered by the payloads found here?\n            reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n            names: [\n                \"type\",\n                \"port\",\n                \"protocol\",\n                \"payloads\"\n            ],\n            format: \"%s %d %s %s\"\n        }\n    ],\n    a: [\n        {\n            // a=rtpmap:110 opus/48000/2\n            push: \"rtp\",\n            reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n            names: [\n                \"payload\",\n                \"codec\",\n                \"rate\",\n                \"encoding\"\n            ],\n            format: function(o) {\n                return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n            }\n        },\n        {\n            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n            // a=fmtp:111 minptime=10; useinbandfec=1\n            push: \"fmtp\",\n            reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n            names: [\n                \"payload\",\n                \"config\"\n            ],\n            format: \"fmtp:%d %s\"\n        },\n        {\n            // a=control:streamid=0\n            name: \"control\",\n            reg: /^control:(.*)/,\n            format: \"control:%s\"\n        },\n        {\n            // a=rtcp:65179 IN IP4 193.84.77.194\n            name: \"rtcp\",\n            reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n            names: [\n                \"port\",\n                \"netType\",\n                \"ipVer\",\n                \"address\"\n            ],\n            format: function(o) {\n                return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n            }\n        },\n        {\n            // a=rtcp-fb:98 trr-int 100\n            push: \"rtcpFbTrrInt\",\n            reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n            names: [\n                \"payload\",\n                \"value\"\n            ],\n            format: \"rtcp-fb:%s trr-int %d\"\n        },\n        {\n            // a=rtcp-fb:98 nack rpsi\n            push: \"rtcpFb\",\n            reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n            names: [\n                \"payload\",\n                \"type\",\n                \"subtype\"\n            ],\n            format: function(o) {\n                return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n            }\n        },\n        {\n            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n            // a=extmap:1/recvonly URI-gps-string\n            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n            push: \"ext\",\n            reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n            names: [\n                \"value\",\n                \"direction\",\n                \"encrypt-uri\",\n                \"uri\",\n                \"config\"\n            ],\n            format: function(o) {\n                return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n            }\n        },\n        {\n            // a=extmap-allow-mixed\n            name: \"extmapAllowMixed\",\n            reg: /^(extmap-allow-mixed)/\n        },\n        {\n            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n            push: \"crypto\",\n            reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                \"id\",\n                \"suite\",\n                \"config\",\n                \"sessionConfig\"\n            ],\n            format: function(o) {\n                return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n            }\n        },\n        {\n            // a=setup:actpass\n            name: \"setup\",\n            reg: /^setup:(\\w*)/,\n            format: \"setup:%s\"\n        },\n        {\n            // a=connection:new\n            name: \"connectionType\",\n            reg: /^connection:(new|existing)/,\n            format: \"connection:%s\"\n        },\n        {\n            // a=mid:1\n            name: \"mid\",\n            reg: /^mid:([^\\s]*)/,\n            format: \"mid:%s\"\n        },\n        {\n            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n            name: \"msid\",\n            reg: /^msid:(.*)/,\n            format: \"msid:%s\"\n        },\n        {\n            // a=ptime:20\n            name: \"ptime\",\n            reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n            format: \"ptime:%d\"\n        },\n        {\n            // a=maxptime:60\n            name: \"maxptime\",\n            reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n            format: \"maxptime:%d\"\n        },\n        {\n            // a=sendrecv\n            name: \"direction\",\n            reg: /^(sendrecv|recvonly|sendonly|inactive)/\n        },\n        {\n            // a=ice-lite\n            name: \"icelite\",\n            reg: /^(ice-lite)/\n        },\n        {\n            // a=ice-ufrag:F7gI\n            name: \"iceUfrag\",\n            reg: /^ice-ufrag:(\\S*)/,\n            format: \"ice-ufrag:%s\"\n        },\n        {\n            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n            name: \"icePwd\",\n            reg: /^ice-pwd:(\\S*)/,\n            format: \"ice-pwd:%s\"\n        },\n        {\n            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n            name: \"fingerprint\",\n            reg: /^fingerprint:(\\S*) (\\S*)/,\n            names: [\n                \"type\",\n                \"hash\"\n            ],\n            format: \"fingerprint:%s %s\"\n        },\n        {\n            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n            push: \"candidates\",\n            reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n            names: [\n                \"foundation\",\n                \"component\",\n                \"transport\",\n                \"priority\",\n                \"ip\",\n                \"port\",\n                \"type\",\n                \"raddr\",\n                \"rport\",\n                \"tcptype\",\n                \"generation\",\n                \"network-id\",\n                \"network-cost\"\n            ],\n            format: function(o) {\n                var str = \"candidate:%s %d %s %d %s %d typ %s\";\n                str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n                // NB: candidate has three optional chunks, so %void middles one if it's missing\n                str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n                if (o.generation != null) {\n                    str += \" generation %d\";\n                }\n                str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n                str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n                return str;\n            }\n        },\n        {\n            // a=end-of-candidates (keep after the candidates line for readability)\n            name: \"endOfCandidates\",\n            reg: /^(end-of-candidates)/\n        },\n        {\n            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n            name: \"remoteCandidates\",\n            reg: /^remote-candidates:(.*)/,\n            format: \"remote-candidates:%s\"\n        },\n        {\n            // a=ice-options:google-ice\n            name: \"iceOptions\",\n            reg: /^ice-options:(\\S*)/,\n            format: \"ice-options:%s\"\n        },\n        {\n            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n            push: \"ssrcs\",\n            reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n            names: [\n                \"id\",\n                \"attribute\",\n                \"value\"\n            ],\n            format: function(o) {\n                var str = \"ssrc:%d\";\n                if (o.attribute != null) {\n                    str += \" %s\";\n                    if (o.value != null) {\n                        str += \":%s\";\n                    }\n                }\n                return str;\n            }\n        },\n        {\n            // a=ssrc-group:FEC 1 2\n            // a=ssrc-group:FEC-FR 3004364195 1080772241\n            push: \"ssrcGroups\",\n            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n            reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n            names: [\n                \"semantics\",\n                \"ssrcs\"\n            ],\n            format: \"ssrc-group:%s %s\"\n        },\n        {\n            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n            name: \"msidSemantic\",\n            reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n            names: [\n                \"semantic\",\n                \"token\"\n            ],\n            format: \"msid-semantic: %s %s\" // space after ':' is not accidental\n        },\n        {\n            // a=group:BUNDLE audio video\n            push: \"groups\",\n            reg: /^group:(\\w*) (.*)/,\n            names: [\n                \"type\",\n                \"mids\"\n            ],\n            format: \"group:%s %s\"\n        },\n        {\n            // a=rtcp-mux\n            name: \"rtcpMux\",\n            reg: /^(rtcp-mux)/\n        },\n        {\n            // a=rtcp-rsize\n            name: \"rtcpRsize\",\n            reg: /^(rtcp-rsize)/\n        },\n        {\n            // a=sctpmap:5000 webrtc-datachannel 1024\n            name: \"sctpmap\",\n            reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n            names: [\n                \"sctpmapNumber\",\n                \"app\",\n                \"maxMessageSize\"\n            ],\n            format: function(o) {\n                return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n            }\n        },\n        {\n            // a=x-google-flag:conference\n            name: \"xGoogleFlag\",\n            reg: /^x-google-flag:([^\\s]*)/,\n            format: \"x-google-flag:%s\"\n        },\n        {\n            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n            push: \"rids\",\n            reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n            names: [\n                \"id\",\n                \"direction\",\n                \"params\"\n            ],\n            format: function(o) {\n                return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n            }\n        },\n        {\n            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n            // a=imageattr:* send [x=800,y=640] recv *\n            // a=imageattr:100 recv [x=320,y=240]\n            push: \"imageattrs\",\n            reg: new RegExp(// a=imageattr:97\n            \"^imageattr:(\\\\d+|\\\\*)\" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n            \"[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)\" + // recv [x=330,y=250]\n            \"(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"),\n            names: [\n                \"pt\",\n                \"dir1\",\n                \"attrs1\",\n                \"dir2\",\n                \"attrs2\"\n            ],\n            format: function(o) {\n                return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n            }\n        },\n        {\n            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n            // a=simulcast:recv 1;4,5 send 6;7\n            name: \"simulcast\",\n            reg: new RegExp(// a=simulcast:\n            \"^simulcast:\" + // send 1,2,3;~4,~5\n            \"(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)\" + // space + recv 6;~7,~8\n            \"(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?\" + // end\n            \"$\"),\n            names: [\n                \"dir1\",\n                \"list1\",\n                \"dir2\",\n                \"list2\"\n            ],\n            format: function(o) {\n                return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n            }\n        },\n        {\n            // old simulcast draft 03 (implemented by Firefox)\n            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n            // a=simulcast: recv pt=97;98 send pt=97\n            // a=simulcast: send rid=5;6;7 paused=6,7\n            name: \"simulcast_03\",\n            reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n            names: [\n                \"value\"\n            ],\n            format: \"simulcast: %s\"\n        },\n        {\n            // a=framerate:25\n            // a=framerate:29.97\n            name: \"framerate\",\n            reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n            format: \"framerate:%s\"\n        },\n        {\n            // RFC4570\n            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n            name: \"sourceFilter\",\n            reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n            names: [\n                \"filterMode\",\n                \"netType\",\n                \"addressTypes\",\n                \"destAddress\",\n                \"srcList\"\n            ],\n            format: \"source-filter: %s %s %s %s %s\"\n        },\n        {\n            // a=bundle-only\n            name: \"bundleOnly\",\n            reg: /^(bundle-only)/\n        },\n        {\n            // a=label:1\n            name: \"label\",\n            reg: /^label:(.+)/,\n            format: \"label:%s\"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n            name: \"sctpPort\",\n            reg: /^sctp-port:(\\d+)$/,\n            format: \"sctp-port:%s\"\n        },\n        {\n            // RFC version 26 for SCTP over DTLS\n            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n            name: \"maxMessageSize\",\n            reg: /^max-message-size:(\\d+)$/,\n            format: \"max-message-size:%s\"\n        },\n        {\n            // RFC7273\n            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n            push: \"tsRefClocks\",\n            reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n            names: [\n                \"clksrc\",\n                \"clksrcExt\"\n            ],\n            format: function(o) {\n                return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n            }\n        },\n        {\n            // RFC7273\n            // a=mediaclk:direct=963214424\n            name: \"mediaClk\",\n            reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n            names: [\n                \"id\",\n                \"mediaClockName\",\n                \"mediaClockValue\",\n                \"rateNumerator\",\n                \"rateDenominator\"\n            ],\n            format: function(o) {\n                var str = \"mediaclk:\";\n                str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n                str += o.mediaClockValue != null ? \"=%s\" : \"\";\n                str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n                str += o.rateDenominator != null ? \"/%s\" : \"\";\n                return str;\n            }\n        },\n        {\n            // a=keywds:keywords\n            name: \"keywords\",\n            reg: /^keywds:(.+)$/,\n            format: \"keywds:%s\"\n        },\n        {\n            // a=content:main\n            name: \"content\",\n            reg: /^content:(.+)/,\n            format: \"content:%s\"\n        },\n        // BFCP https://tools.ietf.org/html/rfc4583\n        {\n            // a=floorctrl:c-s\n            name: \"bfcpFloorCtrl\",\n            reg: /^floorctrl:(c-only|s-only|c-s)/,\n            format: \"floorctrl:%s\"\n        },\n        {\n            // a=confid:1\n            name: \"bfcpConfId\",\n            reg: /^confid:(\\d+)/,\n            format: \"confid:%s\"\n        },\n        {\n            // a=userid:1\n            name: \"bfcpUserId\",\n            reg: /^userid:(\\d+)/,\n            format: \"userid:%s\"\n        },\n        {\n            // a=floorid:1\n            name: \"bfcpFloorId\",\n            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n            names: [\n                \"id\",\n                \"mStream\"\n            ],\n            format: \"floorid:%s mstrm:%s\"\n        },\n        {\n            // any a= that we don't understand is kept verbatim on media.invalid\n            push: \"invalid\",\n            names: [\n                \"value\"\n            ]\n        }\n    ]\n};\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar$1).forEach(function(key) {\n    var objs = grammar$1[key];\n    objs.forEach(function(obj) {\n        if (!obj.reg) {\n            obj.reg = /(.*)/;\n        }\n        if (!obj.format) {\n            obj.format = \"%s\";\n        }\n    });\n});\nvar grammarExports = grammar$2.exports;\n(function(exports) {\n    var toIntIfInt = function(v) {\n        return String(Number(v)) === v ? Number(v) : v;\n    };\n    var attachProperties = function(match, location, names, rawName) {\n        if (rawName && !names) {\n            location[rawName] = toIntIfInt(match[1]);\n        } else {\n            for(var i = 0; i < names.length; i += 1){\n                if (match[i + 1] != null) {\n                    location[names[i]] = toIntIfInt(match[i + 1]);\n                }\n            }\n        }\n    };\n    var parseReg = function(obj, location, content) {\n        var needsBlank = obj.name && obj.names;\n        if (obj.push && !location[obj.push]) {\n            location[obj.push] = [];\n        } else if (needsBlank && !location[obj.name]) {\n            location[obj.name] = {};\n        }\n        var keyLocation = obj.push ? {} : // blank object that will be pushed\n        needsBlank ? location[obj.name] : location; // otherwise, named location or root\n        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n        if (obj.push) {\n            location[obj.push].push(keyLocation);\n        }\n    };\n    var grammar = grammarExports;\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n    exports.parse = function(sdp) {\n        var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n        // parse lines we understand\n        sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n            var type = l[0];\n            var content = l.slice(2);\n            if (type === \"m\") {\n                media.push({\n                    rtp: [],\n                    fmtp: []\n                });\n                location = media[media.length - 1]; // point at latest media line\n            }\n            for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                var obj = grammar[type][j];\n                if (obj.reg.test(content)) {\n                    return parseReg(obj, location, content);\n                }\n            }\n        });\n        session.media = media; // link it up\n        return session;\n    };\n    var paramReducer = function(acc, expr) {\n        var s = expr.split(/=(.+)/, 2);\n        if (s.length === 2) {\n            acc[s[0]] = toIntIfInt(s[1]);\n        } else if (s.length === 1 && expr.length > 1) {\n            acc[s[0]] = undefined;\n        }\n        return acc;\n    };\n    exports.parseParams = function(str) {\n        return str.split(/;\\s?/).reduce(paramReducer, {});\n    };\n    // For backward compatibility - alias will be removed in 3.0.0\n    exports.parseFmtpConfig = exports.parseParams;\n    exports.parsePayloads = function(str) {\n        return str.toString().split(\" \").map(Number);\n    };\n    exports.parseRemoteCandidates = function(str) {\n        var candidates = [];\n        var parts = str.split(\" \").map(toIntIfInt);\n        for(var i = 0; i < parts.length; i += 3){\n            candidates.push({\n                component: parts[i],\n                ip: parts[i + 1],\n                port: parts[i + 2]\n            });\n        }\n        return candidates;\n    };\n    exports.parseImageAttributes = function(str) {\n        return str.split(\" \").map(function(item) {\n            return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n        });\n    };\n    exports.parseSimulcastStreamList = function(str) {\n        return str.split(\";\").map(function(stream) {\n            return stream.split(\",\").map(function(format) {\n                var scid, paused = false;\n                if (format[0] !== \"~\") {\n                    scid = toIntIfInt(format);\n                } else {\n                    scid = toIntIfInt(format.substring(1, format.length));\n                    paused = true;\n                }\n                return {\n                    scid: scid,\n                    paused: paused\n                };\n            });\n        });\n    };\n})(parser$1);\nvar grammar = grammarExports;\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function(formatStr) {\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    return formatStr.replace(formatRegExp, function(x) {\n        if (i >= len) {\n            return x; // missing argument\n        }\n        var arg = args[i];\n        i += 1;\n        switch(x){\n            case \"%%\":\n                return \"%\";\n            case \"%s\":\n                return String(arg);\n            case \"%d\":\n                return Number(arg);\n            case \"%v\":\n                return \"\";\n        }\n    });\n// NB: we discard excess arguments - they are typically undefined from makeLine\n};\nvar makeLine = function(type, obj, location) {\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n    var args = [\n        type + \"=\" + str\n    ];\n    if (obj.names) {\n        for(var i = 0; i < obj.names.length; i += 1){\n            var n = obj.names[i];\n            if (obj.name) {\n                args.push(location[obj.name][n]);\n            } else {\n                // for mLine and push attributes\n                args.push(location[obj.names[i]]);\n            }\n        }\n    } else {\n        args.push(location[obj.name]);\n    }\n    return format.apply(null, args);\n};\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n    \"v\",\n    \"o\",\n    \"s\",\n    \"i\",\n    \"u\",\n    \"e\",\n    \"p\",\n    \"c\",\n    \"b\",\n    \"t\",\n    \"r\",\n    \"z\",\n    \"a\"\n];\nvar defaultInnerOrder = [\n    \"i\",\n    \"c\",\n    \"b\",\n    \"a\"\n];\nvar writer$1 = function(session, opts) {\n    opts = opts || {};\n    // ensure certain properties exist\n    if (session.version == null) {\n        session.version = 0; // 'v=0' must be there (only defined version atm)\n    }\n    if (session.name == null) {\n        session.name = \" \"; // 's= ' must be there if no meaningful name set\n    }\n    session.media.forEach(function(mLine) {\n        if (mLine.payloads == null) {\n            mLine.payloads = \"\";\n        }\n    });\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\n    var sdp = [];\n    // loop through outerOrder for matching properties on session\n    outerOrder.forEach(function(type) {\n        grammar[type].forEach(function(obj) {\n            if (obj.name in session && session[obj.name] != null) {\n                sdp.push(makeLine(type, obj, session));\n            } else if (obj.push in session && session[obj.push] != null) {\n                session[obj.push].forEach(function(el) {\n                    sdp.push(makeLine(type, obj, el));\n                });\n            }\n        });\n    });\n    // then for each media line, follow the innerOrder\n    session.media.forEach(function(mLine) {\n        sdp.push(makeLine(\"m\", grammar.m[0], mLine));\n        innerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in mLine && mLine[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, mLine));\n                } else if (obj.push in mLine && mLine[obj.push] != null) {\n                    mLine[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n    });\n    return sdp.join(\"\\r\\n\") + \"\\r\\n\";\n};\nvar parser = parser$1;\nvar writer = writer$1;\nvar write = writer;\nvar parse = parser.parse;\nparser.parseParams;\nparser.parseFmtpConfig; // Alias of parseParams().\nparser.parsePayloads;\nparser.parseRemoteCandidates;\nparser.parseImageAttributes;\nparser.parseSimulcastStreamList;\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst PCEvents = {\n    NegotiationStarted: \"negotiationStarted\",\n    NegotiationComplete: \"negotiationComplete\",\n    RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let mediaConstraints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), 100);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.config = config;\n        this.mediaConstraints = mediaConstraints;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = isChromiumBased() ? // @ts-expect-error chrome allows additional media constraints to be passed into the RTCPeerConnection constructor\n        new RTCPeerConnection(this.config, this.mediaConstraints) : new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            let mungedSDP = undefined;\n            if (sd.type === \"offer\") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === \"answer\") {\n                const sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === \"audio\") {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(\";\").filter((attr)=>!attr.includes(\"maxaveragebitrate\")).join(\";\");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === \"answer\") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === \"video\") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                livekitLogger.debug(\"restarting ICE\");\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === \"have-local-offer\") {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === \"closed\") {\n                livekitLogger.warn(\"could not createOffer with closed peer connection\");\n                return;\n            }\n            // actually negotiate\n            livekitLogger.debug(\"starting to negotiate\");\n            const offer = yield this.pc.createOffer(options);\n            const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === \"video\") {\n                    ensureVideoDDExtensionForSVC(media);\n                    // mung sdp for codec bitrate setting that can't apply by sendEncoding\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        let fmtpFound = false;\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC));\n                                }\n                                if (!fmtp.config.includes(\"x-google-max-bitrate\")) {\n                                    fmtp.config += \";x-google-max-bitrate=\".concat(trackbr.maxbr);\n                                }\n                                fmtpFound = true;\n                                break;\n                            }\n                        }\n                        if (!fmtpFound) {\n                            media.fmtp.push({\n                                payload: codecPayload,\n                                config: \"x-google-start-bitrate=\".concat(Math.round(trackbr.maxbr * startBitrateForSVC), \";x-google-max-bitrate=\").concat(trackbr.maxbr)\n                            });\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = \"\";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case \"transport\":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case \"candidate-pair\":\n                        if (selectedCandidatePairId === \"\" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case \"remote-candidate\":\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === \"\") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    livekitLogger.debug(\"setting munged \".concat(remote ? \"remote\" : \"local\", \" description\"));\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    livekitLogger.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), {\n                        error: e,\n                        sdp: munged\n                    });\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                // this error cannot always be caught.\n                // If the local description has a setCodecPreferences error, this error will be uncaught\n                let msg = \"unknown error\";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === \"string\") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                livekitLogger.error(\"unable to set \".concat(sd.type), fields);\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === \"opus\") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: \"nack\"\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes(\"stereo=1\")) {\n                        fmtp.config += \";stereo=1\";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction ensureVideoDDExtensionForSVC(media) {\n    var _a, _b, _c, _d;\n    const codec = (_b = (_a = media.rtp[0]) === null || _a === void 0 ? void 0 : _a.codec) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n    if (!isSVCCodec(codec)) {\n        return;\n    }\n    let maxID = 0;\n    const ddFound = (_c = media.ext) === null || _c === void 0 ? void 0 : _c.some((ext)=>{\n        if (ext.uri === ddExtensionURI) {\n            return true;\n        }\n        if (ext.value > maxID) {\n            maxID = ext.value;\n        }\n        return false;\n    });\n    if (!ddFound) {\n        (_d = media.ext) === null || _d === void 0 ? void 0 : _d.push({\n            value: maxID + 1,\n            uri: ddExtensionURI\n        });\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === \"audio\") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === \"opus\") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes(\"sprop-stereo=1\")) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nconst defaultVideoCodec = \"vp8\";\nconst publishDefaults = {\n    /**\n   * @deprecated\n   */ audioBitrate: AudioPresets.music.maxBitrate,\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true\n};\nconst videoDefaults = {\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    expWebAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary){\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === \"connected\")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === \"failed\")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === \"connecting\")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === \"new\")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                livekitLogger.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]));\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        const googConstraints = {\n            optional: [\n                {\n                    googDscp: true\n                }\n            ]\n        };\n        this.publisher = new PCTransport(rtcConfig, googConstraints);\n        this.subscriber = new PCTransport(rtcConfig);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new Mutex();\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        livekitLogger.warn(\"could not removeTrack\", {\n                            error: e\n                        });\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            livekitLogger.debug(\"received server offer\", {\n                RTCSdpType: sd.type,\n                signalingState: this.subscriber.getSignallingState().toString()\n            });\n            yield this.subscriber.setRemoteDescription(sd);\n            // answer the offer\n            const answer = yield this.subscriber.createAndSetAnswer();\n            return answer;\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\") {\n                    livekitLogger.debug(\"negotiation required, start negotiating\");\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject(\"negotiation timed out\");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(\"negotiation aborted\");\n                    };\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport, abortController) {\n        let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n        return __awaiter(this, void 0, void 0, function*() {\n            const connectionState = pcTransport.getConnectionState();\n            if (connectionState === \"connected\") {\n                return;\n            }\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const abortHandler = ()=>{\n                        livekitLogger.warn(\"abort transport connection\");\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        reject(new ConnectionError(\"room connection has been cancelled\", 3 /* ConnectionErrorReason.Cancelled */ ));\n                    };\n                    if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                        abortHandler();\n                    }\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n                    const connectTimeout = CriticalTimers.setTimeout(()=>{\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        reject(new ConnectionError(\"could not establish pc connection\"));\n                    }, timeout);\n                    while(this.state !== PCTransportState.CONNECTED){\n                        yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            reject(new ConnectionError(\"room connection has been cancelled\", 3 /* ConnectionErrorReason.Cancelled */ ));\n                            return;\n                        }\n                    }\n                    CriticalTimers.clearTimeout(connectTimeout);\n                    abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                    resolve();\n                }));\n        });\n    }\n}\nconst lossyDataChannel = \"_lossy\";\nconst reliableDataChannel = \"_reliable\";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    constructor(options){\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.handleDataChannel = (_ref)=>{\n            let { channel } = _ref;\n            return __awaiter(this, void 0, void 0, function*() {\n                if (!channel) {\n                    return;\n                }\n                if (channel.label === reliableDataChannel) {\n                    this.reliableDCSub = channel;\n                } else if (channel.label === lossyDataChannel) {\n                    this.lossyDCSub = channel;\n                } else {\n                    return;\n                }\n                livekitLogger.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label));\n                channel.onmessage = this.handleDataMessage;\n            });\n        };\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        livekitLogger.error(\"unsupported data type\", message.data);\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === \"speaker\") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === \"user\") {\n                        this.emit(EngineEvent.DataPacketReceived, dp.value.value, dp.kind);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                livekitLogger.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), error);\n            } else {\n                livekitLogger.error(\"Unknown DataChannel error on \".concat(channelKind), event);\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            livekitLogger.warn(\"\".concat(connection, \" disconnected\"));\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                livekitLogger.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"));\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            livekitLogger.debug(\"reconnecting in \".concat(delay, \"ms\"));\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.client = new SignalClient();\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new Mutex();\n        this.dataProcessLock = new Mutex();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === 1 /* ConnectionErrorReason.ServerUnreachable */ ) {\n                        livekitLogger.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts));\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError(\"a track with the same ID has already been published\");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError(\"publication of local track timed out, no response from server\"));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error(\"Cancelled publication by calling unpublish\"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            livekitLogger.warn(\"failed to remove track\", {\n                error: e,\n                method: \"removeTrack\"\n            });\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    livekitLogger.debug(\"primary PC state changed \".concat(connectionState));\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect(\"peerconnection failed\", subscriberState === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            this.createDataChannels();\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                livekitLogger.debug(\"received server answer\", {\n                    RTCSdpType: sd.type\n                });\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            livekitLogger.trace(\"got ICE candidate from peer\", {\n                candidate,\n                target\n            });\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            livekitLogger.debug(\"received trackPublishedResponse\", res);\n            if (!this.pendingTrackResolvers[res.cid]) {\n                livekitLogger.error(\"missing track resolver for \".concat(res.cid));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            if (leave === null || leave === void 0 ? void 0 : leave.canReconnect) {\n                this.fullReconnectOnNext = true;\n                // reconnect immediately instead of waiting for next attempt\n                this.handleDisconnect(leaveReconnect);\n            } else {\n                this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                this.close();\n            }\n            livekitLogger.trace(\"leave request\", {\n                leave\n            });\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            livekitLogger.debug(\"E2EE - setting up transports with insertable streams\");\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = \"relay\";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = \"unified-plan\";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = \"gather_continually\";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    setPreferredCodec(transceiver, kind, videoCodec) {\n        if (!(\"getCapabilities\" in RTCRtpSender)) {\n            return;\n        }\n        const cap = RTCRtpSender.getCapabilities(kind);\n        if (!cap) return;\n        livekitLogger.debug(\"get capabilities\", cap);\n        const matched = [];\n        const partialMatched = [];\n        const unmatched = [];\n        cap.codecs.forEach((c)=>{\n            const codec = c.mimeType.toLowerCase();\n            if (codec === \"audio/opus\") {\n                matched.push(c);\n                return;\n            }\n            const matchesVideoCodec = codec === \"video/\".concat(videoCodec);\n            if (!matchesVideoCodec) {\n                unmatched.push(c);\n                return;\n            }\n            // for h264 codecs that have sdpFmtpLine available, use only if the\n            // profile-level-id is 42e01f for cross-browser compatibility\n            if (videoCodec === \"h264\") {\n                if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                    matched.push(c);\n                } else {\n                    partialMatched.push(c);\n                }\n                return;\n            }\n            matched.push(c);\n        });\n        if (supportsSetCodecPreferences(transceiver)) {\n            transceiver.setCodecPreferences(matched.concat(partialMatched, unmatched));\n        }\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                livekitLogger.warn(\"using add-track fallback\");\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                livekitLogger.debug(\"using add-track fallback\");\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            const transceiverInit = {\n                direction: \"sendonly\",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            if (track.kind === Track.Kind.Video && opts.videoCodec) {\n                this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n                track.codec = opts.videoCodec;\n            }\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const transceiverInit = {\n                direction: \"sendonly\"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            this.setPreferredCodec(transceiver, track.kind, opts.videoCodec);\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    livekitLogger.debug(\"received unrecoverable error\", {\n                        error: e\n                    });\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    livekitLogger.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"));\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            livekitLogger.warn(\"encountered error in reconnect policy\", {\n                error: e\n            });\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n                }\n                livekitLogger.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts));\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        livekitLogger.warn(\"attempted connection restart, without signal options present\");\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                        throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error(\"simulated failure\");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n            }\n            livekitLogger.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts));\n            this.emit(EngineEvent.Resuming);\n            try {\n                this.setupSignalClientCallbacks();\n                const res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n                if (res) {\n                    const rtcConfig = this.makeRTCConfiguration(res);\n                    this.pcManager.updateConfiguration(rtcConfig);\n                }\n            } catch (e) {\n                let message = \"\";\n                if (e instanceof Error) {\n                    message = e.message;\n                    livekitLogger.error(e.message);\n                }\n                if (e instanceof ConnectionError && e.reason === 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                    throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error(\"simulated failure\");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            livekitLogger.debug(\"waiting for peer connection to reconnect\");\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message));\n            }\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind) {\n        let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            const transport = subscriber ? this.pcManager.subscriber : this.pcManager.publisher;\n            const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n            if (!transport) {\n                throw new ConnectionError(\"\".concat(transportName, \" connection not set\"));\n            }\n            if (!subscriber && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== \"checking\") {\n                // start negotiation\n                this.negotiate();\n            }\n            const targetChannel = this.dataChannelForKind(kind, subscriber);\n            if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n                return;\n            }\n            // wait until ICE connected\n            const endTime = new Date().getTime() + this.peerConnectionTimeout;\n            while(new Date().getTime() < endTime){\n                if (transport.isICEConnected && ((_a = this.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\") {\n                    return;\n                }\n                yield sleep(50);\n            }\n            throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()));\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.ensureDataTransportConnected(kind, false);\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError(\"PC manager is closed\"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        livekitLogger.debug(\"engine disconnected while negotiation was ongoing\");\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject(\"cannot negotiate on closed engine\");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            livekitLogger.warn(\"sync state cannot be sent without peer connection setup\");\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo()\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 /* ConnectionErrorReason.NotAllowed */  : undefined, regionSettingsResponse.status);\n            }\n        });\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if (\"bytesReceived\" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if (\"bytesSent\" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack);\n        /** @internal */ this.stopOnMute = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    livekitLogger.error(\"could not get audio sender stats\", {\n                        error: e\n                    });\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this.mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    livekitLogger.debug(\"stopping mic track\");\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || deviceHasChanged) && !this.isUserProvided) {\n                    livekitLogger.debug(\"reacquiring mic track\");\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== \"boolean\") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!this.audioContext) {\n                    throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                if (this.kind === \"unknown\") {\n                    throw TypeError(\"cannot set processor on track of unknown kind\");\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    audioContext: this.audioContext\n                };\n                livekitLogger.debug(\"setting up audio processor \".concat(processor.name));\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === \"outbound-rtp\") {\n                    audioStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    livekitLogger.warn(\"silence detected on local audio track\");\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints) {\n    switch(mediaStreamTrack.kind){\n        case \"audio\":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false);\n        case \"video\":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: 3\n        }\n    ];\n    return layers.map((t)=>{\n        var _a;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / t.fps)))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    \"q\",\n    \"h\",\n    \"f\"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug(\"using video encoding\", videoEncoding);\n    }\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        livekitLogger.debug(\"using svc with scalabilityMode \".concat(scalabilityMode));\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        for(let i = 0; i < sm.spatial; i += 1){\n            encodings.push({\n                rid: videoRids[2 - i],\n                maxBitrate: videoEncoding.maxBitrate / Math.pow(3, i),\n                /* @ts-ignore */ maxFramerate: original.encoding.maxFramerate\n            });\n        }\n        /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        livekitLogger.debug(\"encodings\", encodings);\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. ion-sfu translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ]);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ]);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn(\"requested a different codec than specified as backup\", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case \"av1\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case \"vp9\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        if (preset.encoding.maxFramerate) {\n            encoding.maxFramerate = preset.encoding.maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === \"ios\") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info('Setting framerate of encoding \"'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\", '\" to ').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error(\"invalid scalability mode\");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case \"h\":\n                case \"_KEY\":\n                case \"_KEY_SHIFT\":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : \"\");\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    livekitLogger.error(\"could not get audio sender stats\", {\n                        error: e\n                    });\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new Mutex();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        var _a, e_1, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        var _a, e_2, _b, _c;\n        var _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    livekitLogger.debug(\"stopping camera track\");\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    livekitLogger.debug(\"reacquiring camera track\");\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === \"outbound-rtp\") {\n                    const vs = {\n                        type: \"video\",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        framesSent: v.framesSent,\n                        timestamp: v.timestamp,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        livekitLogger.debug(\"setting publishing quality. max quality \".concat(maxQuality));\n        this.setPublishingLayers(qualities);\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when video is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (!this.isMuted) {\n                yield this.restartTrack();\n            }\n            return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    restartTrack(options) {\n        var _a, e_3, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== \"boolean\") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const sc = _c;\n                    if (sc.sender) {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor) {\n        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        var _a, e_4, _b, _c;\n        var _d, _e;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.setProcessor.call(this, processor, showProcessedStreamLocally);\n            if ((_d = this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                try {\n                    for(var _f = true, _g = __asyncValues(this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                        _c = _h.value;\n                        _f = false;\n                        const sc = _c;\n                        yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(this.processor.processedTrack);\n                    }\n                } catch (e_4_1) {\n                    e_4 = {\n                        error: e_4_1\n                    };\n                } finally{\n                    try {\n                        if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                    } finally{\n                        if (e_4) throw e_4.error;\n                    }\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            throw new Error(\"\".concat(codec, \" already added\"));\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        var _a, codecs_1, codecs_1_1;\n        var _b, e_5, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            livekitLogger.debug(\"setting publishing codecs\", {\n                codecs,\n                currentCodec: this.codec\n            });\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        livekitLogger.debug(\"try setPublishingCodec for \".concat(codec.codec), simulcastCodecInfo);\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            livekitLogger.debug(\"try setPublishingLayersForSender \".concat(codec.codec));\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            livekitLogger.debug(\"setting publishing layers\", qualities);\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        livekitLogger.debug(\"setPublishingLayersForSender\", {\n            sender,\n            qualities,\n            senderEncodings\n        });\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                livekitLogger.warn(\"cannot set publishing layers, encodings mismatch\");\n                return;\n            }\n            let hasChanged = false;\n            /* disable closable spatial layer as it has video blur / frozen issue with current server / client\n      1. chrome 113: when switching to up layer with scalability Mode change, it will generate a\n            low resolution frame and recover very quickly, but noticable\n      2. livekit sfu: additional pli request cause video frozen for a few frames, also noticable */ const closableSpatial = false;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) ;\n            else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n                    if (rid === \"\") {\n                        rid = \"q\";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        livekitLogger.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"));\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                livekitLogger.debug(\"setting encodings\", params.encodings);\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case \"f\":\n            return VideoQuality.HIGH;\n        case \"h\":\n            return VideoQuality.MEDIUM;\n        case \"q\":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: VideoQuality.HIGH - i,\n                width: Math.ceil(width / Math.pow(2, i)),\n                height: Math.ceil(height / Math.pow(2, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(3, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver){\n        super(mediaTrack, kind);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener(\"removetrack\", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            livekitLogger.debug(\"using audio context mapping\");\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== \"running\") {\n            context.resume().then(()=>{\n                if (context.state !== \"running\") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    receiverStats = {\n                        type: \"audio\",\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings){\n        super(mediaTrack, sid, Track.Kind.Video, receiver);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            livekitLogger.warn(\"visibility resize observer not triggered\");\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            livekitLogger.warn(\"stopObservingElementInfo ignored\");\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = \"\";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: \"video\",\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === \"codec\") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== \"\" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === \"screen\") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a;\n            this.isPiP = true;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = false;\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && document.pictureInPictureElement === element;\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = document.pictureInPictureElement === this.element;\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n    }\n}\n// does not account for occlusion by other elements\nfunction isElementInViewport(el) {\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { opacity, display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset && !hidden && (opacity !== \"\" ? parseFloat(opacity) > 0 : true) && display !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name){\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        livekitLogger.debug(\"update publication info\", {\n            info\n        });\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track){\n        super(kind, ti.sid, ti.name);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get isEncrypted() {\n        return this.tracks.size > 0 && Array.from(this.tracks.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a, _b;\n        return (_b = (_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) !== null && _b !== void 0 ? _b : false;\n    }\n    /** @internal */ constructor(sid, identity, name, metadata){\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n    }\n    getTracks() {\n        return Array.from(this.tracks.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   * @param source\n   * @returns\n   */ getTrack(source) {\n        for (const [, pub] of this.tracks){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   * @param name\n   * @returns\n   */ getTrackByName(name) {\n        for (const [, pub] of this.tracks){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrack(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrack(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        livekitLogger.trace(\"update participant info\", {\n            info\n        });\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        });\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTracks.forEach((track)=>(track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.tracks.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe){\n        super(kind, ti.sid, ti.name);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            livekitLogger.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), {\n                trackSid: this.trackSid\n            });\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            livekitLogger.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), {\n                trackSid: this.trackSid\n            });\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: \"\",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (this.track instanceof RemoteVideoTrack) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!(this.track instanceof RemoteVideoTrack)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            livekitLogger.warn(\"adaptive stream is enabled, cannot change video track settings\", {\n                trackSid: this.trackSid\n            });\n            return false;\n        }\n        if (!this.isDesired) {\n            livekitLogger.warn(\"cannot update track settings when not subscribed\", {\n                trackSid: this.trackSid\n            });\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata);\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata){\n        super(sid, identity || \"\", name, metadata);\n        this.signalClient = signalClient;\n        this.tracks = new Map();\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            livekitLogger.debug(\"send update settings\", settings);\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrack(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublication(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith(\"TR\")) {\n                // find the first track that matches type\n                this.tracks.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                livekitLogger.error(\"could not find published track\", {\n                    participant: this.sid,\n                    trackSid: sid\n                });\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            livekitLogger.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", {\n                participant: this.sid,\n                trackSid: sid\n            });\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === \"video\";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    getTrackPublication(sid) {\n        return this.tracks.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a;\n            let publication = this.getTrackPublication(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe);\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    livekitLogger.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), {\n                        oldTrack: existingTrackOfSource,\n                        newTrack: publication,\n                        participant: this,\n                        participantInfo: info\n                    });\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.tracks.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                livekitLogger.trace(\"detected removed track on remote participant, unpublishing\", {\n                    publication,\n                    participantSid: this.sid\n                });\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.tracks.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.tracks.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTracks.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTracks.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTracks.forEach((pub)=>{\n                var _a;\n                if (pub.track instanceof RemoteAudioTrack) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        livekitLogger.trace(\"participant event\", {\n            participant: this.sid,\n            event,\n            args\n        });\n        return super.emit(event, ...args);\n    }\n}\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options){\n        super(sid, identity);\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>livekitLogger.warn(e));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during reconnection attempt\");\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            livekitLogger.debug(\"updating track subscription permissions\", {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            });\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                livekitLogger.error(\"could not update mute status for unpublished track\", track);\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            livekitLogger.debug(\"upstream paused\");\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            livekitLogger.debug(\"upstream resumed\");\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTracks.get(update.trackSid);\n                if (!pub) {\n                    livekitLogger.warn(\"received subscribed quality update for unknown track\", {\n                        method: \"handleSubscribedQualityUpdate\",\n                        sid: update.trackSid\n                    });\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                livekitLogger.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.tracks.get(unpublished.trackSid);\n            if (!track) {\n                livekitLogger.warn(\"received unpublished event for unknown track\", {\n                    method: \"handleLocalTrackUnpublished\",\n                    trackSid: unpublished.trackSid\n                });\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    livekitLogger.debug(\"unpublishing local track due to TrackEnded\", {\n                        track: track.sid\n                    });\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n                                });\n                                if (currentPermissions && currentPermissions.state === \"denied\") {\n                                    livekitLogger.warn(\"user has revoked access to \".concat(track.source));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== \"denied\") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error(\"GetUserMedia Permission denied\");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            livekitLogger.debug(\"track ended, attempting to use a different device\");\n                            yield track.restartTrack();\n                        }\n                    } catch (e) {\n                        livekitLogger.warn(\"could not restart track, muting instead\");\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTracks = new Map();\n        this.videoTracks = new Map();\n        this.tracks = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map();\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrack(source) {\n        const track = super.getTrack(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackByName(name) {\n        const track = super.getTrackByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.tracks.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setMetadata(metadata) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata(metadata, (_a = this.name) !== null && _a !== void 0 ? _a : \"\");\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * The change does not take immediate effect.\n   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param metadata\n   */ setName(name) {\n        var _a;\n        this.engine.client.sendUpdateLocalMetadata((_a = this.metadata) !== null && _a !== void 0 ? _a : \"\", name);\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            livekitLogger.debug(\"setTrackEnabled\", {\n                source,\n                enabled\n            });\n            let track = this.getTrack(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        livekitLogger.info(\"skipping duplicate published source\", {\n                            source\n                        });\n                        // no-op it's already been requested\n                        return;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            livekitLogger.info(\"publishing track\", {\n                                localTrack\n                            });\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error && !(e instanceof TrackInvalidError)) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else if (track && track.track) {\n                // screenshare cannot be muted, unpublish instead\n                if (source === Track.Source.ScreenShare) {\n                    track = yield this.unpublishTrack(track.track);\n                    const screenAudioTrack = this.getTrack(Track.Source.ScreenShareAudio);\n                    if (screenAudioTrack && screenAudioTrack.track) {\n                        this.unpublishTrack(screenAudioTrack.track);\n                    }\n                } else {\n                    yield track.mute();\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const opts = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            const constraints = constraintsForOptions(opts);\n            let stream;\n            try {\n                stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (constraints.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (constraints.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n            if (constraints.audio) {\n                this.microphoneError = undefined;\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n            }\n            if (constraints.video) {\n                this.cameraError = undefined;\n            }\n            return stream.getTracks().map((mediaStreamTrack)=>{\n                const isAudio = mediaStreamTrack.kind === \"audio\";\n                isAudio ? options.audio : options.video;\n                let trackConstraints;\n                const conOrBool = isAudio ? constraints.audio : constraints.video;\n                if (typeof conOrBool !== \"boolean\") {\n                    trackConstraints = conOrBool;\n                }\n                const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n                if (track.kind === Track.Kind.Video) {\n                    track.source = Track.Source.Camera;\n                } else if (track.kind === Track.Kind.Audio) {\n                    track.source = Track.Source.Microphone;\n                }\n                track.mediaStream = stream;\n                return track;\n            });\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError(\"no video track found\");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n            screenVideo.source = Track.Source.ScreenShare;\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext);\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function*() {\n            yield (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n            if (track instanceof LocalTrack && this.pendingPublishPromises.has(track)) {\n                yield this.pendingPublishPromises.get(track);\n            }\n            let defaultConstraints;\n            if (track instanceof MediaStreamTrack) {\n                defaultConstraints = track.getConstraints();\n            } else {\n                // we want to access constraints directly as `track.mediaStreamTrack`\n                // might be pointing to a non-device track (e.g. processed track) already\n                defaultConstraints = track.constraints;\n                let deviceKind = undefined;\n                switch(track.source){\n                    case Track.Source.Microphone:\n                        deviceKind = \"audioinput\";\n                        break;\n                    case Track.Source.Camera:\n                        deviceKind = \"videoinput\";\n                }\n                if (deviceKind && this.activeDeviceMap.has(deviceKind)) {\n                    defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                        deviceId: this.activeDeviceMap.get(deviceKind)\n                    });\n                }\n            }\n            // convert raw media track into audio or video track\n            if (track instanceof MediaStreamTrack) {\n                switch(track.kind){\n                    case \"audio\":\n                        track = new LocalAudioTrack(track, defaultConstraints, true, this.audioContext);\n                        break;\n                    case \"video\":\n                        track = new LocalVideoTrack(track, defaultConstraints, true);\n                        break;\n                    default:\n                        throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                }\n            }\n            if (track instanceof LocalAudioTrack) {\n                track.setAudioContext(this.audioContext);\n            }\n            // is it already published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (existingPublication) {\n                livekitLogger.warn(\"track has already been published, skipping\");\n                return existingPublication;\n            }\n            const isStereoInput = \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n            track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n            const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n            // disable dtx for stereo track if not enabled explicitly\n            if (isStereo) {\n                if (!options) {\n                    options = {};\n                }\n                if (options.dtx === undefined) {\n                    livekitLogger.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                }\n                if (options.red === undefined) {\n                    livekitLogger.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                }\n                (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n            }\n            const opts = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), options);\n            // disable simulcast if e2ee is set on safari\n            if (isSafari() && this.roomOptions.e2ee) {\n                livekitLogger.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari\");\n                opts.simulcast = false;\n            }\n            if (opts.source) {\n                track.source = opts.source;\n            }\n            const publishPromise = this.publish(track, opts, isStereo);\n            this.pendingPublishPromises.set(track, publishPromise);\n            try {\n                const publication = yield publishPromise;\n                return publication;\n            } catch (e) {\n                throw e;\n            } finally{\n                this.pendingPublishPromises.delete(track);\n            }\n        });\n    }\n    publish(track, opts, isStereo) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existingTrackOfSource = Array.from(this.tracks.values()).find((publishedTrack)=>track instanceof LocalTrack && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                livekitLogger.info(\"publishing a second track with the same source: \".concat(track.source));\n            }\n            if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    livekitLogger.error(\"could not determine track dimensions, using defaults\", dims);\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (track instanceof LocalVideoTrack) {\n                    if (isSVCCodec(videoCodec)) {\n                        // vp9 svc with screenshare has problem to encode, always use L1T3 here\n                        if (track.source === Track.Source.ScreenShare && videoCodec === \"vp9\") {\n                            opts.scalabilityMode = \"L1T3\";\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : \"L3T3_KEY\";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: \"\"\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_g = (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate) !== null && _g !== void 0 ? _g : opts.audioBitrate,\n                        priority: (_j = (_h = opts.audioPreset) === null || _h === void 0 ? void 0 : _h.priority) !== null && _j !== void 0 ? _j : \"high\",\n                        networkPriority: (_l = (_k = opts.audioPreset) === null || _k === void 0 ? void 0 : _k.priority) !== null && _l !== void 0 ? _l : \"high\"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const ti = yield this.engine.addTrack(req);\n            // server might not support the codec the client has requested, in that case, fallback\n            // to a supported codec\n            let primaryCodecMime;\n            ti.codecs.forEach((codec)=>{\n                if (primaryCodecMime === undefined) {\n                    primaryCodecMime = codec.mimeType;\n                }\n            });\n            if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                if (updatedCodec !== videoCodec) {\n                    livekitLogger.debug(\"falling back to server selected codec\", {\n                        codec: updatedCodec\n                    });\n                    /* @ts-ignore */ opts.videoCodec = updatedCodec;\n                    // recompute encodings since bitrates/etc could have changed\n                    encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                }\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track);\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            if (!this.engine.pcManager) {\n                throw new UnexpectedConnectionState(\"pcManager is not ready\");\n            }\n            livekitLogger.debug(\"publishing \".concat(track.kind, \" with encodings\"), {\n                encodings,\n                trackInfo: ti\n            });\n            track.sender = yield this.engine.createSender(track, opts, encodings);\n            if (encodings) {\n                if (isFireFox() && track.kind === Track.Kind.Audio) {\n                    /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n             livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n             publish high quality audio track. But firefox always uses this value as the actual\n             bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n             So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n             fix the issue.\n           */ let trackTransceiver = undefined;\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        if (transceiver.sender === track.sender) {\n                            trackTransceiver = transceiver;\n                            break;\n                        }\n                    }\n                    if (trackTransceiver) {\n                        this.engine.pcManager.publisher.setTrackCodecBitrate({\n                            transceiver: trackTransceiver,\n                            codec: \"opus\",\n                            maxbr: ((_m = encodings[0]) === null || _m === void 0 ? void 0 : _m.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                        });\n                    }\n                } else if (track.codec && isSVCCodec(track.codec) && ((_o = encodings[0]) === null || _o === void 0 ? void 0 : _o.maxBitrate)) {\n                    this.engine.pcManager.publisher.setTrackCodecBitrate({\n                        cid: req.cid,\n                        codec: track.codec,\n                        maxbr: encodings[0].maxBitrate / 1000\n                    });\n                }\n            }\n            yield this.engine.negotiate();\n            if (track instanceof LocalVideoTrack) {\n                track.startMonitor(this.engine.client);\n            } else if (track instanceof LocalAudioTrack) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.tracks.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError(\"track is not published\");\n            }\n            if (!(track instanceof LocalVideoTrack)) {\n                throw new TrackInvalidError(\"track is not a video track\");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                livekitLogger.info(\"backup codec has been disabled, ignoring request to add additional codec for track\");\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const ti = yield this.engine.addTrack(req);\n            yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n            yield this.engine.negotiate();\n            livekitLogger.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), {\n                encodings,\n                trackInfo: ti\n            });\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            livekitLogger.debug(\"unpublishing track\", {\n                track,\n                method: \"unpublishTrack\"\n            });\n            if (!publication || !publication.track) {\n                livekitLogger.warn(\"track was not unpublished because no publication was found\", {\n                    track,\n                    method: \"unpublishTrack\"\n                });\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = \"inactive\";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (track instanceof LocalVideoTrack) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    livekitLogger.warn(\"failed to unpublish track\", {\n                        error: e,\n                        method: \"unpublishTrack\"\n                    });\n                }\n            }\n            // remove from our maps\n            this.tracks.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTracks.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTracks.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>track instanceof LocalTrackPublication);\n        });\n    }\n    republishAllTracks(options) {\n        let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return __awaiter(this, void 0, void 0, function*() {\n            const localPubs = [];\n            this.tracks.forEach((pub)=>{\n                if (pub.track) {\n                    if (options) {\n                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                    }\n                    localPubs.push(pub);\n                }\n            });\n            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                    const track = pub.track;\n                    yield this.unpublishTrack(track, false);\n                    if (restartTracks && !track.isMuted && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {\n                        // generally we need to restart the track before publishing, often a full reconnect\n                        // is necessary because computer had gone to sleep.\n                        livekitLogger.debug(\"restarting existing track\", {\n                            track: pub.trackSid\n                        });\n                        yield track.restartTrack();\n                    }\n                    yield this.publishTrack(track, pub.options);\n                })));\n        });\n    }\n    publishData(data, kind) {\n        let publishOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return __awaiter(this, void 0, void 0, function*() {\n            const destination = Array.isArray(publishOptions) ? publishOptions : publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.destination;\n            const destinationSids = [];\n            const topic = !Array.isArray(publishOptions) ? publishOptions.topic : undefined;\n            if (destination !== undefined) {\n                destination.forEach((val)=>{\n                    if (val instanceof RemoteParticipant) {\n                        destinationSids.push(val.sid);\n                    } else {\n                        destinationSids.push(val);\n                    }\n                });\n            }\n            const packet = new DataPacket({\n                kind,\n                value: {\n                    case: \"user\",\n                    value: new UserPacket({\n                        participantSid: this.sid,\n                        payload: data,\n                        destinationSids: destinationSids,\n                        topic\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, kind);\n        });\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.tracks.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    livekitLogger.debug(\"updating server mute state after reconcile\", {\n                        sid: ti.sid,\n                        muted: mutedOnServer\n                    });\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.tracks.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 2 * 1000;\n/** @deprecated RoomState has been renamed to [[ConnectionState]] */ const RoomState = ConnectionState;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _b;\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    livekitLogger.info(\"already connected to room \".concat(this.name));\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().catch((e)=>{\n                        livekitLogger.warn(\"could not fetch region settings\", {\n                            error: e\n                        });\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _c;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== 3 /* ConnectionErrorReason.Cancelled */  && e.reason !== 0 /* ConnectionErrorReason.NotAllowed */ ) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_c = this.abortController) === null || _c === void 0 ? void 0 : _c.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === 3 /* ConnectionErrorReason.Cancelled */ )) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl) {\n                                    livekitLogger.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl));\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                    reject(e);\n                                }\n                            } else {\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    publishOnly: connectOptions.publishOnly,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                livekitLogger.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(\", \")));\n                if (!joinResponse.serverVersion) {\n                    throw new UnsupportedServer(\"unknown server version\");\n                }\n                if (joinResponse.serverVersion === \"0.15.1\" && this.options.dynacast) {\n                    livekitLogger.debug(\"disabling dynacast due to server version\");\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n            if (this.options.e2ee && this.e2eeManager) {\n                this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _d, _e;\n                if (this.state === ConnectionState.Reconnecting) {\n                    livekitLogger.info(\"Reconnection attempt replaced by new connection attempt\");\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_d = this.regionUrlProvider) === null || _d === void 0 ? void 0 : _d.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\");\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    livekitLogger.debug(\"error trying to establish signal connection\", {\n                        error: err\n                    });\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\");\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener(\"pagehide\", this.onPageLeave);\n                    window.addEventListener(\"beforeunload\", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener(\"freeze\", this.onPageLeave);\n                    (_e = navigator.mediaDevices) === null || _e === void 0 ? void 0 : _e.addEventListener(\"devicechange\", this.handleDeviceChange);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return __awaiter(_this, void 0, void 0, function*() {\n                var _f, _g, _h, _j;\n                const unlock = yield this.disconnectLock.lock();\n                try {\n                    if (this.state === ConnectionState.Disconnected) {\n                        livekitLogger.debug(\"already disconnected\");\n                        return;\n                    }\n                    livekitLogger.info(\"disconnect from room\", {\n                        identity: this.localParticipant.identity\n                    });\n                    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n                        // try aborting pending connection attempt\n                        livekitLogger.warn(\"abort connection attempt\");\n                        (_f = this.abortController) === null || _f === void 0 ? void 0 : _f.abort();\n                        // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                        (_h = (_g = this.connectFuture) === null || _g === void 0 ? void 0 : _g.reject) === null || _h === void 0 ? void 0 : _h.call(_g, new ConnectionError(\"Client initiated disconnect\"));\n                        this.connectFuture = undefined;\n                    }\n                    // send leave\n                    if (!((_j = this.engine) === null || _j === void 0 ? void 0 : _j.client.isDisconnected)) {\n                        yield this.engine.client.sendLeave();\n                    }\n                    // close engine (also closes client)\n                    if (this.engine) {\n                        yield this.engine.close();\n                    }\n                    this.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                    /* @ts-ignore */ this.engine = undefined;\n                } finally{\n                    unlock();\n                }\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === \"iOS\") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = \"livekit-dummy-audio-el\";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement(\"audio\");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener(\"visibilitychange\", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.participants.forEach((p)=>{\n                    p.audioTracks.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.participants.values()){\n                    p.videoTracks.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === \"NotAllowedError\") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        livekitLogger.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\");\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.participants.values()){\n                this.handleParticipantDisconnected(p.sid, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                livekitLogger.debug(\"signal reconnected to server\", {\n                    region: joinResponse.serverRegion\n                });\n                this.cachedParticipantSids = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    const localPubs = [];\n                    this.localParticipant.tracks.forEach((pub)=>{\n                        if (pub.track) {\n                            localPubs.push(pub);\n                        }\n                    });\n                    yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                            const track = pub.track;\n                            this.localParticipant.unpublishTrack(track, false);\n                            if (!track.isMuted) {\n                                if ((track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && !track.isUserProvided) {\n                                    // we need to restart the track before publishing, often a full reconnect\n                                    // is necessary because computer had gone to sleep.\n                                    livekitLogger.debug(\"restarting existing track\", {\n                                        track: pub.trackSid\n                                    });\n                                    yield track.restartTrack();\n                                }\n                                livekitLogger.debug(\"publishing new track\", {\n                                    track: pub.trackSid\n                                });\n                                yield this.localParticipant.publishTrack(track, pub.options);\n                            }\n                        })));\n                } catch (error) {\n                    livekitLogger.error(\"error trying to re-publish tracks after reconnection\", {\n                        error\n                    });\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    livekitLogger.debug(\"fully reconnected to server\", {\n                        region: joinResponse.serverRegion\n                    });\n                } catch (_k) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                // emit participant connected events after connection has been re-established\n                this.participants.forEach((participant)=>{\n                    this.emit(RoomEvent.ParticipantConnected, participant);\n                });\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // ensure identity <=> sid mapping\n                const sid = this.identityToSid.get(info.identity);\n                if (sid && sid !== info.sid) {\n                    // sid had changed, need to remove previous participant\n                    this.handleParticipantDisconnected(sid, this.participants.get(sid));\n                }\n                let remoteParticipant = this.participants.get(info.sid);\n                const isNewParticipant = !remoteParticipant;\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.sid, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.sid, info);\n                    if (!isNewParticipant) {\n                        // just update, no events\n                        remoteParticipant.updateInfo(info);\n                    }\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.participants.get(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.participants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.participants.get(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.participants.get(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublication(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                pub.track.streamState = Track.streamStateFromProto(streamState.state);\n                participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.participants.get(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.participants.values()).find((p)=>p.tracks.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublication(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (userPacket, kind)=>{\n            // find the participant\n            const participant = this.participants.get(userPacket.participantSid);\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            livekitLogger.warn(\"could not playback audio\", e);\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.participants.get(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _l;\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (pub.track instanceof LocalAudioTrack) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_l = pub.track) === null || _l === void 0 ? void 0 : _l.getDeviceId();\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.participants = new Map();\n        this.cachedParticipantSids = [];\n        this.identityToSid = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new Mutex();\n        this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>livekitLogger.warn(\"Could not set audio output: \".concat(e.message)));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== \"\") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            this.e2eeManager = new E2EEManager(this.options.e2ee);\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (participant instanceof LocalParticipant) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /** server assigned unique room id */ get sid() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n            this.cachedParticipantSids = Array.from(this.participants.keys());\n        }).on(EngineEvent.Resumed, ()=>{\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            this.emit(RoomEvent.Reconnected);\n            this.registerConnectionReconcile();\n            this.updateSubscriptions();\n            // once reconnected, figure out if any participants connected during reconnect and emit events for it\n            const diffParticipants = Array.from(this.participants.values()).filter((p)=>!this.cachedParticipantSids.includes(p.sid));\n            diffParticipants.forEach((p)=>this.emit(RoomEvent.ParticipantConnected, p));\n            this.cachedParticipantSids = [];\n        }).on(EngineEvent.SignalResumed, ()=>{\n            if (this.state === ConnectionState.Reconnecting) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it handles Chrome's unique behavior of creating `default`\n   * devices. When encountered, it'll be removed from the list of devices.\n   * The actual default device will be placed at top.\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            livekitLogger.debug(\"prepareConnection to \".concat(url));\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: \"HEAD\"\n                        });\n                        livekitLogger.debug(\"prepared connection to \".concat(regionUrl));\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: \"HEAD\"\n                    });\n                }\n            } catch (e) {\n                livekitLogger.warn(\"could not prepare connection\", {\n                    error: e\n                });\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        const sid = this.identityToSid.get(identity);\n        if (sid) {\n            return this.participants.get(sid);\n        }\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case \"signal-reconnect\":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate disconnect\");\n                    break;\n                case \"speaker\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"speakerUpdate\",\n                            value: 3\n                        }\n                    });\n                    break;\n                case \"node-failure\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"nodeFailure\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"server-leave\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"serverLeave\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"migration\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"migration\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"resume-reconnect\":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                    break;\n                case \"full-reconnect\":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n                    break;\n                case \"force-tcp\":\n                case \"force-tls\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"switchCandidateProtocol\",\n                            value: scenario === \"force-tls\" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    canReconnect: true\n                                }));\n                            }\n                        });\n                    break;\n                case \"subscriber-bandwidth\":\n                    if (arg === undefined || typeof arg !== \"number\") {\n                        throw new Error(\"subscriber-bandwidth requires a number as argument\");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"subscriberBandwidth\",\n                            value: BigInt(arg)\n                        }\n                    });\n                    break;\n            }\n            if (req) {\n                this.engine.client.sendSimulateScenario(req);\n                postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    /**\n   * Returns the active audio output device used in this room.\n   * @return the previously successfully set audio output device ID or an empty string if the default device is used.\n   * @deprecated use `getActiveDevice('audiooutput')` instead\n   */ getActiveAudioOutputDevice() {\n        var _a, _b;\n        return (_b = (_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) !== null && _b !== void 0 ? _b : \"\";\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind, deviceId) {\n        let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var _a, _b;\n        var _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            let deviceHasChanged = false;\n            let success = true;\n            const deviceConstraint = exact ? {\n                exact: deviceId\n            } : deviceId;\n            if (kind === \"audioinput\") {\n                const prevDeviceId = this.options.audioCaptureDefaults.deviceId;\n                this.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.audioTracks.values()).filter((track)=>track.source === Track.Source.Microphone);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === \"videoinput\") {\n                const prevDeviceId = this.options.videoCaptureDefaults.deviceId;\n                this.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                const tracks = Array.from(this.localParticipant.videoTracks.values()).filter((track)=>track.source === Track.Source.Camera);\n                try {\n                    success = (yield Promise.all(tracks.map((t)=>{\n                        var _a;\n                        return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                    }))).every((val)=>val === true);\n                } catch (e) {\n                    this.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                    throw e;\n                }\n            } else if (kind === \"audiooutput\") {\n                if (!supportsSetSinkId() && !this.options.expWebAudioMix || this.options.expWebAudioMix && this.audioContext && !(\"setSinkId\" in this.audioContext)) {\n                    throw new Error(\"cannot switch audio output, setSinkId not supported\");\n                }\n                (_a = (_c = this.options).audioOutput) !== null && _a !== void 0 ? _a : _c.audioOutput = {};\n                const prevDeviceId = this.options.audioOutput.deviceId;\n                this.options.audioOutput.deviceId = deviceId;\n                deviceHasChanged = prevDeviceId !== deviceConstraint;\n                try {\n                    if (this.options.expWebAudioMix) {\n                        // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                        (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.setSinkId(deviceId);\n                    } else {\n                        yield Promise.all(Array.from(this.participants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    }\n                } catch (e) {\n                    this.options.audioOutput.deviceId = prevDeviceId;\n                    throw e;\n                }\n            }\n            if (deviceHasChanged && success) {\n                this.localParticipant.activeDeviceMap.set(kind, deviceId);\n                this.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n            }\n            return success;\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.participants.clear();\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            livekitLogger.warn(\"skipping incoming track after Room disconnected\");\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantId = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith(\"TR\")) trackId = streamId;\n        if (participantId === this.localParticipant.sid) {\n            livekitLogger.warn(\"tried to create RemoteParticipant for local participant\");\n            return;\n        }\n        const participant = this.participants.get(participantId);\n        if (!participant) {\n            livekitLogger.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantId));\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === \"object\") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.participants.forEach((p)=>{\n                p.tracks.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.tracks.forEach((pub)=>{\n                var _a, _b;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.tracks.clear();\n            this.localParticipant.videoTracks.clear();\n            this.localParticipant.audioTracks.clear();\n            this.participants.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.expWebAudioMix === \"boolean\") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener(\"beforeunload\", this.onPageLeave);\n                window.removeEventListener(\"pagehide\", this.onPageLeave);\n                window.removeEventListener(\"freeze\", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(sid, participant) {\n        // remove and send event\n        this.participants.delete(sid);\n        if (!participant) {\n            return;\n        }\n        this.identityToSid.delete(participant.identity);\n        participant.tracks.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n    }\n    acquireAudioContext() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof this.options.expWebAudioMix !== \"boolean\" && this.options.expWebAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.expWebAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === \"closed\") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.audioContext && this.audioContext.state === \"suspended\") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield this.audioContext.resume();\n                } catch (e) {\n                    livekitLogger.warn(e);\n                }\n            }\n            if (this.options.expWebAudioMix) {\n                this.participants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(id, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info);\n        } else {\n            participant = new RemoteParticipant(this.engine.client, id, \"\", undefined, undefined);\n        }\n        if (this.options.expWebAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>livekitLogger.warn(\"Could not set audio output: \".concat(e.message)));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(id, info) {\n        if (this.participants.has(id)) {\n            return this.participants.get(id);\n        }\n        const participant = this.createParticipant(id, info);\n        this.participants.set(id, participant);\n        this.identityToSid.set(info.identity, info.sid);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (sid)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.participants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTracks()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTracks(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.participants.values()){\n            for (const pub of p.videoTracks.values()){\n                if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                livekitLogger.warn(\"detected connection state mismatch\", {\n                    numFailures: consecutiveFailures\n                });\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitWhenConnected(event) {\n        if (this.state === ConnectionState.Connected) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: \"RM_SIMULATED\",\n                name: \"simulated-room\",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: \"\",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: \"\",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: \"simulated-local\",\n                name: \"local-name\"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: \"video-dummy\"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack((_a = 160 * participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1, 160, true, true)));\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack()));\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack((_b = 160 * participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1, 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]));\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged) {\n            livekitLogger.debug(\"room event \".concat(event), {\n                event,\n                args\n            });\n        }\n        return super.emit(event, ...args);\n    }\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.errorsAsWarnings = false;\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        if (options.errorsAsWarnings) {\n            this.errorsAsWarnings = options.errorsAsWarnings;\n        }\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error(\"check is running already\");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === \"error\");\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            yield this.room.connect(this.url, this.token);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: \"info\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: \"warning\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: \"error\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit(\"update\", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        options !== null && options !== void 0 ? options : options = {};\n        (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;\n        (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;\n        const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (options.audio) {\n            DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n        }\n        if (options.video) {\n            DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n        }\n        const stream = yield mediaPromise;\n        return stream.getTracks().map((mediaStreamTrack)=>{\n            const isAudio = mediaStreamTrack.kind === \"audio\";\n            isAudio ? options.audio : options.video;\n            let trackConstraints;\n            const conOrBool = isAudio ? constraints.audio : constraints.video;\n            if (typeof conOrBool !== \"boolean\") {\n                trackConstraints = conOrBool;\n            }\n            // update the constraints with the device id the user gave permissions to in the permission prompt\n            // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n            if (trackConstraints) {\n                trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;\n            } else {\n                trackConstraints = {\n                    deviceId: mediaStreamTrack.getSettings().deviceId\n                };\n            }\n            const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);\n            if (track.kind === Track.Kind.Video) {\n                track.source = Track.Source.Camera;\n            } else if (track.kind === Track.Kind.Audio) {\n                track.source = Track.Source.Microphone;\n            }\n            track.mediaStream = stream;\n            return track;\n        });\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined) {\n            options.resolution = ScreenSharePresets.h1080fps15.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError(\"no video track found\");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return \"Can publish audio\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && stat.mediaType === \"audio\") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return \"Can publish video\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && stat.mediaType === \"video\") {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return \"Resuming connection after interruption\";\n    }\n    perform() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            room.on(RoomEvent.Reconnecting, ()=>{\n                reconnectingTriggered = true;\n            }).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose(\"\");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error(\"Did not attempt to reconnect\");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n                throw new Error(\"Not able to reconnect\");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return \"Can connect via TURN\";\n    }\n    perform() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith(\"turn:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith(\"turns:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith(\"stun:\")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning(\"No STUN servers configured on server side.\");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: \"relay\"\n                    }\n                });\n            } else {\n                this.appendWarning(\"No TURN servers configured.\");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return \"Establishing WebRTC connection\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += \" (private)\";\n                            } else {\n                                if (candidate.protocol === \"tcp\" && candidate.tcpType === \"passive\") {\n                                    hasTcp = true;\n                                    str += \" (passive)\";\n                                } else if (candidate.protocol === \"udp\") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info(\"now the room is connected\");\n            } catch (err) {\n                this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning(\"Server is not configured for ICE/TCP\");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(\".\");\n    if (parts.length === 4) {\n        if (parts[0] === \"10\") {\n            return true;\n        } else if (parts[0] === \"192\" && parts[1] === \"168\") {\n            return true;\n        } else if (parts[0] === \"172\") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return \"Connecting to signal connection via WebSocket\";\n    }\n    perform() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n                this.appendWarning(\"Server is insecure, clients may block connections to it\");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        super();\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: \"\",\n            description: \"\"\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit(\"checkUpdate\", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on(\"update\", handleUpdate);\n            const result = yield test.run();\n            test.off(\"update\", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : \"user\",\n        confidence: \"low\"\n    };\n    // 1. Try to get facingMode from track settings.\n    if (\"facingMode\" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.debug(\"rawFacingMode\", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === \"string\" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: \"high\"\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        \"low\",\n        \"medium\"\n    ].includes(result.confidence)) {\n        livekitLogger.debug(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        \"obs virtual camera\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        \"iphone\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ],\n    [\n        \"ipad\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === \"\") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        \"user\",\n        \"environment\",\n        \"left\",\n        \"right\"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsaUJBQWlCQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JBLEVBQUVDLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1FBQ3BCQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxDQUFDQyxNQUFNQyxPQUFPLENBQUNGLE1BQU1HLE9BQU9DLElBQUksQ0FBQ0osR0FBR0QsT0FBTyxDQUFDLFNBQVVNLENBQUM7WUFDcEYsSUFBSUEsTUFBTSxhQUFhLENBQUVBLENBQUFBLEtBQUtSLENBQUFBLEdBQUk7Z0JBQ2pDLElBQUlTLElBQUlILE9BQU9JLHdCQUF3QixDQUFDUCxHQUFHSztnQkFDM0NGLE9BQU9LLGNBQWMsQ0FBQ1gsR0FBR1EsR0FBR0MsRUFBRUcsR0FBRyxHQUFHSCxJQUFJO29CQUN2Q0ksWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVCxDQUFDLENBQUNLLEVBQUU7b0JBQUU7Z0JBQ2pDO1lBQ0Q7UUFDRDtJQUNEO0lBQ0EsT0FBT0YsT0FBT1EsTUFBTSxDQUFDZDtBQUN0QjtBQUVBLElBQUllLGlCQUFpQixPQUFPQyxlQUFlLGNBQWNBLGFBQWEsTUFBa0IsR0FBY0MsQ0FBTUEsR0FBRyxPQUFPQyxXQUFXLGNBQWNBLFNBQVMsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLENBQUM7QUFFOUwsU0FBU0Msd0JBQXlCQyxDQUFDO0lBQ2xDLE9BQU9BLEtBQUtBLEVBQUVDLFVBQVUsSUFBSWhCLE9BQU9pQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixHQUFHLGFBQWFBLENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2pHO0FBRUEsSUFBSUssV0FBVztJQUFDQyxTQUFT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Q1pvb0UsWUFBWTtRQUNkO0tBQUU7Q0FBQztBQUNIOzs7O0NBSUMsR0FDRCxTQUFTSSwwQkFBMEJHLFdBQVc7SUFDNUMsSUFBSXowRjtJQUNKLE1BQU1zc0IsUUFBUW1vRSxZQUFZbmpGLElBQUksR0FBR2hHLFdBQVc7SUFDNUMsNEVBQTRFO0lBQzVFLElBQUlnaEIsVUFBVSxJQUFJO1FBQ2hCLE9BQU9yMUI7SUFDVDtJQUNBLG1EQUFtRDtJQUNuRCxJQUFJczlGLGtCQUFrQmhnRixHQUFHLENBQUMrWCxRQUFRO1FBQ2hDLE9BQU9pb0Usa0JBQWtCNy9GLEdBQUcsQ0FBQzQzQjtJQUMvQjtJQUNBLHFEQUFxRDtJQUNyRCxPQUFPLENBQUN0c0IsS0FBSzlMLE1BQU0wNEMsSUFBSSxDQUFDNG5ELHlCQUF5QjdsRixPQUFPLElBQUlyQyxJQUFJLENBQUMraUMsQ0FBQUE7UUFDL0QsSUFBSSxDQUFDcWxELFFBQVEsR0FBR3JsRDtRQUNoQixPQUFPL2lCLE1BQU1DLFFBQVEsQ0FBQ21vRTtJQUN4QixFQUFDLE1BQU8sUUFBUTEwRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFO0FBQ2hEO0FBQ0EsU0FBU28wRixrQkFBa0IxbEYsSUFBSTtJQUM3QixNQUFNaW1GLGdCQUFnQjtRQUFDO1FBQVE7UUFBZTtRQUFRO0tBQVE7SUFDOUQsT0FBT2ptRixTQUFTelgsYUFBYTA5RixjQUFjcG9FLFFBQVEsQ0FBQzdkO0FBQ3REO0FBRXk3QyxDQUN6N0MsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RyZWFtaW5nLXZpZGVvLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L2Rpc3QvbGl2ZWtpdC1jbGllbnQuZXNtLm1qcz8zMjliIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xuXHRtLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRlICYmIHR5cGVvZiBlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuXHRcdFx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBsb2dsZXZlbCA9IHtleHBvcnRzOiB7fX07XG5cbi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4gIChmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuXG4gICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxuICB9KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSAmJiAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXCJ0cmFjZVwiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGkgPCBsZXZlbCA/IG5vb3AgOiB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fCBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG4gICAgICBzZWxmLmxldmVscyA9IHtcbiAgICAgICAgXCJUUkFDRVwiOiAwLFxuICAgICAgICBcIkRFQlVHXCI6IDEsXG4gICAgICAgIFwiSU5GT1wiOiAyLFxuICAgICAgICBcIldBUk5cIjogMyxcbiAgICAgICAgXCJFUlJPUlwiOiA0LFxuICAgICAgICBcIlNJTEVOVFwiOiA1XG4gICAgICB9O1xuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICBkZWZhdWx0TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnNldExldmVsKGRlZmF1bHRMZXZlbCwgZmFsc2UpO1xuICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICB9O1xuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gIH0pO1xufSkobG9nbGV2ZWwpO1xudmFyIGxvZ2xldmVsRXhwb3J0cyA9IGxvZ2xldmVsLmV4cG9ydHM7XG5cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImRlYnVnXCJdID0gMV0gPSBcImRlYnVnXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiaW5mb1wiXSA9IDJdID0gXCJpbmZvXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJzaWxlbnRcIl0gPSA1XSA9IFwic2lsZW50XCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuY29uc3QgbGl2ZWtpdExvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfVxuICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBPYmplY3QudmFsdWVzKGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXJzKCkpKSB7XG4gICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgfVxufVxuLyoqXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcbiAqIGlmIHNldCwgdGhlIGJyb3dzZXIgbG9ncyB3aWxsIGxvc2UgdGhlaXIgc3RhY2t0cmFjZSBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCN3cml0aW5nLXBsdWdpbnMpXG4gKi9cbmZ1bmN0aW9uIHNldExvZ0V4dGVuc2lvbihleHRlbnNpb24pIHtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbGl2ZWtpdExvZ2dlci5tZXRob2RGYWN0b3J5O1xuICBsaXZla2l0TG9nZ2VyLm1ldGhvZEZhY3RvcnkgPSAobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpID0+IHtcbiAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgIGNvbnN0IGxvZ0xldmVsID0gTG9nTGV2ZWxbbWV0aG9kTmFtZV07XG4gICAgY29uc3QgbmVlZExvZyA9IGxvZ0xldmVsID49IGNvbmZpZ0xldmVsICYmIGxvZ0xldmVsIDwgTG9nTGV2ZWwuc2lsZW50O1xuICAgIHJldHVybiAobXNnLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dCkgcmF3TWV0aG9kKG1zZywgY29udGV4dCk7ZWxzZSByYXdNZXRob2QobXNnKTtcbiAgICAgIGlmIChuZWVkTG9nKSB7XG4gICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBsaXZla2l0TG9nZ2VyLnNldExldmVsKGxpdmVraXRMb2dnZXIuZ2V0TGV2ZWwoKSk7IC8vIEJlIHN1cmUgdG8gY2FsbCBzZXRMZXZlbCBtZXRob2QgaW4gb3JkZXIgdG8gYXBwbHkgcGx1Z2luXG59XG5sb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsay1lMmVlJyk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LFxuICBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsXG4gIFVJTlQzMl9NQVggPSAweGZmZmZmZmZmLFxuICBJTlQzMl9NQVggPSAweDdmZmZmZmZmLFxuICBJTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJbnQzMihhcmcpIHtcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHVuc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IFVJTlQzMl9NQVggfHwgYXJnIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgcHJvdG9idWYgZmxvYXQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEZsb2F0MzIoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKSByZXR1cm47XG4gIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jb25zdCBlbnVtVHlwZVN5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi9lbnVtLXR5cGVcIik7XG4vKipcbiAqIEdldCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIGZyb20gYSBnZW5lcmF0ZWQgZW51bS5cbiAqIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgZ2VuZXJhdGVkXG4gKiBlbnVtLCBpdCByYWlzZXMgYW4gZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCB0ID0gZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF07XG4gIGFzc2VydCh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICByZXR1cm4gdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxufVxuLyoqXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gb24gYSBnZW5lcmF0ZWQgZW51bS5cbiAqL1xuZnVuY3Rpb24gc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF0gPSBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcy5tYXAodiA9PiAoe1xuICAgIG5vOiB2Lm5vLFxuICAgIG5hbWU6IHYubmFtZSxcbiAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub11cbiAgfSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEVudW1UeXBlIHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5fb3B0KSB7XG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3QgbnVtYmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IG5vcm1hbFZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgLy8gY29uc3QgdmFsdWU6IEVudW1WYWx1ZUluZm8gPSB7Li4udiwgb3B0aW9uczogdi5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3R9O1xuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgIG5vcm1hbFZhbHVlcy5wdXNoKG4pO1xuICAgIG5hbWVzW3ZhbHVlLm5hbWVdID0gbjtcbiAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlTmFtZSxcbiAgICB2YWx1ZXM6IG5vcm1hbFZhbHVlcyxcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgIC8vIG9wdGlvbnM6IG9wdD8ub3B0aW9ucyA/PyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGZpbmROYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcbiAgICB9LFxuICAgIGZpbmROdW1iZXIobm8pIHtcbiAgICAgIHJldHVybiBudW1iZXJzW25vXTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbnVtIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnVtKHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgZW51bU9iamVjdFtuLmxvY2FsTmFtZV0gPSBuLm5vO1xuICAgIGVudW1PYmplY3Rbbi5ub10gPSBuLmxvY2FsTmFtZTtcbiAgfVxuICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzKTtcbiAgcmV0dXJuIGVudW1PYmplY3Q7XG59XG5mdW5jdGlvbiBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpIHtcbiAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7XG4gICAgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lXG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBNZXNzYWdlIGlzIHRoZSBiYXNlIGNsYXNzIG9mIGV2ZXJ5IG1lc3NhZ2UsIGdlbmVyYXRlZCwgb3IgY3JlYXRlZCBhdFxuICogcnVudGltZS5cbiAqXG4gKiBJdCBpcyBfbm90XyBzYWZlIHRvIGV4dGVuZCB0aGlzIGNsYXNzLiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBtZXNzYWdlIGF0XG4gKiBydW4gdGltZSwgdXNlIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoKS5cbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmVxdWFscyh0aGlzLmdldFR5cGUoKSwgdGhpcywgb3RoZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICpcbiAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xuICAgKiBleGlzdGluZyBrZXlzLlxuICAgKlxuICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxuICAgKiBuZXcgZGF0YS5cbiAgICovXG4gIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UodGhpcywgb3B0LnJlYWRlckZhY3RvcnkoYnl0ZXMpLCBieXRlcy5ieXRlTGVuZ3RoLCBvcHQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXG4gICAqL1xuICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbixcbiAgICAgIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBcIi5jb25jYXQodGhpcy5nZXRUeXBlKCkudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cbiAgICovXG4gIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXG4gICAgICBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLFxuICAgICAgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICB3cml0ZXIgPSBvcHQud3JpdGVyRmFjdG9yeSgpO1xuICAgIGJpbi53cml0ZU1lc3NhZ2UodGhpcywgd3JpdGVyLCBvcHQpO1xuICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cbiAgICovXG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAganNvbiA9IHR5cGUucnVudGltZS5qc29uLFxuICAgICAgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICovXG4gIHRvSnNvblN0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldHR5U3BhY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGUgZm9yIHNlcmlhbGl6YXRpb24gYmVoYXZpb3IuIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW4gY2FsbGluZ1xuICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHNlcmlhbGl6ZSBnb29nbGUucHJvdG9idWYuQW55IHdpdGggYSBwYWNrZWRcbiAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgKiB1bnBhY2tlZCwgYW5kIHRoaXMgaXMgb25seSBwb3NzaWJsZSB3aXRoIGEgdHlwZSByZWdpc3RyeSB0byBsb29rIHVwIHRoZVxuICAgKiBtZXNzYWdlIHR5cGUuICBBcyBhIHJlc3VsdCwgYXR0ZW1wdGluZyB0byBzZXJpYWxpemUgYSBtZXNzYWdlIHdpdGggdGhpc1xuICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHByb3RlY3RlZCBiZWNhdXNlIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gaW52b2tlIGl0XG4gICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICogc3RyaW5naWZpZWQgSlNPTi4gIEFsdGVybmF0aXZlbHksIGlmIGFjdHVhbCBKU09OIGlzIGRlc2lyZWQsIHlvdSBzaG91bGRcbiAgICogdXNlIHRvSnNvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIE1lc3NhZ2VUeXBlIG9mIHRoaXMgbWVzc2FnZSAtIGEgc2luZ2xldG9uIHRoYXQgcmVwcmVzZW50c1xuICAgKiB0aGUgcHJvdG9idWYgbWVzc2FnZSBkZWNsYXJhdGlvbiBhbmQgcHJvdmlkZXMgbWV0YWRhdGEgZm9yIHJlZmxlY3Rpb24tXG4gICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIHR5cGUgdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNZXNzYWdlVHlwZShydW50aW1lLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBsb2NhbE5hbWUgPSAoX2EgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlTmFtZS5zdWJzdHJpbmcodHlwZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gIGNvbnN0IHR5cGUgPSB7XG4gICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBydW50aW1lLnV0aWwuaW5pdEZpZWxkcyh0aGlzKTtcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICB9XG4gIH1bbG9jYWxOYW1lXTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcbiAgT2JqZWN0LmFzc2lnbih0eXBlLCB7XG4gICAgcnVudGltZSxcbiAgICB0eXBlTmFtZSxcbiAgICBmaWVsZHM6IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoZmllbGRzKSxcbiAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIGpzb24sIGJpbiwgdXRpbCkge1xuICByZXR1cm4ge1xuICAgIHN5bnRheCxcbiAgICBqc29uLFxuICAgIGJpbixcbiAgICB1dGlsLFxuICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICB9LFxuICAgIG1ha2VFbnVtLFxuICAgIG1ha2VFbnVtVHlwZSxcbiAgICBnZXRFbnVtVHlwZVxuICB9O1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBTY2FsYXIgdmFsdWUgdHlwZXMuIFRoaXMgaXMgYSBzdWJzZXQgb2YgZmllbGQgdHlwZXMgZGVjbGFyZWQgYnkgcHJvdG9idWZcbiAqIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgVGhlIHR5cGVzIEdST1VQIGFuZCBNRVNTQUdFXG4gKiBhcmUgb21pdHRlZCwgYnV0IHRoZSBudW1lcmljYWwgdmFsdWVzIGFyZSBpZGVudGljYWwuXG4gKi9cbnZhciBTY2FsYXJUeXBlO1xuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XG4gIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9ycy5cbiAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGTE9BVFwiXSA9IDJdID0gXCJGTE9BVFwiO1xuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIklOVDY0XCJdID0gM10gPSBcIklOVDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXG4gIC8vIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbGlrZWx5LlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRklYRUQzMlwiXSA9IDddID0gXCJGSVhFRDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XG4gIC8vIFRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcbiAgLy8gdHJlYXQgZ3JvdXAgZmllbGRzIGFzIHVua25vd24gZmllbGRzLlxuICAvLyBUWVBFX0dST1VQID0gMTAsXG4gIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXG4gIC8vIE5ldyBpbiB2ZXJzaW9uIDIuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xuICAvLyBUWVBFX0VOVU0gPSAxNCxcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UMzJcIl0gPSAxN10gPSBcIlNJTlQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbnZhciBMb25nVHlwZTtcbihmdW5jdGlvbiAoTG9uZ1R5cGUpIHtcbiAgLyoqXG4gICAqIFVzZSBKYXZhU2NyaXB0IEJpZ0ludC5cbiAgICovXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xuICAvKipcbiAgICogVXNlIEphdmFTY3JpcHQgU3RyaW5nLlxuICAgKlxuICAgKiBGaWVsZCBvcHRpb24gYFtqc3R5cGUgPSBKU19TVFJJTkddYC5cbiAgICovXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcblxuLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gIH1cbiAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xuICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gIH1cbiAgZm9yIChsZXQgc2hpZnQgPSAzOyBzaGlmdCA8PSAzMTsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3BsaXRCaXRzID0gbG8gPj4+IDI4ICYgMHgwZiB8IChoaSAmIDB4MDcpIDw8IDQ7XG4gIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XG4gIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGJ5dGVzLnB1c2goaGkgPj4+IDMxICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xuICBpZiAobWludXMpIHtcbiAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gIH1cbiAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAvLyBkaWdpdHMgdG8gYmluYXJ5LiBUaGlzIGlzIHNhZmUgdG8gZG8gd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoIGJlY2F1c2VcbiAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gIGNvbnN0IGJhc2UgPSAxZTY7XG4gIGxldCBsb3dCaXRzID0gMDtcbiAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xuICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cbiAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArIChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbiAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XG4gICAgfVxuICB9XG4gIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICBhZGQxZTZkaWdpdCgtMTIsIC02KTtcbiAgYWRkMWU2ZGlnaXQoLTYpO1xuICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgLy8gYSBtYW51YWwgdHdvJ3MgY29tcGxlbWVudCBjb252ZXJzaW9uIGJlZm9yZSB0aGUgZGVjaW1hbCBjb252ZXJzaW9uLlxuICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAoe1xuICAgIGxvLFxuICAgIGhpXG4gIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xuICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXG4gIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cbiAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xuICB9XG4gIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgY29uc3QgbG93ID0gbG8gJiAweEZGRkZGRjtcbiAgY29uc3QgbWlkID0gKGxvID4+PiAyNCB8IGhpIDw8IDgpICYgMHhGRkZGRkY7XG4gIGNvbnN0IGhpZ2ggPSBoaSA+PiAxNiAmIDB4RkZGRjtcbiAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgbGV0IGRpZ2l0QSA9IGxvdyArIG1pZCAqIDY3NzcyMTYgKyBoaWdoICogNjcxMDY1NjtcbiAgbGV0IGRpZ2l0QiA9IG1pZCArIGhpZ2ggKiA4MTQ3NDk3O1xuICBsZXQgZGlnaXRDID0gaGlnaCAqIDI7XG4gIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgIGRpZ2l0QSAlPSBiYXNlO1xuICB9XG4gIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgIGRpZ2l0QiAlPSBiYXNlO1xuICB9XG4gIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxuICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcbn1cbmZ1bmN0aW9uIHRvVW5zaWduZWQobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvID4+PiAwLFxuICAgIGhpOiBoaSA+Pj4gMFxuICB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgcmV0dXJuIHtcbiAgICBsbzogbG8gfCAwLFxuICAgIGhpOiBoaSB8IDBcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gIGlmIChsb3dCaXRzKSB7XG4gICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBsb3dCaXRzIGlzIDAsIHRoZW4gYml0d2lzZS1ub3QgaXMgMHhGRkZGRkZGRixcbiAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICBoaWdoQml0cyArPSAxO1xuICB9XG4gIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gZGlnaXQxZTcgPT4ge1xuICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMTI3IHwgMTI4KTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICB9XG4gICAgYnl0ZXMucHVzaCgxKTtcbiAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHgwZikgPDwgMjg7XG4gIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKSBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGlmICgoYiAmIDB4ODApICE9IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgLy8gbm90ZSB0aGF0IFNhZmFyaSAxNCBpbXBsZW1lbnRzIEJpZ0ludCwgYnV0IG5vdCB0aGUgRGF0YVZpZXcgbWV0aG9kc1xuICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwcm9jZXNzLmVudiAhPSBcIm9iamVjdFwiIHx8IHByb2Nlc3MuZW52LkJVRl9CSUdJTlRfRElTQUJMRSAhPT0gXCIxXCIpO1xuICBpZiAob2spIHtcbiAgICBjb25zdCBNSU4gPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSxcbiAgICAgIE1BWCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIiksXG4gICAgICBVTUlOID0gQmlnSW50KFwiMFwiKSxcbiAgICAgIFVNQVggPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGJpID4gTUFYIHx8IGJpIDwgTUlOKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgfSxcbiAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBpZiAoYmkgPiBVTUFYIHx8IGJpIDwgVU1JTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmk7XG4gICAgICB9LFxuICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMucGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnVQYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkdi5nZXRCaWdVaW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdCBhc3NlcnRJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgcmV0dXJuIHtcbiAgICB6ZXJvOiBcIjBcIixcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdUVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuICAgIGRlYyhsbywgaGkpIHtcbiAgICAgIHJldHVybiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfSxcbiAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgcHJvdG9JbnQ2NCA9IG1ha2VJbnQ2NFN1cHBvcnQoKTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbnZhciBXaXJlVHlwZTtcbihmdW5jdGlvbiAoV2lyZVR5cGUpIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGZpeGVkNjQsIHNmaXhlZDY0LCBkb3VibGUuXG4gICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQ2NFwiXSA9IDFdID0gXCJCaXQ2NFwiO1xuICAvKipcbiAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcbiAgICpcbiAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcbiAgICogcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGdyb3Vwc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJFbmRHcm91cFwiXSA9IDRdID0gXCJFbmRHcm91cFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxuICAgKiBBbHdheXMgNCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcbn0pKFdpcmVUeXBlIHx8IChXaXJlVHlwZSA9IHt9KSk7XG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xuICAgIC8qKlxuICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxuICAgICAqL1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmJ1ZiA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTsgLy8gZmx1c2ggdGhlIGJ1ZmZlclxuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlcy5zZXQodGhpcy5jaHVua3NbaV0sIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHJldHVybiBieXRlcztcbiAgfVxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXG4gICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxuICAgKlxuICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxuICAgKi9cbiAgZm9yaygpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgY2h1bmtzOiB0aGlzLmNodW5rcyxcbiAgICAgIGJ1ZjogdGhpcy5idWZcbiAgICB9KTtcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIHRoaXMuYnVmID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICovXG4gIGpvaW4oKSB7XG4gICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcbiAgICBsZXQgY2h1bmsgPSB0aGlzLmZpbmlzaCgpO1xuICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgaWYgKCFwcmV2KSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XG4gICAgdGhpcy5idWYgPSBwcmV2LmJ1ZjtcbiAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGVzIGEgdGFnIChmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZSkuXG4gICAqXG4gICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgKlxuICAgKiBHZW5lcmF0ZWQgY29kZSBzaG91bGQgY29tcHV0ZSB0aGUgdGFnIGFoZWFkIG9mIHRpbWUgYW5kIGNhbGwgYHVpbnQzMigpYC5cbiAgICovXG4gIHRhZyhmaWVsZE5vLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgY2h1bmsgb2YgcmF3IGJ5dGVzLlxuICAgKi9cbiAgcmF3KGNodW5rKSB7XG4gICAgaWYgKHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpO1xuICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHVpbnQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50MzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMiwgaW5saW5lZCBmb3Igc3BlZWRcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlICYgMHg3ZiB8IDB4ODApO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICB9XG4gICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGludDMyYCB2YWx1ZSwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIGludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2wodmFsdWUpIHtcbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBieXRlc2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAqL1xuICBieXRlcyh2YWx1ZSkge1xuICAgIHRoaXMudWludDMyKHZhbHVlLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxuICAgKi9cbiAgc3RyaW5nKHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZmxvYXQodmFsdWUpIHtcbiAgICBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBkb3VibGVgIHZhbHVlLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldFVpbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwO1xuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLFxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxuICAgICAgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXG4gICAgICB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksXG4gICAgICB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgaW50NjQodmFsdWUpIHtcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpLFxuICAgICAgLy8gemlnemFnIGVuY29kZVxuICAgICAgc2lnbiA9IHRjLmhpID4+IDMxLFxuICAgICAgbG8gPSB0Yy5sbyA8PCAxIF4gc2lnbixcbiAgICAgIGhpID0gKHRjLmhpIDw8IDEgfCB0Yy5sbyA+Pj4gMzEpIF4gc2lnbjtcbiAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGB1aW50NjRgIHZhbHVlLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgdWludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihidWYsIHRleHREZWNvZGVyKSB7XG4gICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50MzJgIGZpZWxkLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyhidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cbiAgICovXG4gIHRhZygpIHtcbiAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSxcbiAgICAgIGZpZWxkTm8gPSB0YWcgPj4+IDMsXG4gICAgICB3aXJlVHlwZSA9IHRhZyAmIDc7XG4gICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xuICB9XG4gIC8qKlxuICAgKiBTa2lwIG9uZSBlbGVtZW50IG9uIHRoZSB3aXJlIGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cbiAgICogU3VwcG9ydHMgV2lyZVR5cGUuU3RhcnRHcm91cCBzaW5jZSB2Mi4wLjAtYWxwaGEuMjMuXG4gICAqL1xuICBza2lwKHdpcmVUeXBlKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDB4ODApIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0MzI6XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAvLyBGcm9tIGRlc2NyaXB0b3IucHJvdG86IEdyb3VwIHR5cGUgaXMgZGVwcmVjYXRlZCwgbm90IHN1cHBvcnRlZCBpbiBwcm90bzMuXG4gICAgICAgIC8vIEJ1dCB3ZSBtdXN0IHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgYW5kIHRyZWF0IGFzIHVua25vd24uXG4gICAgICAgIGxldCB0O1xuICAgICAgICB3aGlsZSAoKHQgPSB0aGlzLnRhZygpWzFdKSAhPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcbiAgICAgICAgICB0aGlzLnNraXAodCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgIH1cbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqL1xuICBhc3NlcnRCb3VuZHMoKSB7XG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXG4gICAqL1xuICBzaW50MzIoKSB7XG4gICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XG4gICAgLy8gZGVjb2RlIHppZ3phZ1xuICAgIHJldHVybiB6emUgPj4+IDEgXiAtKHp6ZSAmIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDY0YCBmaWVsZCwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIGludDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHVpbnQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAqL1xuICB1aW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQ2NCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICBsZXQgcyA9IC0obG8gJiAxKTtcbiAgICBsbyA9IChsbyA+Pj4gMSB8IChoaSAmIDEpIDw8IDMxKSBeIHM7XG4gICAgaGkgPSBoaSA+Pj4gMSBeIHM7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cbiAgICovXG4gIGJvb2woKSB7XG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgIHJldHVybiBsbyAhPT0gMCB8fCBoaSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDMyYCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkMzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRJbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICovXG4gIGZpeGVkNjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQudURlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQtYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGZsb2F0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBkb3VibGVgIGZpZWxkLCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gICAqL1xuICBkb3VibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDY0KCh0aGlzLnBvcyArPSA4KSAtIDgsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGJ5dGVzYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICovXG4gIGJ5dGVzKCkge1xuICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLFxuICAgICAgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAqL1xuICBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZnVuY3Rpb24gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UgfHwgIXR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuKHtcbiAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjogU2NhbGFyVHlwZS5GTE9BVCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDY0LFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDMyLFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQzMixcbiAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjogU2NhbGFyVHlwZS5TVFJJTkcsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogU2NhbGFyVHlwZS5CWVRFU1xufSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgIHJldHVybiBhID09IGI7XG4gIH1cbiAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUsIGZvbGxvd2luZ1xuICogcHJvdG8zIHNlbWFudGljcy5cbiAqL1xuZnVuY3Rpb24gc2NhbGFyRGVmYXVsdFZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPT0gMCA/IHByb3RvSW50NjQuemVybyA6IFwiMFwiO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIDAuMDtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlIGZvciBwcm90bzMgc2VtYW50aWNzXG4gKlxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICovXG5mdW5jdGlvbiBzY2FsYXJUeXBlSW5mbyh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBpc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gIGxldCB3aXJlVHlwZSA9IFdpcmVUeXBlLlZhcmludDtcbiAgbGV0IGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUubGVuZ3RoO1xuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwOyAvLyBMb29zZSBjb21wYXJpc29uIG1hdGNoZXMgMG4sIDAgYW5kIFwiMFwiXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICBpc0ludHJpbnNpY0RlZmF1bHQgPSBpc1VuZGVmaW5lZCB8fCAhdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlzSW50cmluc2ljRGVmYXVsdCA9IGlzVW5kZWZpbmVkIHx8IHZhbHVlID09IDA7XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCBtZXRob2QgPSBTY2FsYXJUeXBlW3R5cGVdLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBbd2lyZVR5cGUsIG1ldGhvZCwgaXNVbmRlZmluZWQgfHwgaXNJbnRyaW5zaWNEZWZhdWx0XTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBuby1jYXNlLWRlY2xhcmF0aW9ucywgcHJlZmVyLWNvbnN0ICovXG5jb25zdCB1bmtub3duRmllbGRzU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL3Vua25vd24tZmllbGRzXCIpO1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIGJpbmFyeSBkYXRhLlxuY29uc3QgcmVhZERlZmF1bHRzID0ge1xuICByZWFkVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgcmVhZGVyRmFjdG9yeTogYnl0ZXMgPT4gbmV3IEJpbmFyeVJlYWRlcihieXRlcylcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcbiAgd3JpdGVVbmtub3duRmllbGRzOiB0cnVlLFxuICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKClcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMkMShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IHJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMkMShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdENvbW1vbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtYWtlUmVhZE9wdGlvbnM6IG1ha2VSZWFkT3B0aW9ucyQxLFxuICAgIG1ha2VXcml0ZU9wdGlvbnM6IG1ha2VXcml0ZU9wdGlvbnMkMSxcbiAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfSxcbiAgICBkaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICB9LFxuICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICBpZiAoYykge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xuICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSkge1xuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcbiAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgfVxuICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHtcbiAgICAgICAgbm8sXG4gICAgICAgIHdpcmVUeXBlLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgY29uc3QgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKSxcbiAgICAgICAgICBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IG1lc3NhZ2UsXG4gICAgICAgICAgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZCxcbiAgICAgICAgICBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgICAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXIkMTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgICAgICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5MID4gMCkge1xuICAgICAgICAgICAgICByZWFkID0gcmVhZFNjYWxhckxUU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgbGV0IGUgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xuICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkKHJlYWRlciwgc2NhbGFyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0ucHVzaChyZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXVttYXBLZXldID0gbWFwVmFsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vLyBSZWFkIGEgbWVzc2FnZSwgYXZvaWRpbmcgTWVzc2FnZVR5cGUuZnJvbUJpbmFyeSgpIHRvIHJlLXVzZSB0aGVcbi8vIEJpbmFyeVJlYWRPcHRpb25zIGFuZCB0aGUgSUJpbmFyeVJlYWRlci5cbmZ1bmN0aW9uIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSxcbiAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICBsZXQga2V5LCB2YWw7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgbGV0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAga2V5ID0gcmVhZFNjYWxhciQxKHJlYWRlciwgZmllbGQuSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIkMShyZWFkZXIsIGZpZWxkLlYuVCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgdmFsID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleVJhdyA9IHNjYWxhckRlZmF1bHRWYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xuICAgIGtleSA9IGZpZWxkLksgPT0gU2NhbGFyVHlwZS5CT09MID8ga2V5UmF3LnRvU3RyaW5nKCkgOiBrZXlSYXc7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9IFwibnVtYmVyXCIpIHtcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB2YWwgPSBzY2FsYXJEZWZhdWx0VmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgdmFsID0gbmV3IGZpZWxkLlYuVCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgY29uc3QgdiA9IHJlYWRTY2FsYXIkMShyZWFkZXIsIHR5cGUpO1xuICByZXR1cm4gdHlwZW9mIHYgPT0gXCJiaWdpbnRcIiA/IHYudG9TdHJpbmcoKSA6IHY7XG59XG4vLyBEb2VzIG5vdCB1c2Ugc2NhbGFyVHlwZUluZm8oKSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHJlYWRlciwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gcmVhZGVyLmRvdWJsZSgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5pbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIHJlYWRlci5ieXRlcygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50MzIoKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbHVlKSB7XG4gIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XG4gIHdyaXRlci5mb3JrKCk7XG4gIC8vIGphdmFzY3JpcHQgb25seSBhbGxvd3MgbnVtYmVyIG9yIHN0cmluZyBmb3Igb2JqZWN0IHByb3BlcnRpZXNcbiAgLy8gd2UgY29udmVydCBmcm9tIG91ciByZXByZXNlbnRhdGlvbiB0byB0aGUgcHJvdG9idWYgdHlwZVxuICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIHdlIGRlbGliZXJhdGVseSBoYW5kbGUganVzdCB0aGUgc3BlY2lhbCBjYXNlcyBmb3IgbWFwIGtleXNcbiAgc3dpdGNoIChmaWVsZC5LKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICBhc3NlcnQoa2V5ID09IFwidHJ1ZVwiIHx8IGtleSA9PSBcImZhbHNlXCIpO1xuICAgICAga2V5VmFsdWUgPSBrZXkgPT0gXCJ0cnVlXCI7XG4gICAgICBicmVhaztcbiAgfVxuICAvLyB3cml0ZSBrZXksIGV4cGVjdGluZyBrZXkgZmllbGQgbnVtYmVyID0gMVxuICB3cml0ZVNjYWxhciQxKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUsIHRydWUpO1xuICAvLyB3cml0ZSB2YWx1ZSwgZXhwZWN0aW5nIHZhbHVlIGZpZWxkIG51bWJlciA9IDJcbiAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICB3cml0ZVNjYWxhciQxKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIFNjYWxhclR5cGUuSU5UMzIsIDIsIHZhbHVlLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlYuVCwgMiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cbmZ1bmN0aW9uIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKHR5cGUsIHZhbHVlKTtcbiAgICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEod3JpdGVyLCB0eXBlLCBmaWVsZE5vLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kLCBpc0ludHJpbnNpY0RlZmF1bHRdID0gc2NhbGFyVHlwZUluZm8odHlwZSwgdmFsdWUpO1xuICBpZiAoIWlzSW50cmluc2ljRGVmYXVsdCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIHdyaXRlci50YWcoZmllbGRObywgd2lyZVR5cGUpW21ldGhvZF0odmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB3cml0ZXJbbWV0aG9kXSh2YWx1ZVtpXSk7XG4gIH1cbiAgd3JpdGVyLmpvaW4oKTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMsIHByZWZlci1jb25zdCwgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXRQcm90bzMoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VCaW5hcnlGb3JtYXRDb21tb24oKSksIHtcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgbGV0IHZhbHVlLFxuICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBvdXIgZmllbGQgdmFsdWUsIHdoZXRoZXIgaXQgaXMgbWVtYmVyIG9mIGEgb25lb2Ygb3IgcmVndWxhciBmaWVsZFxuICAgICAgICAgIHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQsXG4gICAgICAgICAgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICBjb25zdCBvbmVvZiA9IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICBpZiAob25lb2YuY2FzZSAhPT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZmllbGQgaXMgbm90IHNlbGVjdGVkLCBza2lwXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gb25lb2YudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBtZXNzYWdlW2xvY2FsTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVTY2FsYXIkMSh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQuVCwgZmllbGQubm8sIGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLlQsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcykge1xuICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBwcmVmZXItY29uc3QgKi9cbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxubGV0IGVuY1RhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuc3BsaXQoXCJcIik7XG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyICpjb2RlKiB0byBieXRlIGJlY2F1c2UgbG9va3VwIGJ5IG51bWJlciBpcyBmYXN0XG5sZXQgZGVjVGFibGUgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgZW5jVGFibGUubGVuZ3RoOyBpKyspIGRlY1RhYmxlW2VuY1RhYmxlW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbi8vIHN1cHBvcnQgYmFzZTY0dXJsIHZhcmlhbnRzXG5kZWNUYWJsZVtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIrXCIpO1xuZGVjVGFibGVbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiL1wiKTtcbmNvbnN0IHByb3RvQmFzZTY0ID0ge1xuICAvKipcbiAgICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICAgKlxuICAgKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xuICAgKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAgICogLSBkb2VzIG5vdCByZXF1aXJlIHBhZGRpbmdcbiAgICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XG4gICAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAgICogICBcIl9cIiBpbnN0ZWFkIG9mIFwiL1wiLFxuICAgKiAgIG5vIHBhZGRpbmdcbiAgICovXG4gIGRlYyhiYXNlNjRTdHIpIHtcbiAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgbGV0IGVzID0gYmFzZTY0U3RyLmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09IFwiPVwiKSBlcyAtPSAyO2Vsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpIGVzIC09IDE7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLFxuICAgICAgYnl0ZVBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgICBncm91cFBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgIGIsXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcbiAgICAgIHAgPSAwOyAvLyBwcmV2aW91cyBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRTdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBkZWNUYWJsZVtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV07XG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAvLyByZXNldCBzdGF0ZSB3aGVuIHBhZGRpbmcgZm91bmRcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIGNhc2UgXCJcXHRcIjpcbiAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgLy8gc2tpcCB3aGl0ZS1zcGFjZSwgYW5kIHBhZGRpbmdcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gcCA8PCAyIHwgKGIgJiA0OCkgPj4gNDtcbiAgICAgICAgICBwID0gYjtcbiAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAxNSkgPDwgNCB8IChiICYgNjApID4+IDI7XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMykgPDwgNiB8IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgIHJldHVybiBieXRlcy5zdWJhcnJheSgwLCBieXRlUG9zKTtcbiAgfSxcbiAgLyoqXG4gICAqIEVuY29kZSBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlNjQgc3RyaW5nLlxuICAgKi9cbiAgZW5jKGJ5dGVzKSB7XG4gICAgbGV0IGJhc2U2NCA9IFwiXCIsXG4gICAgICBncm91cFBvcyA9IDAsXG4gICAgICAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcbiAgICAgIGIsXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcbiAgICAgIHAgPSAwOyAvLyBjYXJyeSBvdmVyIGZyb20gcHJldmlvdXMgYnl0ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBieXRlc1tpXTtcbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiID4+IDJdO1xuICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDRdO1xuICAgICAgICAgIHAgPSAoYiAmIDE1KSA8PCAyO1xuICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA2XTtcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiAmIDYzXTtcbiAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBvdXRwdXQgcGFkZGluZ1xuICAgIGlmIChncm91cFBvcykge1xuICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgaWYgKGdyb3VwUG9zID09IDEpIGJhc2U2NCArPSBcIj1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfVxufTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQgKi9cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBKU09OLlxuY29uc3QganNvblJlYWREZWZhdWx0cyA9IHtcbiAgaWdub3JlVW5rbm93bkZpZWxkczogZmFsc2Vcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIHRvIEpTT04uXG5jb25zdCBqc29uV3JpdGVEZWZhdWx0cyA9IHtcbiAgZW1pdERlZmF1bHRWYWx1ZXM6IGZhbHNlLFxuICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxuICBwcmV0dHlTcGFjZXM6IDBcbn07XG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvblJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDoganNvblJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUpzb25Gb3JtYXRDb21tb24obWFrZVdyaXRlRmllbGQpIHtcbiAgY29uc3Qgd3JpdGVGaWVsZCA9IG1ha2VXcml0ZUZpZWxkKHdyaXRlRW51bSwgd3JpdGVTY2FsYXIpO1xuICByZXR1cm4ge1xuICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICBtYWtlV3JpdGVPcHRpb25zLFxuICAgIHJlYWRNZXNzYWdlKHR5cGUsIGpzb24sIG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgICAgIGlmIChqc29uID09IG51bGwgfHwgQXJyYXkuaXNBcnJheShqc29uKSB8fCB0eXBlb2YganNvbiAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvbikpKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgY29uc3Qgb25lb2ZTZWVuID0ge307XG4gICAgICBmb3IgKGNvbnN0IFtqc29uS2V5LCBqc29uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24pKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZEpzb25OYW1lKGpzb25LZXkpO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCAmJiBmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcbiAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNlZW4gPSBvbmVvZlNlZW5bZmllbGQub25lb2YubG9jYWxOYW1lXTtcbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IG11bHRpcGxlIGtleXMgZm9yIG9uZW9mIFxcXCJcIikuY29uY2F0KGZpZWxkLm9uZW9mLm5hbWUsIFwiXFxcIiBwcmVzZW50OiBcXFwiXCIpLmNvbmNhdChzZWVuLCBcIlxcXCIsIFxcXCJcIikuY29uY2F0KGpzb25LZXksIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9uZW9mU2VlbltmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ganNvbktleTtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgIGNhc2U6IGxvY2FsTmFtZVxuICAgICAgICAgIH07XG4gICAgICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChqc29uSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25JdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIFwibWFwXCIgaXMgaW52YWxpZCBmb3IgcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5ULmZyb21Kc29uKGpzb25JdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvbkl0ZW0sIGZpZWxkLkwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25JdGVtKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2godmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkgfHwgdHlwZW9mIGpzb25WYWx1ZSAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdCh0aGlzLmRlYnVnKGpzb25WYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQuZnJvbUpzb24oanNvbk1hcFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSByZWFkRW51bShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIoZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0TWFwW3JlYWRTY2FsYXIoZmllbGQuSywgZmllbGQuSyA9PSBTY2FsYXJUeXBlLkJPT0wgPyBqc29uTWFwS2V5ID09IFwidHJ1ZVwiID8gdHJ1ZSA6IGpzb25NYXBLZXkgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiBqc29uTWFwS2V5IDoganNvbk1hcEtleSwgTG9uZ1R5cGUuQklHSU5UKS50b1N0cmluZygpXSA9IHZhbDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIGtleSBmb3IgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KHRoaXMuZGVidWcoanNvblZhbHVlKSk7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBudWxsIGlzIGludmFsaWQgZm9yIG9uZW9mIGZpZWxkIFxcXCJcIikuY29uY2F0KGpzb25LZXksIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRbbG9jYWxOYW1lXSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKTtcbiAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBlbnVtVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkU2NhbGFyKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQodGhpcy5kZWJ1Zyhqc29uVmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgbGV0IGZpZWxkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgIGxldCBqc29uVmFsdWU7XG4gICAgICAgICAgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgY29uc3Qgb25lb2YgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG9uZW9mLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZCA9IG1lbWJlci5maW5kRmllbGQob25lb2YuY2FzZSk7XG4gICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAgIHRocm93IFwib25lb2YgY2FzZSBub3QgZm91bmQ6IFwiICsgb25lb2YuY2FzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZmllbGQsIG9uZW9mLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmllbGQgPSBtZW1iZXI7XG4gICAgICAgICAgICBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBmaWVsZCA/IFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBKU09OXCIpIDogXCJjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIHRvIEpTT05cIik7XG4gICAgICAgIGNvbnN0IHIgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IFwiOiBcIi5jb25jYXQocikgOiBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIHJlYWRTY2FsYXIsXG4gICAgd3JpdGVTY2FsYXIsXG4gICAgZGVidWc6IGRlYnVnSnNvblZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBkZWJ1Z0pzb25WYWx1ZShqc29uKSB7XG4gIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShqc29uKSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIGpzb24ubGVuZ3RoID4gMTAwID8gXCJzdHJpbmdcIiA6IFwiXFxcIlwiLmNvbmNhdChqc29uLnNwbGl0KCdcIicpLmpvaW4oJ1xcXFxcIicpLCBcIlxcXCJcIik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XG4gIH1cbn1cbi8vIE1heSB0aHJvdyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIG1lc3NhZ2UgaXMgbm9uLWJsYW5rLCBpdCBzaG91bGQgYmUgc2hvd24uXG4vLyBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIHByb3ZpZGUgY29udGV4dC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgLy8gZXZlcnkgdmFsaWQgY2FzZSBpbiB0aGUgc3dpdGNoIGJlbG93IHJldHVybnMsIGFuZCBldmVyeSBmYWxsXG4gIC8vIHRocm91Z2ggaXMgcmVnYXJkZWQgYXMgYSBmYWlsdXJlLlxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gMC4wO1xuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXh0cmEgd2hpdGVzcGFjZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xuICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuRkxPQVQpIGFzc2VydEZsb2F0MzIoZmxvYXQpO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gMDtcbiAgICAgIGxldCBpbnQzMjtcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcIm51bWJlclwiKSBpbnQzMiA9IGpzb247ZWxzZSBpZiAodHlwZW9mIGpzb24gPT0gXCJzdHJpbmdcIiAmJiBqc29uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xuICAgICAgfVxuICAgICAgaWYgKGludDMyID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICByZXR1cm4gaW50MzI7XG4gICAgLy8gaW50NjQsIGZpeGVkNjQsIHVpbnQ2NDogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICBjb25zdCBsb25nID0gcHJvdG9JbnQ2NC5wYXJzZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBsb25nVHlwZSA/IGxvbmcudG9TdHJpbmcoKSA6IGxvbmc7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gcHJvdG9JbnQ2NC56ZXJvO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICBjb25zdCB1TG9uZyA9IHByb3RvSW50NjQudVBhcnNlKGpzb24pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xuICAgIC8vIGJvb2w6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICBpZiAoanNvbiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIikgYnJlYWs7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGlmIChqc29uID09PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEEgc3RyaW5nIG11c3QgYWx3YXlzIGNvbnRhaW4gVVRGLTggZW5jb2RlZCBvciA3LWJpdCBBU0NJSS5cbiAgICAgIC8vIFdlIHZhbGlkYXRlIHdpdGggZW5jb2RlVVJJQ29tcG9uZW50LCB3aGljaCBhcHBlYXJzIHRvIGJlIHRoZSBmYXN0ZXN0IHdpZGVseSBhdmFpbGFibGUgb3B0aW9uLlxuICAgICAgdHJ5IHtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGlmIChqc29uID09PSBudWxsIHx8IGpzb24gPT09IFwiXCIpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZGVjKGpzb24pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcykge1xuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgaWYgKHZhbHVlIHx8IGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5ubztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XG59XG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVtaXRJbnRyaW5zaWNEZWZhdWx0LCBlbnVtQXNJbnRlZ2VyKSB7XG4gIHZhciBfYTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSAwICYmICFlbWl0SW50cmluc2ljRGVmYXVsdCkge1xuICAgIC8vIHByb3RvMyByZXF1aXJlcyAwIHRvIGJlIGRlZmF1bHQgdmFsdWUgZm9yIGFsbCBlbnVtc1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGVudW1Bc0ludGVnZXIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB2YWwgPSB0eXBlLmZpbmROdW1iZXIodmFsdWUpO1xuICByZXR1cm4gKF9hID0gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlOyAvLyBpZiB3ZSBkb24ndCBrbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSwgZW1pdEludHJpbnNpY0RlZmF1bHQpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gMCB8fCBlbWl0SW50cmluc2ljRGVmYXVsdCA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSByZXR1cm4gXCJOYU5cIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8IGVtaXRJbnRyaW5zaWNEZWZhdWx0ID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgLy8gc3RyaW5nOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAvLyBib29sOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIik7XG4gICAgICByZXR1cm4gdmFsdWUgfHwgZW1pdEludHJpbnNpY0RlZmF1bHQgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgLy8gV2UgdXNlIGltcGxpY2l0IGNvbnZlcnNpb24gd2l0aCBgdmFsdWUgIT0gMGAgdG8gY2F0Y2ggYm90aCAwbiBhbmQgXCIwXCJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiBlbWl0SW50cmluc2ljRGVmYXVsdCB8fCB2YWx1ZSAhPSAwID8gdmFsdWUudG9TdHJpbmcoMTApIDogdW5kZWZpbmVkO1xuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICByZXR1cm4gZW1pdEludHJpbnNpY0RlZmF1bHQgfHwgdmFsdWUuYnl0ZUxlbmd0aCA+IDAgPyBwcm90b0Jhc2U2NC5lbmModmFsdWUpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50ICovXG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdFByb3RvMygpIHtcbiAgcmV0dXJuIG1ha2VKc29uRm9ybWF0Q29tbW9uKCh3cml0ZUVudW0sIHdyaXRlU2NhbGFyKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgIGNvbnN0IGpzb25PYmogPSB7fTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHdyaXRlU2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGNvbnN0IGVudW1UeXBlID0gZmllbGQuVi5UO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICBhc3NlcnQoZW50cnlWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbnRyeVZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSB3cml0ZUVudW0oZW51bVR5cGUsIGVudHJ5VmFsdWUsIHRydWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgICAgICAgIGFzc2VydCh2YWwgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIGpzb25PYmpbZW50cnlLZXkudG9TdHJpbmcoKV0gPSB2YWw7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IE9iamVjdC5rZXlzKGpzb25PYmopLmxlbmd0aCA+IDAgPyBqc29uT2JqIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBqc29uQXJyLnB1c2god3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlW2ldLCB0cnVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cmFwRmllbGQoZmllbGQuVCwgdmFsdWVbaV0pLnRvSnNvbihvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlLCAhIWZpZWxkLm9uZW9mIHx8IGZpZWxkLm9wdCB8fCBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgISFmaWVsZC5vbmVvZiB8fCBmaWVsZC5vcHQgfHwgb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcywgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpLnRvSnNvbihvcHRpb25zKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VVdGlsQ29tbW9uKCkge1xuICByZXR1cm4ge1xuICAgIHNldEVudW1UeXBlLFxuICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHRhcmdldC5nZXRUeXBlKCk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsXG4gICAgICAgICAgdCA9IHRhcmdldCxcbiAgICAgICAgICBzID0gc291cmNlO1xuICAgICAgICBpZiAoc1tsb2NhbE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xuICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09IFwibWVzc2FnZVwiICYmICEodmFsIGluc3RhbmNlb2Ygc291cmNlRmllbGQuVCkpIHtcbiAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PT0gXCJzY2FsYXJcIiAmJiBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHtcbiAgICAgICAgICAgICAgY2FzZTogc2ssXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgIGNvcHkgPSBtZW1iZXIucmVwZWF0ZWQgPyBjb3B5Lm1hcCh0b1U4QXJyKSA6IHRvVThBcnIoY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc1tsb2NhbE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB0YWtlIHBhcnRpYWwgaW5wdXQgZm9yIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhIHdyYXBwZXIgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBzW2xvY2FsTmFtZV0ubWFwKHZhbCA9PiB2YWwgaW5zdGFuY2VvZiBtdCA/IHZhbCA6IG5ldyBtdCh2YWwpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc1tsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAobXQuZmllbGRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICBtdC50eXBlTmFtZSA9PT0gXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB0b1U4QXJyKHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsIGluc3RhbmNlb2YgbXQgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeShtID0+IHtcbiAgICAgICAgY29uc3QgdmEgPSBhW20ubG9jYWxOYW1lXTtcbiAgICAgICAgY29uc3QgdmIgPSBiW20ubG9jYWxOYW1lXTtcbiAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhtLlQsIGEsIHZiW2ldKSk7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCBhLCB2YltpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBlYXRlZCBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQobS5raW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHModmEsIHZiKTtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMobS5ULCB2YSwgdmIpO1xuICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcyA9IG0uZmluZEZpZWxkKHZhLmNhc2UpO1xuICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgICAgc3dpdGNoIChzLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5ULmVxdWFscyh2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMocy5ULCB2YS52YWx1ZSwgdmIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25lb2YgY2Fubm90IGNvbnRhaW4gXCIuY29uY2F0KHMua2luZCkpO1xuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSxcbiAgICAgICAgdGFyZ2V0ID0gbmV3IHR5cGUoKSxcbiAgICAgICAgYW55ID0gdGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKGNsb25lU2luZ3VsYXJGaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZVNpbmd1bGFyRmllbGQodik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgIGNvbnN0IGYgPSBtZW1iZXIuZmluZEZpZWxkKHNvdXJjZS5jYXNlKTtcbiAgICAgICAgICBjb3B5ID0gZiA/IHtcbiAgICAgICAgICAgIGNhc2U6IHNvdXJjZS5jYXNlLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UudmFsdWUpXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgIGMuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gYztcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vLyBjb252ZXJ0cyBhbnkgQXJyYXlMaWtlPG51bWJlcj4gdG8gVWludDhBcnJheSBpZiBuZWNlc3NhcnkuXG5mdW5jdGlvbiB0b1U4QXJyKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dCA6IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyMyBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBub3JtYWxpemVyKSB7XG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICB9XG4gIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xuICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgfVxuICBmaW5kKGZpZWxkTm8pIHtcbiAgICBpZiAoIXRoaXMubnVtYmVycykge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIHRbZi5ub10gPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5udW1iZXJzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgfVxuICBsaXN0KCkge1xuICAgIGlmICghdGhpcy5hbGwpIHtcbiAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGw7XG4gIH1cbiAgYnlOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcbiAgfVxuICBieU1lbWJlcigpIHtcbiAgICBpZiAoIXRoaXMubWVtYmVycykge1xuICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICBjb25zdCBhID0gdGhpcy5tZW1iZXJzO1xuICAgICAgbGV0IG87XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xuICAgICAgICAgICAgbyA9IGYub25lb2Y7XG4gICAgICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEZpZWxkIG5hbWVzIC0gaW5jbHVkaW5nIG9uZW9mcyAtIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJDYW1lbENhc2UuIEZvclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxuICogd2l0aCBhbiB1bmRlcnNjb3JlLiBGb3IgbWV0aG9kcywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtYWRlIGxvd2VyY2FzZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgaW5PbmVvZikge1xuICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgaWYgKGluT25lb2YpIHtcbiAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgcmV0dXJuIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIG5hbWUgZm9yIGEgcHJvdG9idWYgZmllbGQsIGV4YWN0bHkgbGlrZSBwcm90b2MgZG9lcy5cbiAqL1xuY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICBjb25zdCBiID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjpcbiAgICAgIGNhc2UgXCIxXCI6XG4gICAgICBjYXNlIFwiMlwiOlxuICAgICAgY2FzZSBcIjNcIjpcbiAgICAgIGNhc2UgXCI0XCI6XG4gICAgICBjYXNlIFwiNVwiOlxuICAgICAgY2FzZSBcIjZcIjpcbiAgICAgIGNhc2UgXCI3XCI6XG4gICAgICBjYXNlIFwiOFwiOlxuICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgYyA9IGMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkT2JqZWN0UHJvcGVydGllcyA9IG5ldyBTZXQoW1xuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxuXCJjb25zdHJ1Y3RvclwiLCBcInRvU3RyaW5nXCIsIFwidG9KU09OXCIsIFwidmFsdWVPZlwiXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZVxuXCJnZXRUeXBlXCIsIFwiY2xvbmVcIiwgXCJlcXVhbHNcIiwgXCJmcm9tQmluYXJ5XCIsIFwiZnJvbUpzb25cIiwgXCJmcm9tSnNvblN0cmluZ1wiLCBcInRvQmluYXJ5XCIsIFwidG9Kc29uXCIsIFwidG9Kc29uU3RyaW5nXCIsXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZSBmb3IgdGhlIGZ1dHVyZVxuXCJ0b09iamVjdFwiXSk7XG5jb25zdCBmYWxsYmFjayA9IG5hbWUgPT4gXCJcIi5jb25jYXQobmFtZSwgXCIkXCIpO1xuLyoqXG4gKiBXaWxsIHdyYXAgbmFtZXMgdGhhdCBhcmUgT2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9yIG5hbWVzIHJlc2VydmVkXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cbiAqL1xuY29uc3Qgc2FmZU1lc3NhZ2VQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jbGFzcyBJbnRlcm5hbE9uZW9mSW5mbyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLmtpbmQgPSBcIm9uZW9mXCI7XG4gICAgdGhpcy5yZXBlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgdGhpcy5vcHQgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XG4gIH1cbiAgYWRkRmllbGQoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9sb29rdXApIHtcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2xvb2t1cFt0aGlzLmZpZWxkc1tpXS5sb2NhbE5hbWVdID0gdGhpcy5maWVsZHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDIzIEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBtZXNzYWdlcyBkZWZpbmVkIHdpdGggdGhlIHByb3RvMyBzeW50YXguXG4gKi9cbmNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgbWFrZUpzb25Gb3JtYXRQcm90bzMoKSwgbWFrZUJpbmFyeUZvcm1hdFByb3RvMygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7XG4gIG5ld0ZpZWxkTGlzdChmaWVsZHMpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsRmllbGRMaXN0KGZpZWxkcywgbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyk7XG4gIH0sXG4gIGluaXRGaWVsZHModGFyZ2V0KSB7XG4gICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGFyZ2V0LmdldFR5cGUoKS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgaWYgKG1lbWJlci5vcHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcbiAgICAgICAgdCA9IHRhcmdldDtcbiAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgdFtuYW1lXSA9IHtcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgdFtuYW1lXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICB0W25hbWVdID0ge307XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICB0W25hbWVdID0gc2NhbGFyRGVmYXVsdFZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59KSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvc1Byb3RvMyhmaWVsZEluZm9zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgbztcbiAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZEluZm9zKCkgOiBmaWVsZEluZm9zKSB7XG4gICAgY29uc3QgZiA9IGZpZWxkO1xuICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xuICAgIH1cbiAgICAvLyBGcm9tIHRoZSBwcm90bzMgbGFuZ3VhZ2UgZ3VpZGU6XG4gICAgLy8gPiBJbiBwcm90bzMsIHJlcGVhdGVkIGZpZWxkcyBvZiBzY2FsYXIgbnVtZXJpYyB0eXBlcyBhcmUgcGFja2VkIGJ5IGRlZmF1bHQuXG4gICAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyBpbmNvbXBsZXRlIC0gYWNjb3JkaW5nIHRvIHRoZSBjb25mb3JtYW5jZSB0ZXN0cywgQk9PTFxuICAgIC8vIGFuZCBFTlVNIGFyZSBwYWNrZWQgYnkgZGVmYXVsdCBhcyB3ZWxsLiBUaGlzIG1lYW5zIG9ubHkgU1RSSU5HIGFuZCBCWVRFU1xuICAgIC8vIGFyZSBub3QgcGFja2VkIGJ5IGRlZmF1bHQsIHdoaWNoIG1ha2VzIHNlbnNlIGJlY2F1c2UgdGhleSBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICBmLnBhY2tlZCA9IChfZCA9IGZpZWxkLnBhY2tlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmllbGQua2luZCA9PSBcImVudW1cIiB8fCBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkc7XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xuICAgICAgfVxuICAgICAgZi5vbmVvZiA9IG87XG4gICAgICBvLmFkZEZpZWxkKGYpO1xuICAgIH1cbiAgICByLnB1c2goZik7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjMgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcbiAqIGNhbGVuZGFyLCBlbmNvZGVkIGFzIGEgY291bnQgb2Ygc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXRcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxuICogR3JlZ29yaWFuIGNhbGVuZGFyIGJhY2t3YXJkcyB0byB5ZWFyIG9uZS5cbiAqXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxuICogc2Vjb25kIHRhYmxlIGlzIG5lZWRlZCBmb3IgaW50ZXJwcmV0YXRpb24sIHVzaW5nIGEgWzI0LWhvdXIgbGluZWFyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXG4gKlxuICogVGhlIHJhbmdlIGlzIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OS45OTk5OTk5OTlaLiBCeVxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXG4gKlxuICogIyBFeGFtcGxlc1xuICpcbiAqIEV4YW1wbGUgMTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgdGltZSgpYC5cbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModGltZShOVUxMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcbiAqXG4gKiBFeGFtcGxlIDI6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYGdldHRpbWVvZmRheSgpYC5cbiAqXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XG4gKiAgICAgZ2V0dGltZW9mZGF5KCZ0diwgTlVMTCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHR2LnR2X3NlYyk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XG4gKlxuICogRXhhbXBsZSAzOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFdpbjMyIGBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgpYC5cbiAqXG4gKiAgICAgRklMRVRJTUUgZnQ7XG4gKiAgICAgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoJmZ0KTtcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XG4gKlxuICogICAgIC8vIEEgV2luZG93cyB0aWNrIGlzIDEwMCBuYW5vc2Vjb25kcy4gV2luZG93cyBlcG9jaCAxNjAxLTAxLTAxVDAwOjAwOjAwWlxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHMoKElOVDY0KSAoKHRpY2tzIC8gMTAwMDAwMDApIC0gMTE2NDQ0NzM2MDBMTCkpO1xuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XG4gKlxuICogRXhhbXBsZSA0OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpYC5cbiAqXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xuICpcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cbiAqXG4gKiAgICAgSW5zdGFudCBub3cgPSBJbnN0YW50Lm5vdygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cbiAqICAgICAgICAgVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG5vdy5nZXRFcG9jaFNlY29uZCgpKVxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA2OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIGN1cnJlbnQgdGltZSBpbiBQeXRob24uXG4gKlxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXG4gKiAgICAgdGltZXN0YW1wLkdldEN1cnJlbnRUaW1lKClcbiAqXG4gKiAjIEpTT04gTWFwcGluZ1xuICpcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxuICogZm9ybWF0IGlzIFwie3llYXJ9LXttb250aH0te2RheX1Ue2hvdXJ9OnttaW59OntzZWN9Wy57ZnJhY19zZWN9XVpcIlxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcbiAqIHNlY29uZHMsIHdoaWNoIGNhbiBnbyB1cCB0byA5IGRpZ2l0cyAoaS5lLiB1cCB0byAxIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiksXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxuICogXCJaXCIpIHdoZW4gcHJpbnRpbmcgdGhlIFRpbWVzdGFtcCB0eXBlIGFuZCBhIHByb3RvMyBKU09OIHBhcnNlciBzaG91bGQgYmVcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxuICpcbiAqIEZvciBleGFtcGxlLCBcIjIwMTctMDEtMTVUMDE6MzA6MTUuMDFaXCIgZW5jb2RlcyAxNS4wMSBzZWNvbmRzIHBhc3RcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxuICpcbiAqIEluIEphdmFTY3JpcHQsIG9uZSBjYW4gY29udmVydCBhIERhdGUgb2JqZWN0IHRvIHRoaXMgZm9ybWF0IHVzaW5nIHRoZVxuICogc3RhbmRhcmRcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxuICogbWV0aG9kLiBJbiBQeXRob24sIGEgc3RhbmRhcmQgYGRhdGV0aW1lLmRhdGV0aW1lYCBvYmplY3QgY2FuIGJlIGNvbnZlcnRlZFxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcbiAqIHRoZSB0aW1lIGZvcm1hdCBzcGVjICclWS0lbS0lZFQlSDolTTolUy4lZlonLiBMaWtld2lzZSwgaW4gSmF2YSwgb25lIGNhbiB1c2VcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXG4gKiApIHRvIG9idGFpbiBhIGZvcm1hdHRlciBjYXBhYmxlIG9mIGdlbmVyYXRpbmcgdGltZXN0YW1wcyBpbiB0aGlzIGZvcm1hdC5cbiAqXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFxuICovXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBzZWNvbmRzIG9mIFVUQyB0aW1lIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXG4gICAgICogc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmUgbm9uLW5lZ2F0aXZlIG5hbm9zIHZhbHVlc1xuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAqIGluY2x1c2l2ZS5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIGZyb21Kc29uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XG4gICAgfVxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQucGFyc2UobXMgLyAxMDAwKTtcbiAgICB0aGlzLm5hbm9zID0gMDtcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgdGhpcy5uYW5vcyA9IHBhcnNlSW50KFwiMVwiICsgbWF0Y2hlc1s3XSArIFwiMFwiLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtIDEwMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvSnNvbihvcHRpb25zKSB7XG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgaWYgKG1zIDwgRGF0ZS5wYXJzZShcIjAwMDEtMDEtMDFUMDA6MDA6MDBaXCIpIHx8IG1zID4gRGF0ZS5wYXJzZShcIjk5OTktMTItMzFUMjM6NTk6NTlaXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmFub3MgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIGxldCB6ID0gXCJaXCI7XG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAobmFub3NTdHIuc3Vic3RyaW5nKDMpID09PSBcIjAwMDAwMFwiKSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDYpICsgXCJaXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICB9XG4gIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XG4gIH1cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7XG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRpbWVzdGFtcCwgYSwgYik7XG4gIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNlY29uZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG4vLyBDb3B5cmlnaHQgMjAyMyBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkF1ZGlvQ29kZWNcbiAqL1xudmFyIEF1ZGlvQ29kZWM7XG4oZnVuY3Rpb24gKEF1ZGlvQ29kZWMpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBERUZBVUxUX0FDID0gMDtcbiAgICovXG4gIEF1ZGlvQ29kZWNbQXVkaW9Db2RlY1tcIkRFRkFVTFRfQUNcIl0gPSAwXSA9IFwiREVGQVVMVF9BQ1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IE9QVVMgPSAxO1xuICAgKi9cbiAgQXVkaW9Db2RlY1tBdWRpb0NvZGVjW1wiT1BVU1wiXSA9IDFdID0gXCJPUFVTXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQUFDID0gMjtcbiAgICovXG4gIEF1ZGlvQ29kZWNbQXVkaW9Db2RlY1tcIkFBQ1wiXSA9IDJdID0gXCJBQUNcIjtcbn0pKEF1ZGlvQ29kZWMgfHwgKEF1ZGlvQ29kZWMgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9Db2RlYylcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEF1ZGlvQ29kZWMsIFwibGl2ZWtpdC5BdWRpb0NvZGVjXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRFRkFVTFRfQUNcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJPUFVTXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQUFDXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5WaWRlb0NvZGVjXG4gKi9cbnZhciBWaWRlb0NvZGVjO1xuKGZ1bmN0aW9uIChWaWRlb0NvZGVjKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogREVGQVVMVF9WQyA9IDA7XG4gICAqL1xuICBWaWRlb0NvZGVjW1ZpZGVvQ29kZWNbXCJERUZBVUxUX1ZDXCJdID0gMF0gPSBcIkRFRkFVTFRfVkNcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBIMjY0X0JBU0VMSU5FID0gMTtcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkgyNjRfQkFTRUxJTkVcIl0gPSAxXSA9IFwiSDI2NF9CQVNFTElORVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEgyNjRfTUFJTiA9IDI7XG4gICAqL1xuICBWaWRlb0NvZGVjW1ZpZGVvQ29kZWNbXCJIMjY0X01BSU5cIl0gPSAyXSA9IFwiSDI2NF9NQUlOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSDI2NF9ISUdIID0gMztcbiAgICovXG4gIFZpZGVvQ29kZWNbVmlkZW9Db2RlY1tcIkgyNjRfSElHSFwiXSA9IDNdID0gXCJIMjY0X0hJR0hcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBWUDggPSA0O1xuICAgKi9cbiAgVmlkZW9Db2RlY1tWaWRlb0NvZGVjW1wiVlA4XCJdID0gNF0gPSBcIlZQOFwiO1xufSkoVmlkZW9Db2RlYyB8fCAoVmlkZW9Db2RlYyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb0NvZGVjKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVmlkZW9Db2RlYywgXCJsaXZla2l0LlZpZGVvQ29kZWNcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiREVGQVVMVF9WQ1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkgyNjRfQkFTRUxJTkVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJIMjY0X01BSU5cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJIMjY0X0hJR0hcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJWUDhcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkltYWdlQ29kZWNcbiAqL1xudmFyIEltYWdlQ29kZWM7XG4oZnVuY3Rpb24gKEltYWdlQ29kZWMpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBJQ19ERUZBVUxUID0gMDtcbiAgICovXG4gIEltYWdlQ29kZWNbSW1hZ2VDb2RlY1tcIklDX0RFRkFVTFRcIl0gPSAwXSA9IFwiSUNfREVGQVVMVFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IElDX0pQRUcgPSAxO1xuICAgKi9cbiAgSW1hZ2VDb2RlY1tJbWFnZUNvZGVjW1wiSUNfSlBFR1wiXSA9IDFdID0gXCJJQ19KUEVHXCI7XG59KShJbWFnZUNvZGVjIHx8IChJbWFnZUNvZGVjID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEltYWdlQ29kZWMpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShJbWFnZUNvZGVjLCBcImxpdmVraXQuSW1hZ2VDb2RlY1wiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJJQ19ERUZBVUxUXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSUNfSlBFR1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVHJhY2tUeXBlXG4gKi9cbnZhciBUcmFja1R5cGU7XG4oZnVuY3Rpb24gKFRyYWNrVHlwZSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFVRElPID0gMDtcbiAgICovXG4gIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJBVURJT1wiXSA9IDBdID0gXCJBVURJT1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFZJREVPID0gMTtcbiAgICovXG4gIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJWSURFT1wiXSA9IDFdID0gXCJWSURFT1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IERBVEEgPSAyO1xuICAgKi9cbiAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIkRBVEFcIl0gPSAyXSA9IFwiREFUQVwiO1xufSkoVHJhY2tUeXBlIHx8IChUcmFja1R5cGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoVHJhY2tUeXBlLCBcImxpdmVraXQuVHJhY2tUeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFVRElPXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVklERU9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEQVRBXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5UcmFja1NvdXJjZVxuICovXG52YXIgVHJhY2tTb3VyY2U7XG4oZnVuY3Rpb24gKFRyYWNrU291cmNlKSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVU5LTk9XTiA9IDA7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENBTUVSQSA9IDE7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIkNBTUVSQVwiXSA9IDFdID0gXCJDQU1FUkFcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNSUNST1BIT05FID0gMjtcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiTUlDUk9QSE9ORVwiXSA9IDJdID0gXCJNSUNST1BIT05FXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0NSRUVOX1NIQVJFID0gMztcbiAgICovXG4gIFRyYWNrU291cmNlW1RyYWNrU291cmNlW1wiU0NSRUVOX1NIQVJFXCJdID0gM10gPSBcIlNDUkVFTl9TSEFSRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNDUkVFTl9TSEFSRV9BVURJTyA9IDQ7XG4gICAqL1xuICBUcmFja1NvdXJjZVtUcmFja1NvdXJjZVtcIlNDUkVFTl9TSEFSRV9BVURJT1wiXSA9IDRdID0gXCJTQ1JFRU5fU0hBUkVfQVVESU9cIjtcbn0pKFRyYWNrU291cmNlIHx8IChUcmFja1NvdXJjZSA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFRyYWNrU291cmNlLCBcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNBTUVSQVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk1JQ1JPUEhPTkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlZpZGVvUXVhbGl0eVxuICovXG52YXIgVmlkZW9RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1cgPSAwO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkxPV1wiXSA9IDBdID0gXCJMT1dcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBNRURJVU0gPSAxO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1FRElVTVwiXSA9IDFdID0gXCJNRURJVU1cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBISUdIID0gMjtcbiAgICovXG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJISUdIXCJdID0gMl0gPSBcIkhJR0hcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBPRkYgPSAzO1xuICAgKi9cbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk9GRlwiXSA9IDNdID0gXCJPRkZcIjtcbn0pKFZpZGVvUXVhbGl0eSB8fCAoVmlkZW9RdWFsaXR5ID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFZpZGVvUXVhbGl0eSwgXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJMT1dcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJNRURJVU1cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJISUdIXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiT0ZGXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVxuICovXG52YXIgQ29ubmVjdGlvblF1YWxpdHkkMTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQT09SID0gMDtcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiUE9PUlwiXSA9IDBdID0gXCJQT09SXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogR09PRCA9IDE7XG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkdPT0RcIl0gPSAxXSA9IFwiR09PRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEVYQ0VMTEVOVCA9IDI7XG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIkVYQ0VMTEVOVFwiXSA9IDJdID0gXCJFWENFTExFTlRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1NUID0gMztcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W0Nvbm5lY3Rpb25RdWFsaXR5W1wiTE9TVFwiXSA9IDNdID0gXCJMT1NUXCI7XG59KShDb25uZWN0aW9uUXVhbGl0eSQxIHx8IChDb25uZWN0aW9uUXVhbGl0eSQxID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5KVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkkMSwgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBPT1JcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJHT09EXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiRVhDRUxMRU5UXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTE9TVFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZ1xuICovXG52YXIgQ2xpZW50Q29uZmlnU2V0dGluZztcbihmdW5jdGlvbiAoQ2xpZW50Q29uZmlnU2V0dGluZykge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVOU0VUID0gMDtcbiAgICovXG4gIENsaWVudENvbmZpZ1NldHRpbmdbQ2xpZW50Q29uZmlnU2V0dGluZ1tcIlVOU0VUXCJdID0gMF0gPSBcIlVOU0VUXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRElTQUJMRUQgPSAxO1xuICAgKi9cbiAgQ2xpZW50Q29uZmlnU2V0dGluZ1tDbGllbnRDb25maWdTZXR0aW5nW1wiRElTQUJMRURcIl0gPSAxXSA9IFwiRElTQUJMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBFTkFCTEVEID0gMjtcbiAgICovXG4gIENsaWVudENvbmZpZ1NldHRpbmdbQ2xpZW50Q29uZmlnU2V0dGluZ1tcIkVOQUJMRURcIl0gPSAyXSA9IFwiRU5BQkxFRFwiO1xufSkoQ2xpZW50Q29uZmlnU2V0dGluZyB8fCAoQ2xpZW50Q29uZmlnU2V0dGluZyA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZywgXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5TRVRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJESVNBQkxFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVOQUJMRURcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cbiAqL1xudmFyIERpc2Nvbm5lY3RSZWFzb247XG4oZnVuY3Rpb24gKERpc2Nvbm5lY3RSZWFzb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOX1JFQVNPTiA9IDA7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJVTktOT1dOX1JFQVNPTlwiXSA9IDBdID0gXCJVTktOT1dOX1JFQVNPTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IENMSUVOVF9JTklUSUFURUQgPSAxO1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiQ0xJRU5UX0lOSVRJQVRFRFwiXSA9IDFdID0gXCJDTElFTlRfSU5JVElBVEVEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRFVQTElDQVRFX0lERU5USVRZID0gMjtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIkRVUExJQ0FURV9JREVOVElUWVwiXSA9IDJdID0gXCJEVVBMSUNBVEVfSURFTlRJVFlcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRVJWRVJfU0hVVERPV04gPSAzO1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiU0VSVkVSX1NIVVRET1dOXCJdID0gM10gPSBcIlNFUlZFUl9TSFVURE9XTlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFBBUlRJQ0lQQU5UX1JFTU9WRUQgPSA0O1xuICAgKi9cbiAgRGlzY29ubmVjdFJlYXNvbltEaXNjb25uZWN0UmVhc29uW1wiUEFSVElDSVBBTlRfUkVNT1ZFRFwiXSA9IDRdID0gXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUk9PTV9ERUxFVEVEID0gNTtcbiAgICovXG4gIERpc2Nvbm5lY3RSZWFzb25bRGlzY29ubmVjdFJlYXNvbltcIlJPT01fREVMRVRFRFwiXSA9IDVdID0gXCJST09NX0RFTEVURURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTVEFURV9NSVNNQVRDSCA9IDY7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJTVEFURV9NSVNNQVRDSFwiXSA9IDZdID0gXCJTVEFURV9NSVNNQVRDSFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEpPSU5fRkFJTFVSRSA9IDc7XG4gICAqL1xuICBEaXNjb25uZWN0UmVhc29uW0Rpc2Nvbm5lY3RSZWFzb25bXCJKT0lOX0ZBSUxVUkVcIl0gPSA3XSA9IFwiSk9JTl9GQUlMVVJFXCI7XG59KShEaXNjb25uZWN0UmVhc29uIHx8IChEaXNjb25uZWN0UmVhc29uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uLCBcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlJlY29ubmVjdFJlYXNvblxuICovXG52YXIgUmVjb25uZWN0UmVhc29uO1xuKGZ1bmN0aW9uIChSZWNvbm5lY3RSZWFzb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9VTktOT1dOID0gMDtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9VTktOT1dOXCJdID0gMF0gPSBcIlJSX1VOS05PV05cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TSUdOQUxfRElTQ09OTkVDVEVEID0gMTtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIlJSX1NJR05BTF9ESVNDT05ORUNURURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9QVUJMSVNIRVJfRkFJTEVEID0gMjtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCJdID0gMl0gPSBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TVUJTQ1JJQkVSX0ZBSUxFRCA9IDM7XG4gICAqL1xuICBSZWNvbm5lY3RSZWFzb25bUmVjb25uZWN0UmVhc29uW1wiUlJfU1VCU0NSSUJFUl9GQUlMRURcIl0gPSAzXSA9IFwiUlJfU1VCU0NSSUJFUl9GQUlMRURcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSUl9TV0lUQ0hfQ0FORElEQVRFID0gNDtcbiAgICovXG4gIFJlY29ubmVjdFJlYXNvbltSZWNvbm5lY3RSZWFzb25bXCJSUl9TV0lUQ0hfQ0FORElEQVRFXCJdID0gNF0gPSBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIjtcbn0pKFJlY29ubmVjdFJlYXNvbiB8fCAoUmVjb25uZWN0UmVhc29uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFJlY29ubmVjdFJlYXNvbiwgXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSUl9VTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlJSX1BVQkxJU0hFUl9GQUlMRURcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXG4gKi9cbnZhciBTdWJzY3JpcHRpb25FcnJvcjtcbihmdW5jdGlvbiAoU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTRV9VTktOT1dOID0gMDtcbiAgICovXG4gIFN1YnNjcmlwdGlvbkVycm9yW1N1YnNjcmlwdGlvbkVycm9yW1wiU0VfVU5LTk9XTlwiXSA9IDBdID0gXCJTRV9VTktOT1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU0VfQ09ERUNfVU5TVVBQT1JURUQgPSAxO1xuICAgKi9cbiAgU3Vic2NyaXB0aW9uRXJyb3JbU3Vic2NyaXB0aW9uRXJyb3JbXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiXSA9IDFdID0gXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNFX1RSQUNLX05PVEZPVU5EID0gMjtcbiAgICovXG4gIFN1YnNjcmlwdGlvbkVycm9yW1N1YnNjcmlwdGlvbkVycm9yW1wiU0VfVFJBQ0tfTk9URk9VTkRcIl0gPSAyXSA9IFwiU0VfVFJBQ0tfTk9URk9VTkRcIjtcbn0pKFN1YnNjcmlwdGlvbkVycm9yIHx8IChTdWJzY3JpcHRpb25FcnJvciA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvcilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yLCBcImxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU0VfVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU0VfVFJBQ0tfTk9URk9VTkRcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21cbiAqL1xubGV0IFJvb20kMSA9IGNsYXNzIFJvb20gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBlbXB0eV90aW1lb3V0ID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmVtcHR5VGltZW91dCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbWF4X3BhcnRpY2lwYW50cyA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5tYXhQYXJ0aWNpcGFudHMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgY3JlYXRpb25fdGltZSA9IDU7XG4gICAgICovXG4gICAgdGhpcy5jcmVhdGlvblRpbWUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHVybl9wYXNzd29yZCA9IDY7XG4gICAgICovXG4gICAgdGhpcy50dXJuUGFzc3dvcmQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBlbmFibGVkX2NvZGVjcyA9IDc7XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkQ29kZWNzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWV0YWRhdGEgPSA4O1xuICAgICAqL1xuICAgIHRoaXMubWV0YWRhdGEgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG51bV9wYXJ0aWNpcGFudHMgPSA5O1xuICAgICAqL1xuICAgIHRoaXMubnVtUGFydGljaXBhbnRzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBudW1fcHVibGlzaGVycyA9IDExO1xuICAgICAqL1xuICAgIHRoaXMubnVtUHVibGlzaGVycyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFjdGl2ZV9yZWNvcmRpbmcgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IGZhbHNlO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb20oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJvb20sIGEsIGIpO1xuICB9XG59O1xuUm9vbSQxLnJ1bnRpbWUgPSBwcm90bzM7XG5Sb29tJDEudHlwZU5hbWUgPSBcImxpdmVraXQuUm9vbVwiO1xuUm9vbSQxLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZW1wdHlfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInR1cm5fcGFzc3dvcmRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJlbmFibGVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwibnVtX3B1Ymxpc2hlcnNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImFjdGl2ZV9yZWNvcmRpbmdcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db2RlY1xuICovXG5jbGFzcyBDb2RlYyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtaW1lID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLm1pbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGZtdHBfbGluZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5mbXRwTGluZSA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvZGVjKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQ29kZWMsIGEsIGIpO1xuICB9XG59XG5Db2RlYy5ydW50aW1lID0gcHJvdG8zO1xuQ29kZWMudHlwZU5hbWUgPSBcImxpdmVraXQuQ29kZWNcIjtcbkNvZGVjLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZm10cF9saW5lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QbGF5b3V0RGVsYXlcbiAqL1xuY2xhc3MgUGxheW91dERlbGF5IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBlbmFibGVkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtaW4gPSAyO1xuICAgICAqL1xuICAgIHRoaXMubWluID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBtYXggPSAzO1xuICAgICAqL1xuICAgIHRoaXMubWF4ID0gMDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGxheW91dERlbGF5KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQbGF5b3V0RGVsYXksIGEsIGIpO1xuICB9XG59XG5QbGF5b3V0RGVsYXkucnVudGltZSA9IHByb3RvMztcblBsYXlvdXREZWxheS50eXBlTmFtZSA9IFwibGl2ZWtpdC5QbGF5b3V0RGVsYXlcIjtcblBsYXlvdXREZWxheS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZW5hYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibWF4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50UGVybWlzc2lvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBzdWJzY3JpYmUgdG8gb3RoZXIgdHJhY2tzIGluIHRoZSByb29tXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgY2FuX3N1YnNjcmliZSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jYW5TdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIG5ldyB0cmFja3MgdG8gcm9vbVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9wdWJsaXNoID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmNhblB1Ymxpc2ggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBhbGxvdyBwYXJ0aWNpcGFudCB0byBwdWJsaXNoIGRhdGFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fcHVibGlzaF9kYXRhID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmNhblB1Ymxpc2hEYXRhID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogc291cmNlcyB0aGF0IGFyZSBhbGxvd2VkIHRvIGJlIHB1Ymxpc2hlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlRyYWNrU291cmNlIGNhbl9wdWJsaXNoX3NvdXJjZXMgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuY2FuUHVibGlzaFNvdXJjZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCBpdCdzIGhpZGRlbiB0byBvdGhlcnNcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBoaWRkZW4gPSA3O1xuICAgICAqL1xuICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGl0J3MgYSByZWNvcmRlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHJlY29yZGVyID0gODtcbiAgICAgKi9cbiAgICB0aGlzLnJlY29yZGVyID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIHRoYXQgcGFydGljaXBhbnQgY2FuIHVwZGF0ZSBvd24gbWV0YWRhdGFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBjYW5fdXBkYXRlX21ldGFkYXRhID0gMTA7XG4gICAgICovXG4gICAgdGhpcy5jYW5VcGRhdGVNZXRhZGF0YSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyB0aGF0IHBhcnRpY2lwYW50IGlzIGFuIGFnZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgYWdlbnQgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLmFnZW50ID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50UGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRQZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRQZXJtaXNzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudFBlcm1pc3Npb24udHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXCI7XG5QYXJ0aWNpcGFudFBlcm1pc3Npb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hfZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9zb3VyY2VzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJoaWRkZW5cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicmVjb3JkZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcImNhbl91cGRhdGVfbWV0YWRhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcImFnZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRJbmZvXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50SW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBpZGVudGl0eSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5pZGVudGl0eSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZSBzdGF0ZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5KT0lOSU5HO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja0luZm8gdHJhY2tzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1ldGFkYXRhID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLm1ldGFkYXRhID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiB0aW1lc3RhbXAgd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgcm9vbSwgaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBqb2luZWRfYXQgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuam9pbmVkQXQgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDk7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB2ZXJzaW9uID0gMTA7XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIHRoZSBwYXJ0aWNpcGFudCBoYXMgYW4gYWN0aXZlIHB1Ymxpc2hlciBjb25uZWN0aW9uXG4gICAgICogYW5kIGNhbiBwdWJsaXNoIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBpc19wdWJsaXNoZXIgPSAxMztcbiAgICAgKi9cbiAgICB0aGlzLmlzUHVibGlzaGVyID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50SW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRJbmZvLCBhLCBiKTtcbiAgfVxufVxuUGFydGljaXBhbnRJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudEluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvXCI7XG5QYXJ0aWNpcGFudEluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImpvaW5lZF9hdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFBlcm1pc3Npb25cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJpc19wdWJsaXNoZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcbiAqL1xudmFyIFBhcnRpY2lwYW50SW5mb19TdGF0ZTtcbihmdW5jdGlvbiAoUGFydGljaXBhbnRJbmZvX1N0YXRlKSB7XG4gIC8qKlxuICAgKiB3ZWJzb2NrZXQnIGNvbm5lY3RlZCwgYnV0IG5vdCBvZmZlcmVkIHlldFxuICAgKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSk9JTklORyA9IDA7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiSk9JTklOR1wiXSA9IDBdID0gXCJKT0lOSU5HXCI7XG4gIC8qKlxuICAgKiBzZXJ2ZXIgcmVjZWl2ZWQgY2xpZW50IG9mZmVyXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBKT0lORUQgPSAxO1xuICAgKi9cbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkpPSU5FRFwiXSA9IDFdID0gXCJKT0lORURcIjtcbiAgLyoqXG4gICAqIElDRSBjb25uZWN0aXZpdHkgZXN0YWJsaXNoZWRcbiAgICpcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFDVElWRSA9IDI7XG4gICAqL1xuICBQYXJ0aWNpcGFudEluZm9fU3RhdGVbUGFydGljaXBhbnRJbmZvX1N0YXRlW1wiQUNUSVZFXCJdID0gMl0gPSBcIkFDVElWRVwiO1xuICAvKipcbiAgICogV1MgZGlzY29ubmVjdGVkXG4gICAqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBESVNDT05ORUNURUQgPSAzO1xuICAgKi9cbiAgUGFydGljaXBhbnRJbmZvX1N0YXRlW1BhcnRpY2lwYW50SW5mb19TdGF0ZVtcIkRJU0NPTk5FQ1RFRFwiXSA9IDNdID0gXCJESVNDT05ORUNURURcIjtcbn0pKFBhcnRpY2lwYW50SW5mb19TdGF0ZSB8fCAoUGFydGljaXBhbnRJbmZvX1N0YXRlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSwgXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJKT0lOSU5HXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSk9JTkVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQUNUSVZFXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiRElTQ09OTkVDVEVEXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5FbmNyeXB0aW9uXG4gKi9cbmNsYXNzIEVuY3J5cHRpb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb24oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBFbmNyeXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRW5jcnlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRW5jcnlwdGlvbiwgYSwgYik7XG4gIH1cbn1cbkVuY3J5cHRpb24ucnVudGltZSA9IHByb3RvMztcbkVuY3J5cHRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuRW5jcnlwdGlvblwiO1xuRW5jcnlwdGlvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW10pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkVuY3J5cHRpb24uVHlwZVxuICovXG52YXIgRW5jcnlwdGlvbl9UeXBlO1xuKGZ1bmN0aW9uIChFbmNyeXB0aW9uX1R5cGUpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBOT05FID0gMDtcbiAgICovXG4gIEVuY3J5cHRpb25fVHlwZVtFbmNyeXB0aW9uX1R5cGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBHQ00gPSAxO1xuICAgKi9cbiAgRW5jcnlwdGlvbl9UeXBlW0VuY3J5cHRpb25fVHlwZVtcIkdDTVwiXSA9IDFdID0gXCJHQ01cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDVVNUT00gPSAyO1xuICAgKi9cbiAgRW5jcnlwdGlvbl9UeXBlW0VuY3J5cHRpb25fVHlwZVtcIkNVU1RPTVwiXSA9IDJdID0gXCJDVVNUT01cIjtcbn0pKEVuY3J5cHRpb25fVHlwZSB8fCAoRW5jcnlwdGlvbl9UeXBlID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSwgXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJOT05FXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiR0NNXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQ1VTVE9NXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cbiAqL1xuY2xhc3MgU2ltdWxjYXN0Q29kZWNJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG1pbWVfdHlwZSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5taW1lVHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWlkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm1pZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlY0luZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpbXVsY2FzdENvZGVjSW5mbywgYSwgYik7XG4gIH1cbn1cblNpbXVsY2FzdENvZGVjSW5mby5ydW50aW1lID0gcHJvdG8zO1xuU2ltdWxjYXN0Q29kZWNJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiO1xuU2ltdWxjYXN0Q29kZWNJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tJbmZvXG4gKi9cbmNsYXNzIFRyYWNrSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVHJhY2tUeXBlIHR5cGUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IFRyYWNrVHlwZS5BVURJTztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMztcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5tdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHdpZHRoIG9mIHZpZGVvICh1bnNldCBmb3IgYXVkaW8pXG4gICAgICogY2xpZW50cyBtYXkgcmVjZWl2ZSBhIGxvd2VyIHJlc29sdXRpb24gdmVyc2lvbiB3aXRoIHNpbXVsY2FzdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSA1O1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIGhlaWdodCBvZiB2aWRlbyAodW5zZXQgZm9yIGF1ZGlvKVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0cmFjayBpcyBzaW11bGNhc3RlZFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHNpbXVsY2FzdCA9IDc7XG4gICAgICovXG4gICAgdGhpcy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIERUWCAoRGlzY29udGludW91cyBUcmFuc21pc3Npb24pIGlzIGRpc2FibGVkIGZvciBhdWRpb1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGRpc2FibGVfZHR4ID0gODtcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVEdHggPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBzb3VyY2Ugb2YgbWVkaWFcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1NvdXJjZSBzb3VyY2UgPSA5O1xuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIC8qKlxuICAgICAqIG1pbWUgdHlwZSBvZiBjb2RlY1xuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWltZV90eXBlID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5taW1lVHlwZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbWlkID0gMTI7XG4gICAgICovXG4gICAgdGhpcy5taWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm8gY29kZWNzID0gMTM7XG4gICAgICovXG4gICAgdGhpcy5jb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3RlcmVvID0gMTQ7XG4gICAgICovXG4gICAgdGhpcy5zdGVyZW8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIFJFRCAoUmVkdW5kYW50IEVuY29kaW5nKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX3JlZCA9IDE1O1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZVJlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGUgZW5jcnlwdGlvbiA9IDE2O1xuICAgICAqL1xuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHN0cmVhbSA9IDE3O1xuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja0luZm8sIGEsIGIpO1xuICB9XG59XG5UcmFja0luZm8ucnVudGltZSA9IHByb3RvMztcblRyYWNrSW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja0luZm9cIjtcblRyYWNrSW5mby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJzaW11bGNhc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwibWlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWNJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgYXZhaWxhYmxlIHNwYXRpYWwgbGF5ZXJzXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WaWRlb0xheWVyXG4gKi9cbmNsYXNzIFZpZGVvTGF5ZXIgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogZm9yIHRyYWNrcyB3aXRoIGEgc2luZ2xlIGxheWVyLCB0aGlzIHNob3VsZCBiZSBISUdIXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgd2lkdGggPSAyO1xuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGhlaWdodCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKlxuICAgICAqIHRhcmdldCBiaXRyYXRlIGluIGJpdCBwZXIgc2Vjb25kIChicHMpLCBzZXJ2ZXIgd2lsbCBtZWFzdXJlIGFjdHVhbFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgYml0cmF0ZSA9IDQ7XG4gICAgICovXG4gICAgdGhpcy5iaXRyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBzc3JjID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLnNzcmMgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFZpZGVvTGF5ZXIsIGEsIGIpO1xuICB9XG59XG5WaWRlb0xheWVyLnJ1bnRpbWUgPSBwcm90bzM7XG5WaWRlb0xheWVyLnR5cGVOYW1lID0gXCJsaXZla2l0LlZpZGVvTGF5ZXJcIjtcblZpZGVvTGF5ZXIuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInF1YWxpdHlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJiaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInNzcmNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbi8qKlxuICogbmV3IERhdGFQYWNrZXQgQVBJXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhUGFja2V0XG4gKi9cbmNsYXNzIERhdGFQYWNrZXQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRhdGFQYWNrZXQuS2luZCBraW5kID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmtpbmQgPSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIG9uZW9mIGxpdmVraXQuRGF0YVBhY2tldC52YWx1ZVxuICAgICAqL1xuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhUGFja2V0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGF0YVBhY2tldCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFQYWNrZXQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKERhdGFQYWNrZXQsIGEsIGIpO1xuICB9XG59XG5EYXRhUGFja2V0LnJ1bnRpbWUgPSBwcm90bzM7XG5EYXRhUGFja2V0LnR5cGVOYW1lID0gXCJsaXZla2l0LkRhdGFQYWNrZXRcIjtcbkRhdGFQYWNrZXQuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImtpbmRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhUGFja2V0X0tpbmQpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVzZXJQYWNrZXQsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3BlYWtlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRhdGFQYWNrZXQuS2luZFxuICovXG52YXIgRGF0YVBhY2tldF9LaW5kO1xuKGZ1bmN0aW9uIChEYXRhUGFja2V0X0tpbmQpIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBSRUxJQUJMRSA9IDA7XG4gICAqL1xuICBEYXRhUGFja2V0X0tpbmRbRGF0YVBhY2tldF9LaW5kW1wiUkVMSUFCTEVcIl0gPSAwXSA9IFwiUkVMSUFCTEVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBMT1NTWSA9IDE7XG4gICAqL1xuICBEYXRhUGFja2V0X0tpbmRbRGF0YVBhY2tldF9LaW5kW1wiTE9TU1lcIl0gPSAxXSA9IFwiTE9TU1lcIjtcbn0pKERhdGFQYWNrZXRfS2luZCB8fCAoRGF0YVBhY2tldF9LaW5kID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZCwgXCJsaXZla2l0LkRhdGFQYWNrZXQuS2luZFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJSRUxJQUJMRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkxPU1NZXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5BY3RpdmVTcGVha2VyVXBkYXRlXG4gKi9cbmNsYXNzIEFjdGl2ZVNwZWFrZXJVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNwZWFrZXJJbmZvIHNwZWFrZXJzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnNwZWFrZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEFjdGl2ZVNwZWFrZXJVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBY3RpdmVTcGVha2VyVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQWN0aXZlU3BlYWtlclVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoQWN0aXZlU3BlYWtlclVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cbkFjdGl2ZVNwZWFrZXJVcGRhdGUucnVudGltZSA9IHByb3RvMztcbkFjdGl2ZVNwZWFrZXJVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiO1xuQWN0aXZlU3BlYWtlclVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNwZWFrZXJJbmZvXG4gKi9cbmNsYXNzIFNwZWFrZXJJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIGF1ZGlvIGxldmVsLCAwLTEuMCwgMSBpcyBsb3VkZXN0XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGZsb2F0IGxldmVsID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmxldmVsID0gMDtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHNwZWFrZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGFjdGl2ZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3BlYWtlckluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2VySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNwZWFrZXJJbmZvKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTcGVha2VySW5mbywgYSwgYik7XG4gIH1cbn1cblNwZWFrZXJJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TcGVha2VySW5mby50eXBlTmFtZSA9IFwibGl2ZWtpdC5TcGVha2VySW5mb1wiO1xuU3BlYWtlckluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxldmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDIgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3RpdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Vc2VyUGFja2V0XG4gKi9cbmNsYXNzIFVzZXJQYWNrZXQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogcGFydGljaXBhbnQgSUQgb2YgdXNlciB0aGF0IHNlbnQgdGhlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfaWRlbnRpdHkgPSA1O1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogdXNlciBkZWZpbmVkIHBheWxvYWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYnl0ZXMgcGF5bG9hZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5wYXlsb2FkID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgLyoqXG4gICAgICogdGhlIElEIG9mIHRoZSBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZSAoc2VudCB0byBhbGwgYnkgZGVmYXVsdClcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGRlc3RpbmF0aW9uX3NpZHMgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZGVzdGluYXRpb25TaWRzID0gW107XG4gICAgLyoqXG4gICAgICogaWRlbnRpdGllcyBvZiBwYXJ0aWNpcGFudHMgd2hvIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZSAoc2VudCB0byBhbGwgYnkgZGVmYXVsdClcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIGRlc3RpbmF0aW9uX2lkZW50aXRpZXMgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuZGVzdGluYXRpb25JZGVudGl0aWVzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVzZXJQYWNrZXQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVc2VyUGFja2V0KCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXNlclBhY2tldCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXNlclBhY2tldCwgYSwgYik7XG4gIH1cbn1cblVzZXJQYWNrZXQucnVudGltZSA9IHByb3RvMztcblVzZXJQYWNrZXQudHlwZU5hbWUgPSBcImxpdmVraXQuVXNlclBhY2tldFwiO1xuVXNlclBhY2tldC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25fc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRvcGljXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIG9wdDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXG4gKi9cbmNsYXNzIFBhcnRpY2lwYW50VHJhY2tzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHBhcnRpY2lwYW50IElEIG9mIHBhcnRpY2lwYW50IHRvIHdob20gdGhlIHRyYWNrcyBiZWxvbmdcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdHJhY2tfc2lkcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZHMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRUcmFja3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFRyYWNrcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VHJhY2tzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQYXJ0aWNpcGFudFRyYWNrcywgYSwgYik7XG4gIH1cbn1cblBhcnRpY2lwYW50VHJhY2tzLnJ1bnRpbWUgPSBwcm90bzM7XG5QYXJ0aWNpcGFudFRyYWNrcy50eXBlTmFtZSA9IFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiO1xuUGFydGljaXBhbnRUcmFja3MuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgc2VydmVyXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TZXJ2ZXJJbmZvXG4gKi9cbmNsYXNzIFNlcnZlckluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvbiBlZGl0aW9uID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmVkaXRpb24gPSBTZXJ2ZXJJbmZvX0VkaXRpb24uU3RhbmRhcmQ7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdmVyc2lvbiA9IDI7XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHByb3RvY29sID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnByb3RvY29sID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSA0O1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBub2RlX2lkID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLm5vZGVJZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24uIHNlbnQgb25seSBpZiBzZXJ2ZXIgaXMgaW4gZGV2ZWxvcG1lbnQgbW9kZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgZGVidWdfaW5mbyA9IDY7XG4gICAgICovXG4gICAgdGhpcy5kZWJ1Z0luZm8gPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2VydmVySW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNlcnZlckluZm8sIGEsIGIpO1xuICB9XG59XG5TZXJ2ZXJJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TZXJ2ZXJJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlNlcnZlckluZm9cIjtcblNlcnZlckluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImVkaXRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZXJ2ZXJJbmZvX0VkaXRpb24pXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwibm9kZV9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRlYnVnX2luZm9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblxuICovXG52YXIgU2VydmVySW5mb19FZGl0aW9uO1xuKGZ1bmN0aW9uIChTZXJ2ZXJJbmZvX0VkaXRpb24pIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBTdGFuZGFyZCA9IDA7XG4gICAqL1xuICBTZXJ2ZXJJbmZvX0VkaXRpb25bU2VydmVySW5mb19FZGl0aW9uW1wiU3RhbmRhcmRcIl0gPSAwXSA9IFwiU3RhbmRhcmRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBDbG91ZCA9IDE7XG4gICAqL1xuICBTZXJ2ZXJJbmZvX0VkaXRpb25bU2VydmVySW5mb19FZGl0aW9uW1wiQ2xvdWRcIl0gPSAxXSA9IFwiQ2xvdWRcIjtcbn0pKFNlcnZlckluZm9fRWRpdGlvbiB8fCAoU2VydmVySW5mb19FZGl0aW9uID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcbnByb3RvMy51dGlsLnNldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbiwgXCJsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJTdGFuZGFyZFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNsb3VkXCJcbn1dKTtcbi8qKlxuICogZGV0YWlscyBhYm91dCB0aGUgY2xpZW50XG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5DbGllbnRJbmZvXG4gKi9cbmNsYXNzIENsaWVudEluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkNsaWVudEluZm8uU0RLIHNkayA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zZGsgPSBDbGllbnRJbmZvX1NESy5VTktOT1dOO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHZlcnNpb24gPSAyO1xuICAgICAqL1xuICAgIHRoaXMudmVyc2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwcm90b2NvbCA9IDM7XG4gICAgICovXG4gICAgdGhpcy5wcm90b2NvbCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgb3MgPSA0O1xuICAgICAqL1xuICAgIHRoaXMub3MgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG9zX3ZlcnNpb24gPSA1O1xuICAgICAqL1xuICAgIHRoaXMub3NWZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBkZXZpY2VfbW9kZWwgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuZGV2aWNlTW9kZWwgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGJyb3dzZXIgPSA3O1xuICAgICAqL1xuICAgIHRoaXMuYnJvd3NlciA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYnJvd3Nlcl92ZXJzaW9uID0gODtcbiAgICAgKi9cbiAgICB0aGlzLmJyb3dzZXJWZXJzaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBhZGRyZXNzID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLmFkZHJlc3MgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIHdpZmksIHdpcmVkLCBjZWxsdWxhciwgdnBuLCBlbXB0eSBpZiBub3Qga25vd25cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIG5ldHdvcmsgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLm5ldHdvcmsgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRJbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50SW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENsaWVudEluZm8sIGEsIGIpO1xuICB9XG59XG5DbGllbnRJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5DbGllbnRJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LkNsaWVudEluZm9cIjtcbkNsaWVudEluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNka1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm9zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwib3NfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImRldmljZV9tb2RlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImJyb3dzZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJhZGRyZXNzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcIm5ldHdvcmtcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkNsaWVudEluZm8uU0RLXG4gKi9cbnZhciBDbGllbnRJbmZvX1NESztcbihmdW5jdGlvbiAoQ2xpZW50SW5mb19TREspIHtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTktOT1dOID0gMDtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogSlMgPSAxO1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJKU1wiXSA9IDFdID0gXCJKU1wiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFNXSUZUID0gMjtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiU1dJRlRcIl0gPSAyXSA9IFwiU1dJRlRcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBBTkRST0lEID0gMztcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiQU5EUk9JRFwiXSA9IDNdID0gXCJBTkRST0lEXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogRkxVVFRFUiA9IDQ7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkZMVVRURVJcIl0gPSA0XSA9IFwiRkxVVFRFUlwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEdPID0gNTtcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiR09cIl0gPSA1XSA9IFwiR09cIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBVTklUWSA9IDY7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIlVOSVRZXCJdID0gNl0gPSBcIlVOSVRZXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUkVBQ1RfTkFUSVZFID0gNztcbiAgICovXG4gIENsaWVudEluZm9fU0RLW0NsaWVudEluZm9fU0RLW1wiUkVBQ1RfTkFUSVZFXCJdID0gN10gPSBcIlJFQUNUX05BVElWRVwiO1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFJVU1QgPSA4O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJSVVNUXCJdID0gOF0gPSBcIlJVU1RcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQWVRIT04gPSA5O1xuICAgKi9cbiAgQ2xpZW50SW5mb19TREtbQ2xpZW50SW5mb19TREtbXCJQWVRIT05cIl0gPSA5XSA9IFwiUFlUSE9OXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogQ1BQID0gMTA7XG4gICAqL1xuICBDbGllbnRJbmZvX1NES1tDbGllbnRJbmZvX1NES1tcIkNQUFwiXSA9IDEwXSA9IFwiQ1BQXCI7XG59KShDbGllbnRJbmZvX1NESyB8fCAoQ2xpZW50SW5mb19TREsgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESywgXCJsaXZla2l0LkNsaWVudEluZm8uU0RLXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNXSUZUXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiQU5EUk9JRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkZMVVRURVJcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJHT1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlVOSVRZXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiUlVTVFwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIlBZVEhPTlwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJDUFBcIlxufV0pO1xuLyoqXG4gKiBzZXJ2ZXIgcHJvdmlkZWQgY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cbiAqL1xuY2xhc3MgQ2xpZW50Q29uZmlndXJhdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyByZXN1bWVfY29ubmVjdGlvbiA9IDM7XG4gICAgICovXG4gICAgdGhpcy5yZXN1bWVDb25uZWN0aW9uID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyBmb3JjZV9yZWxheSA9IDU7XG4gICAgICovXG4gICAgdGhpcy5mb3JjZVJlbGF5ID0gQ2xpZW50Q29uZmlnU2V0dGluZy5VTlNFVDtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ2xpZW50Q29uZmlndXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudENvbmZpZ3VyYXRpb24oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRDb25maWd1cmF0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDbGllbnRDb25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuQ2xpZW50Q29uZmlndXJhdGlvbi5ydW50aW1lID0gcHJvdG8zO1xuQ2xpZW50Q29uZmlndXJhdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5DbGllbnRDb25maWd1cmF0aW9uXCI7XG5DbGllbnRDb25maWd1cmF0aW9uLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ2aWRlb1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNjcmVlblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZylcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGlzYWJsZWRfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEaXNhYmxlZENvZGVjc1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJmb3JjZV9yZWxheVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXG4gKi9cbmNsYXNzIFZpZGVvQ29uZmlndXJhdGlvbiBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ2xpZW50Q29uZmlnU2V0dGluZyBoYXJkd2FyZV9lbmNvZGVyID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmhhcmR3YXJlRW5jb2RlciA9IENsaWVudENvbmZpZ1NldHRpbmcuVU5TRVQ7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpZGVvQ29uZmlndXJhdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVmlkZW9Db25maWd1cmF0aW9uLCBhLCBiKTtcbiAgfVxufVxuVmlkZW9Db25maWd1cmF0aW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5WaWRlb0NvbmZpZ3VyYXRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCI7XG5WaWRlb0NvbmZpZ3VyYXRpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImhhcmR3YXJlX2VuY29kZXJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkRpc2FibGVkQ29kZWNzXG4gKi9cbmNsYXNzIERpc2FibGVkQ29kZWNzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGRpc2FibGVkIGZvciBib3RoIHB1Ymxpc2ggYW5kIHN1YnNjcmliZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvZGVjIGNvZGVjcyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jb2RlY3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiBvbmx5IGRpc2FibGUgZm9yIHB1Ymxpc2hcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5Db2RlYyBwdWJsaXNoID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnB1Ymxpc2ggPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGlzYWJsZWRDb2RlY3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEaXNhYmxlZENvZGVjcygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERpc2FibGVkQ29kZWNzKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhEaXNhYmxlZENvZGVjcywgYSwgYik7XG4gIH1cbn1cbkRpc2FibGVkQ29kZWNzLnJ1bnRpbWUgPSBwcm90bzM7XG5EaXNhYmxlZENvZGVjcy50eXBlTmFtZSA9IFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiO1xuRGlzYWJsZWRDb2RlY3MuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInB1Ymxpc2hcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUERyaWZ0XG4gKi9cbmNsYXNzIFJUUERyaWZ0IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBzdGFydF90aW1lc3RhbXAgPSA0O1xuICAgICAqL1xuICAgIHRoaXMuc3RhcnRUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgZW5kX3RpbWVzdGFtcCA9IDU7XG4gICAgICovXG4gICAgdGhpcy5lbmRUaW1lc3RhbXAgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgcnRwX2Nsb2NrX3RpY2tzID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLnJ0cENsb2NrVGlja3MgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBkcmlmdF9zYW1wbGVzID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmRyaWZ0U2FtcGxlcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBkcmlmdF9tcyA9IDg7XG4gICAgICovXG4gICAgdGhpcy5kcmlmdE1zID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBjbG9ja19yYXRlID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrUmF0ZSA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUERyaWZ0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQRHJpZnQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBEcmlmdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUlRQRHJpZnQsIGEsIGIpO1xuICB9XG59XG5SVFBEcmlmdC5ydW50aW1lID0gcHJvdG8zO1xuUlRQRHJpZnQudHlwZU5hbWUgPSBcImxpdmVraXQuUlRQRHJpZnRcIjtcblJUUERyaWZ0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkdXJhdGlvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInN0YXJ0X3RpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImVuZF90aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJydHBfY2xvY2tfdGlja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJkcmlmdF9zYW1wbGVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJkcmlmdF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNsb2NrX3JhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUFN0YXRzXG4gKi9cbmNsYXNzIFJUUFN0YXRzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGR1cmF0aW9uID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldHMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9yYXRlID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldFJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGhlYWRlcl9ieXRlcyA9IDM5O1xuICAgICAqL1xuICAgIHRoaXMuaGVhZGVyQnl0ZXMgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgYml0cmF0ZSA9IDc7XG4gICAgICovXG4gICAgdGhpcy5iaXRyYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX2xvc3QgPSA4O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c0xvc3QgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9sb3NzX3JhdGUgPSA5O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0TG9zc1JhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgcGFja2V0X2xvc3NfcGVyY2VudGFnZSA9IDEwO1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0TG9zc1BlcmNlbnRhZ2UgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfZHVwbGljYXRlID0gMTE7XG4gICAgICovXG4gICAgdGhpcy5wYWNrZXRzRHVwbGljYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBwYWNrZXRfZHVwbGljYXRlX3JhdGUgPSAxMjtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldER1cGxpY2F0ZVJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDY0IGJ5dGVzX2R1cGxpY2F0ZSA9IDEzO1xuICAgICAqL1xuICAgIHRoaXMuYnl0ZXNEdXBsaWNhdGUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzX2R1cGxpY2F0ZSA9IDQwO1xuICAgICAqL1xuICAgIHRoaXMuaGVhZGVyQnl0ZXNEdXBsaWNhdGUgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBkb3VibGUgYml0cmF0ZV9kdXBsaWNhdGUgPSAxNDtcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGVEdXBsaWNhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHBhY2tldHNfcGFkZGluZyA9IDE1O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c1BhZGRpbmcgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIHBhY2tldF9wYWRkaW5nX3JhdGUgPSAxNjtcbiAgICAgKi9cbiAgICB0aGlzLnBhY2tldFBhZGRpbmdSYXRlID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQ2NCBieXRlc19wYWRkaW5nID0gMTc7XG4gICAgICovXG4gICAgdGhpcy5ieXRlc1BhZGRpbmcgPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50NjQgaGVhZGVyX2J5dGVzX3BhZGRpbmcgPSA0MTtcbiAgICAgKi9cbiAgICB0aGlzLmhlYWRlckJ5dGVzUGFkZGluZyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBiaXRyYXRlX3BhZGRpbmcgPSAxODtcbiAgICAgKi9cbiAgICB0aGlzLmJpdHJhdGVQYWRkaW5nID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwYWNrZXRzX291dF9vZl9vcmRlciA9IDE5O1xuICAgICAqL1xuICAgIHRoaXMucGFja2V0c091dE9mT3JkZXIgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIGZyYW1lcyA9IDIwO1xuICAgICAqL1xuICAgIHRoaXMuZnJhbWVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBmcmFtZV9yYXRlID0gMjE7XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZG91YmxlIGppdHRlcl9jdXJyZW50ID0gMjI7XG4gICAgICovXG4gICAgdGhpcy5qaXR0ZXJDdXJyZW50ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGRvdWJsZSBqaXR0ZXJfbWF4ID0gMjM7XG4gICAgICovXG4gICAgdGhpcy5qaXR0ZXJNYXggPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbWFwPGludDMyLCB1aW50MzI+IGdhcF9oaXN0b2dyYW0gPSAyNDtcbiAgICAgKi9cbiAgICB0aGlzLmdhcEhpc3RvZ3JhbSA9IHt9O1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tzID0gMjU7XG4gICAgICovXG4gICAgdGhpcy5uYWNrcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19hY2tzID0gMzc7XG4gICAgICovXG4gICAgdGhpcy5uYWNrQWNrcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgbmFja19taXNzZXMgPSAyNjtcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tNaXNzZXMgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIG5hY2tfcmVwZWF0ZWQgPSAzODtcbiAgICAgKi9cbiAgICB0aGlzLm5hY2tSZXBlYXRlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcGxpcyA9IDI3O1xuICAgICAqL1xuICAgIHRoaXMucGxpcyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZmlycyA9IDI5O1xuICAgICAqL1xuICAgIHRoaXMuZmlycyA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgcnR0X2N1cnJlbnQgPSAzMTtcbiAgICAgKi9cbiAgICB0aGlzLnJ0dEN1cnJlbnQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogdWludDMyIHJ0dF9tYXggPSAzMjtcbiAgICAgKi9cbiAgICB0aGlzLnJ0dE1heCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIga2V5X2ZyYW1lcyA9IDMzO1xuICAgICAqL1xuICAgIHRoaXMua2V5RnJhbWVzID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBsYXllcl9sb2NrX3BsaXMgPSAzNTtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVyTG9ja1BsaXMgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSVFBTdGF0cygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJUUFN0YXRzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUlRQU3RhdHMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJUUFN0YXRzLCBhLCBiKTtcbiAgfVxufVxuUlRQU3RhdHMucnVudGltZSA9IHByb3RvMztcblJUUFN0YXRzLnR5cGVOYW1lID0gXCJsaXZla2l0LlJUUFN0YXRzXCI7XG5SVFBTdGF0cy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVuZF90aW1lXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZHVyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYWNrZXRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInBhY2tldF9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiYnl0ZXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMzksXG4gIG5hbWU6IFwiaGVhZGVyX2J5dGVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiYml0cmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInBhY2tldHNfbG9zdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJwYWNrZXRfbG9zc19yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInBhY2tldF9sb3NzX3BlcmNlbnRhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwYWNrZXRzX2R1cGxpY2F0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwicGFja2V0X2R1cGxpY2F0ZV9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImJ5dGVzX2R1cGxpY2F0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA0MCxcbiAgbmFtZTogXCJoZWFkZXJfYnl0ZXNfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImJpdHJhdGVfZHVwbGljYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInBhY2tldHNfcGFkZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwicGFja2V0X3BhZGRpbmdfcmF0ZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJieXRlc19wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDQxLFxuICBuYW1lOiBcImhlYWRlcl9ieXRlc19wYWRkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcImJpdHJhdGVfcGFkZGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJwYWNrZXRzX291dF9vZl9vcmRlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwiZnJhbWVzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyMSxcbiAgbmFtZTogXCJmcmFtZV9yYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDIyLFxuICBuYW1lOiBcImppdHRlcl9jdXJyZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbn0sIHtcbiAgbm86IDIzLFxuICBuYW1lOiBcImppdHRlcl9tYXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xufSwge1xuICBubzogMjQsXG4gIG5hbWU6IFwiZ2FwX2hpc3RvZ3JhbVwiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gIH1cbn0sIHtcbiAgbm86IDI1LFxuICBuYW1lOiBcIm5hY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzNyxcbiAgbmFtZTogXCJuYWNrX2Fja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDI2LFxuICBuYW1lOiBcIm5hY2tfbWlzc2VzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzOCxcbiAgbmFtZTogXCJuYWNrX3JlcGVhdGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyNyxcbiAgbmFtZTogXCJwbGlzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyOCxcbiAgbmFtZTogXCJsYXN0X3BsaVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAyOSxcbiAgbmFtZTogXCJmaXJzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzMCxcbiAgbmFtZTogXCJsYXN0X2ZpclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVGltZXN0YW1wXG59LCB7XG4gIG5vOiAzMSxcbiAgbmFtZTogXCJydHRfY3VycmVudFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzIsXG4gIG5hbWU6IFwicnR0X21heFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzMsXG4gIG5hbWU6IFwia2V5X2ZyYW1lc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMzQsXG4gIG5hbWU6IFwibGFzdF9rZXlfZnJhbWVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVzdGFtcFxufSwge1xuICBubzogMzUsXG4gIG5hbWU6IFwibGF5ZXJfbG9ja19wbGlzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzNixcbiAgbmFtZTogXCJsYXN0X2xheWVyX2xvY2tfcGxpXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDQ0LFxuICBuYW1lOiBcInBhY2tldF9kcmlmdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUlRQRHJpZnRcbn0sIHtcbiAgbm86IDQ1LFxuICBuYW1lOiBcInJlcG9ydF9kcmlmdFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUlRQRHJpZnRcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UaW1lZFZlcnNpb25cbiAqL1xuY2xhc3MgVGltZWRWZXJzaW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdW5peF9taWNybyA9IDE7XG4gICAgICovXG4gICAgdGhpcy51bml4TWljcm8gPSBwcm90b0ludDY0Lnplcm87XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiB0aWNrcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy50aWNrcyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVkVmVyc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZWRWZXJzaW9uLCBhLCBiKTtcbiAgfVxufVxuVGltZWRWZXJzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5UaW1lZFZlcnNpb24udHlwZU5hbWUgPSBcImxpdmVraXQuVGltZWRWZXJzaW9uXCI7XG5UaW1lZFZlcnNpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVuaXhfbWljcm9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuXG5jb25zdCBtYXhSZXRyeURlbGF5ID0gNzAwMDtcbmNvbnN0IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TID0gWzAsIDMwMCwgMiAqIDIgKiAzMDAsIDMgKiAzICogMzAwLCA0ICogNCAqIDMwMCwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheV07XG5jbGFzcyBEZWZhdWx0UmVjb25uZWN0UG9saWN5IHtcbiAgY29uc3RydWN0b3IocmV0cnlEZWxheXMpIHtcbiAgICB0aGlzLl9yZXRyeURlbGF5cyA9IHJldHJ5RGVsYXlzICE9PSB1bmRlZmluZWQgPyBbLi4ucmV0cnlEZWxheXNdIDogREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVM7XG4gIH1cbiAgbmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50ID49IHRoaXMuX3JldHJ5RGVsYXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IHRoaXMuX3JldHJ5RGVsYXlzW2NvbnRleHQucmV0cnlDb3VudF07XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA8PSAxKSByZXR1cm4gcmV0cnlEZWxheTtcbiAgICByZXR1cm4gcmV0cnlEZWxheSArIE1hdGgucmFuZG9tKCkgKiAxMDAwO1xuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBldmVudHMgPSB7ZXhwb3J0czoge319O1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsO1xudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbicgPyBSLmFwcGx5IDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xufTtcbnZhciBSZWZsZWN0T3duS2V5cztcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbmV2ZW50cy5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuZXZlbnRzLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG59O1xuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGZpcmVkOiBmYWxzZSxcbiAgICB3cmFwRm46IHVuZGVmaW5lZCxcbiAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xuICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwb3NpdGlvbiA9IC0xO1xuICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KCk7ZWxzZSB7XG4gICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG52YXIgZXZlbnRzRXhwb3J0cyA9IGV2ZW50cy5leHBvcnRzO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5sZXQgbG9nRGlzYWJsZWRfID0gdHJ1ZTtcbmxldCBkZXByZWNhdGlvbldhcm5pbmdzXyA9IHRydWU7XG5cbi8qKlxuICogRXh0cmFjdCBicm93c2VyIHZlcnNpb24gb3V0IG9mIHRoZSBwcm92aWRlZCB1c2VyIGFnZW50IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHVhc3RyaW5nIHVzZXJBZ2VudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGV4cHIgUmVndWxhciBleHByZXNzaW9uIHVzZWQgYXMgbWF0Y2ggY3JpdGVyaWEuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBicm93c2VyIHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgIGNiLmhhbmRsZUV2ZW50KG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBicm93c2VyOiBudWxsLFxuICAgIHZlcnNpb246IG51bGxcbiAgfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hdmlnYXRvclxuICB9ID0gd2luZG93O1xuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgIC8vIEZpcmVmb3guXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgd2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXG4gICAgLy8gVmVyc2lvbiBtYXRjaGVzIENocm9tZS9XZWJSVEMgdmVyc2lvbi5cbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKTtcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBzb21ldGhpbmcgeW91IHdhbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIGNvbnN0IHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtcbiAgICAgIFtrZXldOiB2YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG59XG5cbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cbmZ1bmN0aW9uIHdhbGtTdGF0cyhzdGF0cywgYmFzZSwgcmVzdWx0U2V0KSB7XG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5mdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICBjb25zdCBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICBjb25zdCB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJiB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xuICAgIHJlc3VsdC5mb3JFYWNoKHN0YXRzID0+IHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5jb25zdCBsb2dnaW5nID0gbG9nO1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQyKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgY29uc3QgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByID0gdHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7XG4gICAgICAgIGlkZWFsOiBjW2tleV1cbiAgICAgIH07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24gKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lID09PSAnZGV2aWNlSWQnID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICBsZXQgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgcmVtYXAgPSBmdW5jdGlvbiAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcgPyBmYWNlIDoge1xuICAgICAgICBpZGVhbDogZmFjZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcbiAgICAgIGlmIChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykgJiYgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlICYmICFnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcykpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGxldCBtYXRjaGVzO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2Zyb250J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBtYXRjaGVzIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gZm9yIGJhY2sgKHR5cGljYWwpLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgICAgICAgICAgbGV0IGRldiA9IGRldmljZXMuZmluZChkID0+IG1hdGNoZXMuc29tZShtYXRjaCA9PiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpKSk7XG4gICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcbiAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXYpIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge1xuICAgICAgICAgICAgICAgIGV4YWN0OiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBpZGVhbDogZGV2LmRldmljZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBJbnZhbGlkU3RhdGVFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcbiAgICAgICAgVHJhY2tTdGFydEVycm9yOiAnTm90UmVhZGFibGVFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgVGFiQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGMgPT4ge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XG5cbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgLy8gY29uc3RyYWludHMuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZSA9PiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKSkpO1xuICAgIH07XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEkMSh3aW5kb3csIGdldFNvdXJjZUlkKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldFNvdXJjZUlkIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aFxuICAvLyB0aGUgc291cmNlSWQgb2YgdGhlIHNjcmVlbi93aW5kb3cvdGFiIHRvIGJlIHNoYXJlZC5cbiAgaWYgKHR5cGVvZiBnZXRTb3VyY2VJZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ3NoaW1HZXREaXNwbGF5TWVkaWE6IGdldFNvdXJjZUlkIGFyZ3VtZW50IGlzIG5vdCAnICsgJ2EgZnVuY3Rpb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID0gZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUlkKGNvbnN0cmFpbnRzKS50aGVuKHNvdXJjZUlkID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoU3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiYgY29uc3RyYWludHMudmlkZW8ud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHRTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5oZWlnaHQ7XG4gICAgICBjb25zdCBmcmFtZVJhdGVTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5mcmFtZVJhdGU7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2U6ICdkZXNrdG9wJyxcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICBtYXhGcmFtZVJhdGU6IGZyYW1lUmF0ZVNwZWNpZmllZCB8fCAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAod2lkdGhTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heFdpZHRoID0gd2lkdGhTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U3BlY2lmaWVkKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhIZWlnaHQgPSBoZWlnaHRTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cbmZ1bmN0aW9uIHNoaW1PblRyYWNrJDEod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9vbnRyYWNrcG9seSkge1xuICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IGUgPT4ge1xuICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRlLnRyYWNrLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0ge1xuICAgICAgICAgICAgICAgIHRyYWNrOiB0ZS50cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2tcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZXZlbiBpZiBSVENSdHBUcmFuc2NlaXZlciBpcyBpbiB3aW5kb3csIGl0IGlzIG9ubHkgdXNlZCBhbmRcbiAgICAvLyBlbWl0dGVkIGluIHVuaWZpZWQtcGxhbi4gVW5mb3J0dW5hdGVseSB0aGlzIG1lYW5zIHdlIG5lZWRcbiAgICAvLyB0byB1bmNvbmRpdGlvbmFsbHkgd3JhcCB0aGUgZXZlbnQuXG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGlmICghZS50cmFuc2NlaXZlcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICByZWNlaXZlcjogZS5yZWNlaXZlclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24gKHBjLCB0cmFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIGdldCBkdG1mKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgICAgfSxcbiAgICAgICAgX3BjOiBwY1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYXVnbWVudCBhZGRUcmFjayB3aGVuIGdldFNlbmRlcnMgaXMgbm90IGF2YWlsYWJsZS5cbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kZXJzLnNsaWNlKCk7IC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLlxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgc2VuZGVyID0gc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKTtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgIC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1HZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG5cbiAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGZ1bmN0aW9uIHRoZW4gd2UgYXJlIGluIHRoZSBvbGQgc3R5bGUgc3RhdHMgc28ganVzdFxuICAgIC8vIHBhc3MgYmFjayB0aGUgb3JpZ2luYWwgZ2V0U3RhdHMgZm9ybWF0IHRvIGF2b2lkIGJyZWFraW5nIG9sZCB1c2Vycy5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBzcGVjLXN0eWxlIGdldFN0YXRzIGlzIHN1cHBvcnRlZCwgcmV0dXJuIHRob3NlIHdoZW4gY2FsbGVkIHdpdGhcbiAgICAvLyBlaXRoZXIgbm8gYXJndW1lbnRzIG9yIHRoZSBzZWxlY3RvciBhcmd1bWVudCBpcyBudWxsLlxuICAgIGlmIChvcmlnR2V0U3RhdHMubGVuZ3RoID09PSAwICYmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW10pO1xuICAgIH1cbiAgICBjb25zdCBmaXhDaHJvbWVTdGF0c18gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGNvbnN0IHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICBjb25zdCByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICByZXBvcnRzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgICAgICAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICAgICAgICAgIH1bcmVwb3J0LnR5cGVdIHx8IHJlcG9ydC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgfTtcblxuICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICBjb25zdCBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5rZXlzKHN0YXRzKS5tYXAoa2V5ID0+IFtrZXksIHN0YXRzW2tleV1dKSk7XG4gICAgfTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBvblN1Y2MobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXywgc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICAvLyBwcm9taXNlLXN1cHBvcnRcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfSwgcmVqZWN0XSk7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PlxuICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcbiAgICAgICAqICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGlkZW50aWZ5IHRoZSBSVENSdHBTZW5kZXIuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHNoaW0gcmVjZWl2ZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSkpO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXG4gIGNvbnN0IG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGV0IHNlbmRlcjtcbiAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgIGxldCBlcnI7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHMgPT4ge1xuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2gociA9PiB7XG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIgfHwgc2VuZGVyICYmIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLm1hcChzdHJlYW1JZCA9PiB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW0sIHNlbmRlcl07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbmRlcjtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbHRlcihuZXdTZW5kZXIgPT4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTEpO1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW1dLmNvbmNhdChuZXdTZW5kZXJzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBpZiAoc2VuZGVyKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxuICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY1KSB7XG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xuICB9XG5cbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxuICBjb25zdCBvcmlnR2V0TG9jYWxTdHJlYW1zID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFt0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gfHwgc3RyZWFtXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCAhPT0gMSB8fCAhc3RyZWFtc1swXS5nZXRUcmFja3MoKS5maW5kKHQgPT4gdCA9PT0gdHJhY2spKSB7XG4gICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBhZGFwdGVyLmpzIGFkZFRyYWNrIHBvbHlmaWxsIG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgJyArICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsICdOb3RTdXBwb3J0ZWRFcnJvcicpO1xuICAgIH1cbiAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICBpZiAob2xkU3RyZWFtKSB7XG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgIC8vIE5vdGU6IHdlIHJlbHkgb24gdGhlIGhpZ2gtbGV2ZWwgYWRkVHJhY2svZHRtZiBzaGltIHRvXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY29uc3QgaXNMZWdhY3lDYWxsID0gYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVzYyA9IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcbiAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGRlc2NyaXB0aW9uID0+IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG4gIGNvbnN0IG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxuXG4gIGNvbnN0IG9yaWdMb2NhbERlc2NyaXB0aW9uID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBvcmlnTG9jYWxEZXNjcmlwdGlvbi5nZXQuYXBwbHkodGhpcyk7XG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgIC8vIHNpbmNlIHdlIHNoaW0gUlRQU2VuZGVyLiBTbyB3ZSBjaGVjayBpZiBzZW5kZXIuX3BjIGlzIHNldC5cbiAgICBpZiAoIXNlbmRlci5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xuICAgIGlmICghaXNMb2NhbCkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICBsZXQgc3RyZWFtO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goc3RyZWFtaWQgPT4ge1xuICAgICAgY29uc3QgaGFzVHJhY2sgPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKS5maW5kKHRyYWNrID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGhhc1RyYWNrKSB7XG4gICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgLy8gdGFrZXMgY2FyZSBvZiBhbnkgc2hpbW1lZCBfc2VuZGVycy5cbiAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBzYW1lIG9kZCBjaHJvbWUgYmVoYXZpb3VyIGFzIGFib3ZlLlxuICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICAgIFttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIEF0dGVtcHQgdG8gZml4IE9OTiBpbiBwbGFuLWIgbW9kZS5cbmZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBlID0+IHtcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgcGMuZ2V0Q29uZmlndXJhdGlvbiAmJiBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxudmFyIGNocm9tZVNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Zml4TmVnb3RpYXRpb25OZWVkZWQ6IGZpeE5lZ290aWF0aW9uTmVlZGVkLFxuXHRzaGltQWRkVHJhY2tSZW1vdmVUcmFjazogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2ssXG5cdHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZTogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlLFxuXHRzaGltR2V0RGlzcGxheU1lZGlhOiBzaGltR2V0RGlzcGxheU1lZGlhJDEsXG5cdHNoaW1HZXRTZW5kZXJzV2l0aER0bWY6IHNoaW1HZXRTZW5kZXJzV2l0aER0bWYsXG5cdHNoaW1HZXRTdGF0czogc2hpbUdldFN0YXRzLFxuXHRzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDIsXG5cdHNoaW1NZWRpYVN0cmVhbTogc2hpbU1lZGlhU3RyZWFtLFxuXHRzaGltT25UcmFjazogc2hpbU9uVHJhY2skMSxcblx0c2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24kMSxcblx0c2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHM6IHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBkZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICBjb25zdCBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAoIShjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbykpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7XG4gICAgICAgIG1lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8ubWVkaWFTb3VyY2UgPSBwcmVmZXJyZWRNZWRpYVNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gIH07XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1xuICAgICAgICBbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtb2Rlcm5TdGF0c1R5cGVzID0ge1xuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXG4gICAgb3V0Ym91bmRydHA6ICdvdXRib3VuZC1ydHAnLFxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gIH07XG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSkudGhlbihzdGF0cyA9PiB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXG4gICAgICAgICAgc3RhdHMuZm9yRWFjaCgoc3RhdCwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICB9O1xuICB9XG4gIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgPyB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKSA6IFByb21pc2UucmVzb2x2ZShuZXcgTWFwKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgfTtcbiAgfVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgZGVwcmVjYXRlZCgncmVtb3ZlU3RyZWFtJywgJ3JlbW92ZVRyYWNrJyk7XG4gICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KSB7XG4gIC8vIHJlbmFtZSBEYXRhQ2hhbm5lbCB0byBSVENEYXRhQ2hhbm5lbCAobmF0aXZlIGZpeCBpbiBGRjYwKTpcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE3Mzg1MVxuICBpZiAod2luZG93LkRhdGFDaGFubmVsICYmICF3aW5kb3cuUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB3aW5kb3cuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuRGF0YUNoYW5uZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9IGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIC8vIFdlYklETCBpbnB1dCBjb2VyY2lvbiBhbmQgdmFsaWRhdGlvblxuICAgICAgbGV0IHNlbmRFbmNvZGluZ3MgPSBhcmd1bWVudHNbMV0gJiYgYXJndW1lbnRzWzFdLnNlbmRFbmNvZGluZ3M7XG4gICAgICBpZiAoc2VuZEVuY29kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNlbmRFbmNvZGluZ3MgPSBbLi4uc2VuZEVuY29kaW5nc107XG4gICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBzZW5kRW5jb2RpbmdzLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICBzZW5kRW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmdQYXJhbSA9PiB7XG4gICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gb3JpZ0FkZFRyYW5zY2VpdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxuICAgICAgICAvLyBhc3luY2hyb25vdXMgd2F5IGFuZCBzYXZlIHRoZSBwcm9taXNlIHJlZmVyZW5jZSBpbiBhIGdsb2JhbCBvYmplY3QuXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gdWdseSBoYWNrLCBidXQgYXQgdGhlIHNhbWUgdGltZSBpcyB3YXkgbW9yZSByb2J1c3QgdGhhblxuICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcbiAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYWZ0ZXIgdGhlIGNyZWF0ZW9mZmVyIHdlIGFyZSBub3QgMTAwJSBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIHBhcmFtcyB3ZXJlIGFzeW5jaHJvbm91c2x5IGFwcGxpZWQgc28gd2UgbWlnaHQgbWlzcyB0aGVcbiAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZW5kZXJcbiAgICAgICAgfSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5sZW5ndGggPT09IDEgJiYgT2JqZWN0LmtleXMocGFyYW1zLmVuY29kaW5nc1swXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRQYXJhbWV0ZXJzID0gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycztcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBmaXJlZm94U2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRzaGltQWRkVHJhbnNjZWl2ZXI6IHNoaW1BZGRUcmFuc2NlaXZlcixcblx0c2hpbUNyZWF0ZUFuc3dlcjogc2hpbUNyZWF0ZUFuc3dlcixcblx0c2hpbUNyZWF0ZU9mZmVyOiBzaGltQ3JlYXRlT2ZmZXIsXG5cdHNoaW1HZXREaXNwbGF5TWVkaWE6IHNoaW1HZXREaXNwbGF5TWVkaWEsXG5cdHNoaW1HZXRQYXJhbWV0ZXJzOiBzaGltR2V0UGFyYW1ldGVycyxcblx0c2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSQxLFxuXHRzaGltT25UcmFjazogc2hpbU9uVHJhY2ssXG5cdHNoaW1QZWVyQ29ubmVjdGlvbjogc2hpbVBlZXJDb25uZWN0aW9uLFxuXHRzaGltUlRDRGF0YUNoYW5uZWw6IHNoaW1SVENEYXRhQ2hhbm5lbCxcblx0c2hpbVJlY2VpdmVyR2V0U3RhdHM6IHNoaW1SZWNlaXZlckdldFN0YXRzLFxuXHRzaGltUmVtb3ZlU3RyZWFtOiBzaGltUmVtb3ZlU3RyZWFtLFxuXHRzaGltU2VuZGVyR2V0U3RhdHM6IHNoaW1TZW5kZXJHZXRTdGF0c1xufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldExvY2FsU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RyZWFtcztcbiAgICB9O1xuICB9XG4gIGlmICghKCdhZGRTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgY29uc3QgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLCBzdHJlYW0pKTtcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0UmVtb3RlU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XG4gICAgfTtcbiAgfVxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbmFkZHN0cmVhbScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGUgPT4ge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgY29uc3QgcGMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHBjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIGNvbnN0IHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgY29uc3Qgc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIGNvbnN0IGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBzZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbl0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gYWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIFtjYW5kaWRhdGVdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xufVxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBjb25zdHJhaW50cyA9PiB7XG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcbiAgICB9O1xuICB9XG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihjYiwgZXJyY2IpO1xuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMsIHtcbiAgICAgIHZpZGVvOiBjb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xuICAgICAgICAgIGRlcHJlY2F0ZWQoJ1JUQ0ljZVNlcnZlci51cmwnLCAnUlRDSWNlU2VydmVyLnVybHMnKTtcbiAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xuICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcbiAgICAgICAgICBkZWxldGUgc2VydmVyLnVybDtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gIH07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICBpZiAoJ2dlbmVyYXRlQ2VydGlmaWNhdGUnIGluIE9yaWdQZWVyQ29ubmVjdGlvbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gT3JpZ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIEFkZCBldmVudC50cmFuc2NlaXZlciBtZW1iZXIgb3ZlciBkZXByZWNhdGVkIGV2ZW50LnJlY2VpdmVyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIGNvbnN0IG9yaWdDcmVhdGVPZmZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcbiAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJiAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJiAhdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtcbiAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2b25seSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BdWRpb0NvbnRleHQod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCB3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xufVxuXG52YXIgc2FmYXJpU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRzaGltQXVkaW9Db250ZXh0OiBzaGltQXVkaW9Db250ZXh0LFxuXHRzaGltQ2FsbGJhY2tzQVBJOiBzaGltQ2FsbGJhY2tzQVBJLFxuXHRzaGltQ29uc3RyYWludHM6IHNoaW1Db25zdHJhaW50cyxcblx0c2hpbUNyZWF0ZU9mZmVyTGVnYWN5OiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3ksXG5cdHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEsXG5cdHNoaW1Mb2NhbFN0cmVhbXNBUEk6IHNoaW1Mb2NhbFN0cmVhbXNBUEksXG5cdHNoaW1SVENJY2VTZXJ2ZXJVcmxzOiBzaGltUlRDSWNlU2VydmVyVXJscyxcblx0c2hpbVJlbW90ZVN0cmVhbXNBUEk6IHNoaW1SZW1vdGVTdHJlYW1zQVBJLFxuXHRzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyOiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyXG59KTtcblxudmFyIHNkcCQxID0ge2V4cG9ydHM6IHt9fTtcblxuLyogZXNsaW50LWVudiBub2RlICovXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gIC8vIFNEUCBoZWxwZXJzLlxuICBjb25zdCBTRFBVdGlscyA9IHt9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuICAvLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gIH07XG5cbiAgLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG4gIFNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAvLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuICBTRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgfTtcbiAgLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG4gIFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbicpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG4gIFNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gICAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXG4gIFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucztcbiAgfTtcblxuICAvLyBSZXR1cm5zIGxpbmVzIHRoYXQgc3RhcnQgd2l0aCBhIGNlcnRhaW4gcHJlZml4LlxuICBTRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChibG9iLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMCk7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuICAvLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44LjhcbiAgLy8gcnBvcnQgNTU5OTZcIlxuICAvLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cbiAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGxldCBwYXJ0cztcbiAgICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICAgIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgIH1cbiAgICBjb25zdCBjYW5kaWRhdGUgPSB7XG4gICAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICAgIGNvbXBvbmVudDoge1xuICAgICAgICAxOiAncnRwJyxcbiAgICAgICAgMjogJ3J0Y3AnXG4gICAgICB9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgICBpcDogcGFydHNbNF0sXG4gICAgICBhZGRyZXNzOiBwYXJ0c1s0XSxcbiAgICAgIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcbiAgICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICAgIHR5cGU6IHBhcnRzWzddXG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxuICAgICAgICAgIGlmIChjYW5kaWRhdGVbcGFydHNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xuICB9O1xuXG4gIC8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG4gIC8vIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgYT0gcHJlZml4IVxuICBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICBjb25zdCBzZHAgPSBbXTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gICAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgICBpZiAoY29tcG9uZW50ID09PSAncnRwJykge1xuICAgICAgc2RwLnB1c2goMSk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgICAgc2RwLnB1c2goMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5hZGRyZXNzIHx8IGNhbmRpZGF0ZS5pcCk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuICAgIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgICBzZHAucHVzaCgndHlwJyk7XG4gICAgc2RwLnB1c2godHlwZSk7XG4gICAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiYgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgICB9XG4gICAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4gIC8vIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG4gIFNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUuc3Vic3RyaW5nKDE0KS5zcGxpdCgnICcpO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuICBTRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICBjb25zdCBwYXJzZWQgPSB7XG4gICAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgICB9O1xuICAgIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcbiAgICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICAgIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICAgIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAgIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICAgIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIHJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4gIC8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xuICAgIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gIFNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgICB1cmk6IHBhcnRzWzFdLFxuICAgICAgYXR0cmlidXRlczogcGFydHMuc2xpY2UoMikuam9pbignICcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4gIC8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cbiAgU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbiAoaGVhZGVyRXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICsgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gOiAnJykgKyAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgKGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzID8gJyAnICsgaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgOiAnJykgKyAnXFxyXFxuJztcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBmbXRwIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuICAvLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cbiAgU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgICBsZXQga3Y7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZm10cCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbiAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICBTRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cbiAgU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICBsZXQgbGluZXMgPSAnJztcbiAgICBsZXQgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICsgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICsgJ1xcclxcbic7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9O1xuXG4gIC8vIFBhcnNlcyBhIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4gIC8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuICBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgICBjb25zdCBwYXJ0cyA9IHtcbiAgICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApXG4gICAgfTtcbiAgICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgICBpZiAoY29sb24gPiAtMSkge1xuICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxLCBjb2xvbik7XG4gICAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfTtcblxuICAvLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxuICAvLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG4gIFNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEzKS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXG4gICAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKVxuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuICAvLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cbiAgU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICAgIGlmIChtaWQpIHtcbiAgICAgIHJldHVybiBtaWQuc3Vic3RyaW5nKDYpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXG4gIFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cbiAgICB9O1xuICB9O1xuXG4gIC8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbiAgLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG4gIFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1maW5nZXJwcmludDonKTtcbiAgICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvbGU6ICdhdXRvJyxcbiAgICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gICAgfTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIFNEUFV0aWxzLndyaXRlRHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xuICAgIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNkcDtcbiAgfTtcblxuICAvLyBQYXJzZXMgYT1jcnlwdG8gbGluZXMgaW50b1xuICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuICBTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgY3J5cHRvU3VpdGU6IHBhcnRzWzFdLFxuICAgICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpXG4gICAgfTtcbiAgfTtcbiAgU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gJ2E9Y3J5cHRvOicgKyBwYXJhbWV0ZXJzLnRhZyArICcgJyArIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgKyAodHlwZW9mIHBhcmFtZXRlcnMua2V5UGFyYW1zID09PSAnb2JqZWN0JyA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKSA6IHBhcmFtZXRlcnMua2V5UGFyYW1zKSArIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICsgJ1xcclxcbic7XG4gIH07XG5cbiAgLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xuICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxuICBTRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgICAga2V5U2FsdDogcGFydHNbMF0sXG4gICAgICBsaWZlVGltZTogcGFydHNbMV0sXG4gICAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9O1xuICBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6JyArIGtleVBhcmFtcy5rZXlTYWx0ICsgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aCA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGggOiAnJyk7XG4gIH07XG5cbiAgLy8gRXh0cmFjdHMgYWxsIFNERVMgcGFyYW1ldGVycy5cbiAgU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9Y3J5cHRvOicpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbiAgfTtcblxuICAvLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuICAvLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuICBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtdWZyYWc6JylbMF07XG4gICAgY29uc3QgcHdkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS1wd2Q6JylbMF07XG4gICAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxuICAgICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHJpbmcoMTApXG4gICAgfTtcbiAgfTtcblxuICAvLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cbiAgU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgKyAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbiAgICBpZiAocGFyYW1zLmljZUxpdGUpIHtcbiAgICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBSVENSdHBQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICBjb2RlY3M6IFtdLFxuICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICAgIHJ0Y3A6IFtdXG4gICAgfTtcbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gICAgZGVzY3JpcHRpb24ucHJvZmlsZSA9IG1saW5lWzJdO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XG4gICAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgICB9KTtcbiAgICBjb25zdCB3aWxkY2FyZFJ0Y3BGYiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjoqICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgd2lsZGNhcmRSdGNwRmIuZm9yRWFjaChmYiA9PiB7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiYgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBGSVhNRTogcGFyc2UgcnRjcC5cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xuICAvLyBwYXJhbWV0ZXJzLlxuICBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGtpbmQsIGNhcHMpIHtcbiAgICBsZXQgc2RwID0gJyc7XG5cbiAgICAvLyBCdWlsZCB0aGUgbWxpbmUuXG4gICAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICAgIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICAgIHNkcCArPSAnICcgKyAoY2Fwcy5wcm9maWxlIHx8ICdVRFAvVExTL1JUUC9TQVZQRicpICsgJyAnO1xuICAgIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gICAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gICAgfSk7XG4gICAgbGV0IG1heHB0aW1lID0gMDtcbiAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVFeHRtYXAoZXh0ZW5zaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgICByZXR1cm4gc2RwO1xuICB9O1xuXG4gIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICAgIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gICAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICAgIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgICBsZXQgc2Vjb25kYXJ5U3NyYztcbiAgICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKS5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XG4gICAgfSk7XG4gICAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgICB9XG4gICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgICBlbmNQYXJhbS5ydHggPSB7XG4gICAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg3KSwgMTApO1xuICAgICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNSksIDEwKSAqIDEwMDAgKiAwLjk1IC0gNTAgKiA0MCAqIDg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xuICB9O1xuXG4gIC8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuICBTRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgICAvLyBTU1JDcy5cbiAgICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xuICAgIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICAgIH1cblxuICAgIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAgIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgICBjb25zdCBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gICAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xuICB9O1xuICBTRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IHNkcCA9ICcnO1xuICAgIGlmIChydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSkge1xuICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAocnRjcFBhcmFtZXRlcnMubXV4KSB7XG4gICAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICAgIH1cbiAgICBpZiAocnRjcFBhcmFtZXRlcnMuc3NyYyAhPT0gdW5kZWZpbmVkICYmIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lKSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gICAgfVxuICAgIHJldHVybiBzZHA7XG4gIH07XG5cbiAgLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuICAvLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuICBTRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgbGV0IHBhcnRzO1xuICAgIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gICAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICB0cmFjazogcGFydHNbMV1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gICAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogcGFydHNbMF0sXG4gICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU0NUUFxuICAvLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbiAgLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcbiAgU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gICAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICB9XG4gICAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxuICAgICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICAgIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF0uc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgICBtYXhNZXNzYWdlU2l6ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU0NUUFxuICAvLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4gIC8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4gIC8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4gIC8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcbiAgU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWEsIHNjdHApIHtcbiAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJywgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLCAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ107XG4gICAgfVxuICAgIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbiAgLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4gIC8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuICBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG4gIH07XG5cbiAgLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcbiAgLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbiAgLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4gIC8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXG4gIC8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG4gIFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24gKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgICBsZXQgc2Vzc2lvbklkO1xuICAgIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgICBpZiAoc2Vzc0lkKSB7XG4gICAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAgIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICAgIHJldHVybiAndj0wXFxyXFxuJyArICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgKyAncz0tXFxyXFxuJyArICd0PTAgMFxcclxcbic7XG4gIH07XG5cbiAgLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG4gIFNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gICAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyaW5nKDIpO1xuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZXNzaW9ucGFydCkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gICAgfVxuICAgIHJldHVybiAnc2VuZHJlY3YnO1xuICB9O1xuICBTRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyaW5nKDIpO1xuICB9O1xuICBTRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xuICB9O1xuICBTRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1syXSxcbiAgICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpXG4gICAgfTtcbiAgfTtcbiAgU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICAgIHNlc3Npb25JZDogcGFydHNbMV0sXG4gICAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxuICAgICAgYWRkcmVzczogcGFydHNbNV1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cbiAgU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbiAge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4gIH1cbn0pKHNkcCQxKTtcbnZhciBzZHBFeHBvcnRzID0gc2RwJDEuZXhwb3J0cztcbnZhciBTRFBVdGlscyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZHBFeHBvcnRzKTtcblxudmFyIHNkcCA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0OiBTRFBVdGlsc1xufSwgW3NkcEV4cG9ydHNdKTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2FuZGlkYXRlLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuYXRpdmVDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUuY2FuZGlkYXRlKTtcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHJlbGF5UHJvdG9jb2wuXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XG4gICAgICAgICAgMDogJ3RscycsXG4gICAgICAgICAgMTogJ3RjcCcsXG4gICAgICAgICAgMjogJ3VkcCdcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNkcFNlbWFudGljc1xuICAgICAgfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICBjb25zdCBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgfVxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gIH07XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MDUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgY29uc3Qgc2RwID0gZGVzYy5zZHAuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAvLyBTYWZhcmkgZW5mb3JjZXMgcmVhZC1vbmx5LW5lc3Mgb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIGZpZWxkcy5cbiAgICAgIGlmICh3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICYmIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzYy5zZHAgPSBzZHA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8vIFN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgLy8gYXMgd2VsbCBhcyBhZGRJY2VDYW5kaWRhdGUoe2NhbmRpZGF0ZTogXCJcIiwgLi4ufSlcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXG4gIC8vIE5vdGU6IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBwb2x5ZmlsbHMgd2hpY2ggY2hhbmdlIHRoZSBzaWduYXR1cmUuXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgaWYgKCFuYXRpdmVBZGRJY2VDYW5kaWRhdGUgfHwgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgLy8gTmF0aXZlIHN1cHBvcnQgZm9yIGlnbm9yaW5nIGV4aXN0cyBmb3IgQ2hyb21lIE03NysuXG4gICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgIC8vIHZlcnNpb24gdGhhdCBhbHNvIGlnbm9yZXMgYWRkSWNlQ2FuZGlkYXRlKG51bGwpLlxuICAgIGlmICgoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScpICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmZ1bmN0aW9uIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBpZiAoIW5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gfHwgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnIHx8IGRlc2MudHlwZSAmJiBkZXNjLnNkcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbWFpbmluZyBzdGVwcyBzaG91bGQgdGVjaG5pY2FsbHkgaGFwcGVuIHdoZW4gU0xEIGNvbWVzIG9mZiB0aGVcbiAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgIC8vIHRoaXMgaXMgdG9vIGRpZmZpY3VsdCB0byBzaGltLiBJbnN0ZWFkLCB0aGlzIHNoaW0gb25seSBjb3ZlcnMgdGhlXG4gICAgLy8gY29tbW9uIGNhc2Ugd2hlcmUgdGhlIG9wZXJhdGlvbnMgY2hhaW4gaXMgZW1wdHkuIFRoaXMgaXMgaW1wZXJmZWN0LCBidXRcbiAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAvLyB3aW5kb3cgdG8gemVybyBvbiBpbXBlcmZlY3QgaW1wbGVtZW50YXRpb25zLCB0aGVyZSdzIHZhbHVlIGluIHRhcHBpbmdcbiAgICAvLyBpbnRvIHRoZSBwZXJmZWN0IG5lZ290aWF0aW9uIHBhdHRlcm4gdGhhdCBzZXZlcmFsIGJyb3dzZXJzIHN1cHBvcnQuXG4gICAgZGVzYyA9IHtcbiAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgIHNkcDogZGVzYy5zZHBcbiAgICB9O1xuICAgIGlmICghZGVzYy50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgY2FzZSAnaGF2ZS1sb2NhbC1vZmZlcic6XG4gICAgICAgIGNhc2UgJ2hhdmUtcmVtb3RlLXByYW5zd2VyJzpcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVzYy5zZHAgfHwgZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBkZXNjLnR5cGUgPT09ICdvZmZlcicgPyB0aGlzLmNyZWF0ZU9mZmVyIDogdGhpcy5jcmVhdGVBbnN3ZXI7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcykudGhlbihkID0+IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2RdKSk7XG4gIH07XG59XG5cbnZhciBjb21tb25TaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQ6IHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQsXG5cdHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eTogc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5LFxuXHRzaGltQ29ubmVjdGlvblN0YXRlOiBzaGltQ29ubmVjdGlvblN0YXRlLFxuXHRzaGltTWF4TWVzc2FnZVNpemU6IHNoaW1NYXhNZXNzYWdlU2l6ZSxcblx0c2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uOiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24sXG5cdHNoaW1SVENJY2VDYW5kaWRhdGU6IHNoaW1SVENJY2VDYW5kaWRhdGUsXG5cdHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sOiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCxcblx0c2hpbVNlbmRUaHJvd1R5cGVFcnJvcjogc2hpbVNlbmRUaHJvd1R5cGVFcnJvclxufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbmZ1bmN0aW9uIGFkYXB0ZXJGYWN0b3J5KCkge1xuICBsZXQge1xuICAgIHdpbmRvd1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBzaGltQ2hyb21lOiB0cnVlLFxuICAgIHNoaW1GaXJlZm94OiB0cnVlLFxuICAgIHNoaW1TYWZhcmk6IHRydWVcbiAgfTtcbiAgLy8gVXRpbHMuXG4gIGNvbnN0IGxvZ2dpbmcgPSBsb2c7XG4gIGNvbnN0IGJyb3dzZXJEZXRhaWxzID0gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IGV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IGRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiBkaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwXG4gIH07XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24kMSB8fCAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltT25UcmFjayQxKHdpbmRvdyk7XG4gICAgICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KTtcbiAgICAgIHNoaW1HZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KTtcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1PblRyYWNrKHdpbmRvdyk7XG4gICAgICBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdyk7XG4gICAgICBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KTtcbiAgICAgIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2hpbUdldFBhcmFtZXRlcnMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpO1xuICAgICAgc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpO1xuICAgICAgc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpO1xuICAgICAgc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIHNoaW1BdWRpb0NvbnRleHQod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuYWRhcHRlckZhY3Rvcnkoe1xuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogd2luZG93XG59KTtcblxuY29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XG4vLyBIb3cgbWFueSBjb25zZWN1dGl2ZSBmcmFtZXMgY2FuIGZhaWwgZGVjcnlwdGluZyBiZWZvcmUgYSBwYXJ0aWN1bGFyIGtleSBnZXRzIG1hcmtlZCBhcyBpbnZhbGlkXG5jb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmNvbnN0IEUyRUVfRkxBRyA9ICdsa19lMmVlJztcbmNvbnN0IFNBTFQgPSAnTEtGcmFtZUVuY3J5cHRpb25LZXknO1xuY29uc3QgS0VZX1BST1ZJREVSX0RFRkFVTFRTID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0Vcbn07XG5cbnZhciBLZXlQcm92aWRlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlQcm92aWRlckV2ZW50KSB7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJTZXRLZXlcIl0gPSBcInNldEtleVwiO1xuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xufSkoS2V5UHJvdmlkZXJFdmVudCB8fCAoS2V5UHJvdmlkZXJFdmVudCA9IHt9KSk7XG52YXIgS2V5SGFuZGxlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlIYW5kbGVyRXZlbnQpIHtcbiAgS2V5SGFuZGxlckV2ZW50W1wiS2V5UmF0Y2hldGVkXCJdID0gXCJrZXlSYXRjaGV0ZWRcIjtcbn0pKEtleUhhbmRsZXJFdmVudCB8fCAoS2V5SGFuZGxlckV2ZW50ID0ge30pKTtcbnZhciBFbmNyeXB0aW9uRXZlbnQ7XG4oZnVuY3Rpb24gKEVuY3J5cHRpb25FdmVudCkge1xuICBFbmNyeXB0aW9uRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIEVuY3J5cHRpb25FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG59KShFbmNyeXB0aW9uRXZlbnQgfHwgKEVuY3J5cHRpb25FdmVudCA9IHt9KSk7XG52YXIgQ3J5cHRvckV2ZW50O1xuKGZ1bmN0aW9uIChDcnlwdG9yRXZlbnQpIHtcbiAgQ3J5cHRvckV2ZW50W1wiRXJyb3JcIl0gPSBcImNyeXB0b3JFcnJvclwiO1xufSkoQ3J5cHRvckV2ZW50IHx8IChDcnlwdG9yRXZlbnQgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1ZpZGVvRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEtleShrZXlCeXRlcykge1xuICBsZXQgYWxnb3JpdGhtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE1cbiAgfTtcbiAgbGV0IHVzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZW5jcnlwdCc7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleUJ5dGVzLCBhbGdvcml0aG0sIGZhbHNlLCB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcocGFzc3dvcmQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShwYXNzd29yZCksIHtcbiAgICAgIG5hbWU6ICdQQktERjInXG4gICAgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXIpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBjcnlwdG9CdWZmZXIsICdIS0RGJywgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWUsIHNhbHQpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZW5jb2RlZFNhbHQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc2FsdCk7XG4gIHN3aXRjaCAoYWxnb3JpdGhtTmFtZSkge1xuICAgIGNhc2UgJ0hLREYnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpbmZvOiBuZXcgQXJyYXlCdWZmZXIoMTI4KVxuICAgICAgfTtcbiAgICBjYXNlICdQQktERjInOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxnb3JpdGhtIFwiLmNvbmNhdChhbGdvcml0aG1OYW1lLCBcIiBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRcIikpO1xuICB9XG59XG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5mdW5jdGlvbiBkZXJpdmVLZXlzKG1hdGVyaWFsLCBzYWx0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hrZGZQYXJhbXNcbiAgICBjb25zdCBlbmNyeXB0aW9uS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjhcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGVyaWFsLFxuICAgICAgZW5jcnlwdGlvbktleVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRTJFRUtleSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG59XG4vKipcbiAqIFJhdGNoZXRzIGEga2V5LiBTZWVcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuNS4xXG4gKi9cbmZ1bmN0aW9uIHJhdGNoZXQobWF0ZXJpYWwsIHNhbHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlQml0c1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG4gIH0pO1xufVxuZnVuY3Rpb24gbmVlZHNSYnNwVW5lc2NhcGluZyhmcmFtZURhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZURhdGEubGVuZ3RoIC0gMzsgaSsrKSB7XG4gICAgaWYgKGZyYW1lRGF0YVtpXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDJdID09IDMpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmJzcChzdHJlYW0pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOykge1xuICAgIC8vIEJlIGNhcmVmdWwgYWJvdXQgb3Zlci91bmRlcmZsb3cgaGVyZS4gYnl0ZV9sZW5ndGhfIC0gMyBjYW4gdW5kZXJmbG93LCBhbmRcbiAgICAvLyBpICsgMyBjYW4gb3ZlcmZsb3csIGJ1dCBieXRlX2xlbmd0aF8gLSBpIGNhbid0LCBiZWNhdXNlIGkgPCBieXRlX2xlbmd0aF9cbiAgICAvLyBhYm92ZSwgYW5kIHRoYXQgZXhwcmVzc2lvbiB3aWxsIHByb2R1Y2UgdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IGluXG4gICAgLy8gdGhlIHN0cmVhbSBpbmNsdWRpbmcgdGhlIGJ5dGUgYXQgaS5cbiAgICBpZiAobGVuZ3RoIC0gaSA+PSAzICYmICFzdHJlYW1baV0gJiYgIXN0cmVhbVtpICsgMV0gJiYgc3RyZWFtW2kgKyAyXSA9PSAzKSB7XG4gICAgICAvLyBUd28gcmJzcCBieXRlcy5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgLy8gU2tpcCB0aGUgZW11bGF0aW9uIGJ5dGUuXG4gICAgICBpKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNpbmdsZSByYnNwIGJ5dGUuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW4pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV9pbi5sZW5ndGg7ICsraSkge1xuICAgIHZhciBieXRlID0gZGF0YV9pbltpXTtcbiAgICBpZiAoYnl0ZSA8PSBrRW11bGF0aW9uQnl0ZSAmJiBudW1Db25zZWN1dGl2ZVplcm9zID49IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSkge1xuICAgICAgLy8gTmVlZCB0byBlc2NhcGUuXG4gICAgICBkYXRhT3V0LnB1c2goa0VtdWxhdGlvbkJ5dGUpO1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICAgIGRhdGFPdXQucHVzaChieXRlKTtcbiAgICBpZiAoYnl0ZSA9PSAwKSB7XG4gICAgICArK251bUNvbnNlY3V0aXZlWmVyb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBCYXNlS2V5UHJvdmlkZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGNhbGxiYWNrIGJlaW5nIGludm9rZWQgYWZ0ZXIgYSByYXRjaGV0IHJlcXVlc3QgaGFzIGJlZW4gcGVyZm9ybWVkIG9uIGEgcGFydGljaXBhbnRcbiAgICAgKiB0aGF0IHN1cmZhY2VzIHRoZSBuZXcga2V5IG1hdGVyaWFsLlxuICAgICAqIEBwYXJhbSBtYXRlcmlhbFxuICAgICAqIEBwYXJhbSBrZXlJbmRleFxuICAgICAqL1xuICAgIHRoaXMub25LZXlSYXRjaGV0ZWQgPSAobWF0ZXJpYWwsIGtleUluZGV4KSA9PiB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdrZXkgcmF0Y2hldGVkIGV2ZW50IHJlY2VpdmVkJywge1xuICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5rZXlJbmZvTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgS0VZX1BST1ZJREVSX0RFRkFVTFRTKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIGEga2V5IGhhcyBiZWVuIHNldCBmb3IgYSBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKi9cbiAgb25TZXRFbmNyeXB0aW9uS2V5KGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfTtcbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KFwiXCIuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IG51bGwgJiYgcGFydGljaXBhbnRJZGVudGl0eSAhPT0gdm9pZCAwID8gcGFydGljaXBhbnRJZGVudGl0eSA6ICdzaGFyZWQnLCBcIi1cIikuY29uY2F0KGtleUluZGV4ICE9PSBudWxsICYmIGtleUluZGV4ICE9PSB2b2lkIDAgPyBrZXlJbmRleCA6IDApLCBrZXlJbmZvKTtcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8pO1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5rZXlJbmZvTWFwLnZhbHVlcygpKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gIH1cbn1cbi8qKlxuICogQSBiYXNpYyBLZXlQcm92aWRlciBpbXBsZW1lbnRhdGlvbiBpbnRlbmRlZCBmb3IgYSBzaW5nbGUgc2hhcmVkXG4gKiBwYXNzcGhyYXNlIGJldHdlZW4gYWxsIHBhcnRpY2lwYW50c1xuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgc2hhcmVkS2V5OiB0cnVlLFxuICAgICAgLy8gZm9yIGEgc2hhcmVkIGtleSBwcm92aWRlciBmYWlsaW5nIHRvIGRlY3J5cHQgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnRcbiAgICAgIC8vIHNob3VsZCBub3QgbWFyayB0aGUga2V5IGFzIGludmFsaWQsIHNvIHdlIGFjY2VwdCB3cm9uZyBrZXlzIGZvcmV2ZXJcbiAgICAgIC8vIGFuZCB3b24ndCB0cnkgdG8gYXV0by1yYXRjaGV0XG4gICAgICByYXRjaGV0V2luZG93U2l6ZTogMCxcbiAgICAgIGZhaWx1cmVUb2xlcmFuY2U6IC0xXG4gICAgfSk7XG4gICAgc3VwZXIob3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBzZXRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHlpZWxkIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhrZXkpIDogeWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGtleSk7XG4gICAgICB0aGlzLm9uU2V0RW5jcnlwdGlvbktleShkZXJpdmVkS2V5KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbiwgc3RhdHVzKSB7XG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIH1cbn1cbmNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufVxuY2xhc3MgVHJhY2tJbnZhbGlkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjAsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgfVxufVxuY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgfVxufVxuY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBwdWJsaXNoIGRhdGEnKTtcbiAgfVxufVxudmFyIE1lZGlhRGV2aWNlRmFpbHVyZTtcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IFwiUGVybWlzc2lvbkRlbmllZFwiO1xuICAvLyBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZVxuICBNZWRpYURldmljZUZhaWx1cmVbXCJOb3RGb3VuZFwiXSA9IFwiTm90Rm91bmRcIjtcbiAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICBNZWRpYURldmljZUZhaWx1cmVbXCJEZXZpY2VJblVzZVwiXSA9IFwiRGV2aWNlSW5Vc2VcIjtcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiT3RoZXJcIl0gPSBcIk90aGVyXCI7XG59KShNZWRpYURldmljZUZhaWx1cmUgfHwgKE1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmICduYW1lJyBpbiBlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnRGV2aWNlc05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuTm90Rm91bmQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLkRldmljZUluVXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5PdGhlcjtcbiAgICB9XG4gIH1cbiAgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUgPSBnZXRGYWlsdXJlO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuXG4vKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xudmFyIFJvb21FdmVudDtcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWRcbiAgICovXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgU3RhdGVDaGFuZ2VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuICAgKi9cbiAgUm9vbUV2ZW50W1wiU3RhdGVDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcm9vbVxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cbiAgICogVGhpcyBhbGxvd3MgZm9yIGFwcGxpY2F0aW9ucyB0byBzaG93IFVJIGluZm9ybWluZyB1c2VycyB0aGF0IHRoZXkgbWlnaHQgaGF2ZSB0b1xuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKlxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cbiAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgKlxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUm9vbU1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicm9vbU1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0sIHRvcGljPzogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgKHJlbW90ZSkgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBzdGF0dXMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgYXVkaW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGF1ZGlvIGVsZW1lbnRzLiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogYFJvb20uY2FuUGxheWJhY2tBdWRpb2Agd2lsbCBpbmRpY2F0ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBwZXJtaXR0ZWQuXG4gICAqL1xuICBSb29tRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCB2aWRlbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYSB2aWRlbyBlbGVtZW50LiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogQ2FsbGluZyBgcm9vbS5zdGFydFZpZGVvKClgIGluIGEgdXNlciBnZXN0dXJlIGV2ZW50IGhhbmRsZXIgd2lsbCByZXN1bWUgdGhlIHZpZGVvIHBsYXliYWNrLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcInZpZGVvUGxheWJhY2tDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIHdlIGhhdmUgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0cmFjay5cbiAgICogVGhlIGVycm9ycyB0YWtlIHBsYWNlIGluIGdldFVzZXJNZWRpYSgpLlxuICAgKiBVc2UgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUoZXJyb3IpIHRvIGdldCB0aGUgcmVhc29uIG9mIGZhaWx1cmUuXG4gICAqIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0Q2FtZXJhRXJyb3JdXSBhbmQgW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RNaWNyb3Bob25lRXJyb3JdXVxuICAgKiB3aWxsIGluZGljYXRlIGlmIGl0IGhhZCBhbiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgYXVkaW8gb3IgdmlkZW8gdHJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKiBhcmdzOiAoZXJyb3I6IEVycm9yKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC4gQ3VycmVudGx5IG9ubHkgZmlyZWQgb24gTG9jYWxQYXJ0aWNpcGFudC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xuICAvKipcbiAgICogU2lnbmFsIGNvbm5lY3RlZCwgY2FuIHB1Ymxpc2ggdHJhY2tzLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFJlY29yZGluZyBvZiBhIHJvb20gaGFzIHN0YXJ0ZWQvc3RvcHBlZC4gUm9vbS5pc1JlY29yZGluZyB3aWxsIGJlIHVwZGF0ZWQgdG9vLlxuICAgKiBhcmdzOiAoaXNSZWNvcmRpbmc6IGJvb2xlYW4pXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvcmRpbmdTdGF0dXNDaGFuZ2VkXCJdID0gXCJyZWNvcmRpbmdTdGF0dXNDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiRW5jcnlwdGlvbkVycm9yXCJdID0gXCJlbmNyeXB0aW9uRXJyb3JcIjtcbiAgLyoqXG4gICAqIEVtaXRzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGJ1ZmZlciBzdGF0dXMgb2YgYSBkYXRhIGNoYW5uZWwgY2hhbmdlc1xuICAgKiBhcmdzOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWRcIl0gPSBcImRjQnVmZmVyU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGJ5IGEgY2FsbCB0byByb29tLnN3aXRjaEFjdGl2ZURldmljZVxuICAgKiBhcmdzOiAoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlRGV2aWNlQ2hhbmdlZFwiXSA9IFwiYWN0aXZlRGV2aWNlQ2hhbmdlZFwiO1xufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XG4gICAqXG4gICAqIGFyZ3M6IChzcGVha2luZzogYm9vbGVhbilcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJJc1NwZWFraW5nQ2hhbmdlZFwiXSA9IFwiaXNTcGVha2luZ0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkF1ZGlvU3RyZWFtQWNxdWlyZWRcIl0gPSBcImF1ZGlvU3RyZWFtQWNxdWlyZWRcIjtcbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLiBDdXJyZW50bHkgb25seSBmaXJlZCBvbiBMb2NhbFBhcnRpY2lwYW50LlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQQ1RyYWNrQWRkZWRcIl0gPSBcInBjVHJhY2tBZGRlZFwiO1xufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG52YXIgRW5naW5lRXZlbnQ7XG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xuICBFbmdpbmVFdmVudFtcIlJlc3VtZWRcIl0gPSBcInJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN1bWVkXCJdID0gXCJzaWduYWxSZXN1bWVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiTWVkaWFUcmFja0FkZGVkXCJdID0gXCJtZWRpYVRyYWNrQWRkZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xuICBFbmdpbmVFdmVudFtcIlJUUFZpZGVvTWFwVXBkYXRlXCJdID0gXCJydHBWaWRlb01hcFVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUm9vbVVwZGF0ZVwiXSA9IFwicm9vbVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVtb3RlTXV0ZVwiXSA9IFwicmVtb3RlTXV0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG59KShFbmdpbmVFdmVudCB8fCAoRW5naW5lRXZlbnQgPSB7fSkpO1xudmFyIFRyYWNrRXZlbnQ7XG4oZnVuY3Rpb24gKFRyYWNrRXZlbnQpIHtcbiAgVHJhY2tFdmVudFtcIk1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcbiAgVHJhY2tFdmVudFtcIk11dGVkXCJdID0gXCJtdXRlZFwiO1xuICBUcmFja0V2ZW50W1wiVW5tdXRlZFwiXSA9IFwidW5tdXRlZFwiO1xuICAvKipcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIlJlc3RhcnRlZFwiXSA9IFwicmVzdGFydGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJFbmRlZFwiXSA9IFwiZW5kZWRcIjtcbiAgVHJhY2tFdmVudFtcIlN1YnNjcmliZWRcIl0gPSBcInN1YnNjcmliZWRcIjtcbiAgVHJhY2tFdmVudFtcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVNldHRpbmdzXCJdID0gXCJ1cGRhdGVTZXR0aW5nc1wiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTdWJzY3JpcHRpb25cIl0gPSBcInVwZGF0ZVN1YnNjcmlwdGlvblwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwiYXVkaW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxBdWRpb1RyYWNrIGluc3RhbmNlc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJhdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaXNpYmlsaXR5Q2hhbmdlZFwiXSA9IFwidmlzaWJpbGl0eUNoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiXSA9IFwidmlkZW9EaW1lbnNpb25zQ2hhbmdlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwidmlkZW9QbGF5YmFja1N0YXJ0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwidmlkZW9QbGF5YmFja0ZhaWxlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50QXR0YWNoZWRcIl0gPSBcImVsZW1lbnRBdHRhY2hlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50RGV0YWNoZWRcIl0gPSBcImVsZW1lbnREZXRhY2hlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVBhdXNlZFwiXSA9IFwidXBzdHJlYW1QYXVzZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1SZXN1bWVkXCJdID0gXCJ1cHN0cmVhbVJlc3VtZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXG4gICAqL1xuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwic3Vic2NyaXB0aW9uRmFpbGVkXCI7XG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtcblxuZnVuY3Rpb24gcihyLCBlLCBuKSB7XG4gIHZhciBpLCB0LCBvO1xuICB2b2lkIDAgPT09IGUgJiYgKGUgPSA1MCksIHZvaWQgMCA9PT0gbiAmJiAobiA9IHt9KTtcbiAgdmFyIGEgPSBudWxsICE9IChpID0gbi5pc0ltbWVkaWF0ZSkgJiYgaSxcbiAgICB1ID0gbnVsbCAhPSAodCA9IG4uY2FsbGJhY2spICYmIHQsXG4gICAgYyA9IG4ubWF4V2FpdCxcbiAgICB2ID0gRGF0ZS5ub3coKSxcbiAgICBsID0gW107XG4gIGZ1bmN0aW9uIGYoKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gYykge1xuICAgICAgdmFyIHIgPSBEYXRlLm5vdygpIC0gdjtcbiAgICAgIGlmIChyICsgZSA+PSBjKSByZXR1cm4gYyAtIHI7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIHZhciBkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgbiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCB0KSB7XG4gICAgICB2YXIgYyA9IGEgJiYgdm9pZCAwID09PSBvO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG8gPSB2b2lkIDAsIHYgPSBEYXRlLm5vdygpLCAhYSkge1xuICAgICAgICAgIHZhciBpID0gci5hcHBseShuLCBlKTtcbiAgICAgICAgICB1ICYmIHUoaSksIGwuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCByLnJlc29sdmUpKGkpO1xuICAgICAgICAgIH0pLCBsID0gW107XG4gICAgICAgIH1cbiAgICAgIH0sIGYoKSksIGMpIHtcbiAgICAgICAgdmFyIGQgPSByLmFwcGx5KG4sIGUpO1xuICAgICAgICByZXR1cm4gdSAmJiB1KGQpLCBpKGQpO1xuICAgICAgfVxuICAgICAgbC5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZTogaSxcbiAgICAgICAgcmVqZWN0OiB0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGQuY2FuY2VsID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAoMCwgZS5yZWplY3QpKHIpO1xuICAgIH0pLCBsID0gW107XG4gIH0sIGQ7XG59XG5cbi8vIHRpbnksIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbGFuY2VkaWtzb24vYm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9wYXJzZXItYnJvd3NlcnMuanNcbi8vIHJlZHVjZWQgdG8gb25seSBkaWZmZXJlbnRpYXRlIENocm9tZShpdW0pIGJhc2VkIGJyb3dzZXJzIC8gRmlyZWZveCAvIFNhZmFyaVxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcbmxldCBicm93c2VyRGV0YWlscztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50KSB7XG4gIGxldCBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCAhPT0gbnVsbCAmJiB1c2VyQWdlbnQgIT09IHZvaWQgMCA/IHVzZXJBZ2VudCA6IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChicm93c2VyRGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdGVzdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gdGVzdC50ZXN0KHVhKTtcbiAgICB9KTtcbiAgICBicm93c2VyRGV0YWlscyA9IGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5kZXNjcmliZSh1YSk7XG4gIH1cbiAgcmV0dXJuIGJyb3dzZXJEZXRhaWxzO1xufVxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW3tcbiAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCB7XG4gIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmNocm9tZXxjaHJvbWl1bXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NyaW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn0sIC8qIFNhZmFyaSAqL1xue1xuICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufV07XG5mdW5jdGlvbiBnZXRNYXRjaChleHAsIHVhKSB7XG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IGlkICYmIG1hdGNoW2lkXSB8fCAnJztcbn1cblxudmFyIHZlcnNpb24kMSA9IFwiMS4xNS41XCI7XG5cbmNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uJDE7XG5jb25zdCBwcm90b2NvbFZlcnNpb24gPSAxMTtcblxuLyoqXG4gKiBUaW1lcnMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uc1xuICogdGhhdCBlbnN1cmUgdGhhdCB0aGV5IGFyZSBmaXJlZC4gVGhlc2Ugc2hvdWxkIGJlIHVzZWQgd2hlbiBpdCBpcyBjcml0aWNhbFxuICogdGhhdCB0aGUgdGltZXIgZmlyZXMgb24gdGltZS5cbiAqL1xuY2xhc3MgQ3JpdGljYWxUaW1lcnMge31cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5Dcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0VGltZW91dCguLi5hcmd1bWVudHMpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNldEludGVydmFsKC4uLmFyZ3VtZW50cyk7XG59O1xuQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2xlYXJUaW1lb3V0KC4uLmFyZ3VtZW50cyk7XG59O1xuQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcbn07XG5cbmNsYXNzIFZpZGVvUHJlc2V0IHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgbWF4Qml0cmF0ZSwgbWF4RnJhbWVyYXRlLCBwcmlvcml0eSkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgbWF4Qml0cmF0ZSxcbiAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgIHByaW9yaXR5XG4gICAgfTtcbiAgfVxuICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnJhbWVSYXRlOiB0aGlzLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHRcbiAgICB9O1xuICB9XG59XG5jb25zdCBiYWNrdXBDb2RlY3MgPSBbJ3ZwOCcsICdoMjY0J107XG5jb25zdCB2aWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnLCAndnA5JywgJ2F2MSddO1xuZnVuY3Rpb24gaXNCYWNrdXBDb2RlYyhjb2RlYykge1xuICByZXR1cm4gISFiYWNrdXBDb2RlY3MuZmluZChiYWNrdXAgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG52YXIgQXVkaW9QcmVzZXRzO1xuKGZ1bmN0aW9uIChBdWRpb1ByZXNldHMpIHtcbiAgQXVkaW9QcmVzZXRzLnRlbGVwaG9uZSA9IHtcbiAgICBtYXhCaXRyYXRlOiAxMjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMuc3BlZWNoID0ge1xuICAgIG1heEJpdHJhdGU6IDIwMDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpYyA9IHtcbiAgICBtYXhCaXRyYXRlOiAzMjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogNDgwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHkgPSB7XG4gICAgbWF4Qml0cmF0ZTogNjQwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHlTdGVyZW8gPSB7XG4gICAgbWF4Qml0cmF0ZTogOTYwMDBcbiAgfTtcbn0pKEF1ZGlvUHJlc2V0cyB8fCAoQXVkaW9QcmVzZXRzID0ge30pKTtcbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMTgwLCAxNjAwMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNTQwLCA4MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTcwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1MDAwMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgODAwMDAwMCwgMzApXG59O1xuLyoqXG4gKiBGb3VyIGJ5IHRocmVlIHByZXNldHNcbiAqL1xuY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjUwMDAsIDIwKSxcbiAgaDI0MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMjQwLCAxNDAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzAwMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDcyMCwgNTQwLCA2MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxMzAwMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTQ0MCwgMTA4MCwgMjMwMDAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDM4MDAwMDAsIDMwKVxufTtcbmNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwMDAwLCAzLCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA0MDAwMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDIwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNDAwMDAwMCwgMzAsICdtZWRpdW0nKVxufTtcblxuLy8gQ29weXJpZ2h0IDIwMjMgTGl2ZUtpdCwgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TaWduYWxUYXJnZXRcbiAqL1xudmFyIFNpZ25hbFRhcmdldDtcbihmdW5jdGlvbiAoU2lnbmFsVGFyZ2V0KSB7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogUFVCTElTSEVSID0gMDtcbiAgICovXG4gIFNpZ25hbFRhcmdldFtTaWduYWxUYXJnZXRbXCJQVUJMSVNIRVJcIl0gPSAwXSA9IFwiUFVCTElTSEVSXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogU1VCU0NSSUJFUiA9IDE7XG4gICAqL1xuICBTaWduYWxUYXJnZXRbU2lnbmFsVGFyZ2V0W1wiU1VCU0NSSUJFUlwiXSA9IDFdID0gXCJTVUJTQ1JJQkVSXCI7XG59KShTaWduYWxUYXJnZXQgfHwgKFNpZ25hbFRhcmdldCA9IHt9KSk7XG4vLyBSZXRyaWV2ZSBlbnVtIG1ldGFkYXRhIHdpdGg6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTaWduYWxUYXJnZXQsIFwibGl2ZWtpdC5TaWduYWxUYXJnZXRcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUFVCTElTSEVSXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiU1VCU0NSSUJFUlwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU3RyZWFtU3RhdGVcbiAqL1xudmFyIFN0cmVhbVN0YXRlO1xuKGZ1bmN0aW9uIChTdHJlYW1TdGF0ZSkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IEFDVElWRSA9IDA7XG4gICAqL1xuICBTdHJlYW1TdGF0ZVtTdHJlYW1TdGF0ZVtcIkFDVElWRVwiXSA9IDBdID0gXCJBQ1RJVkVcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBQQVVTRUQgPSAxO1xuICAgKi9cbiAgU3RyZWFtU3RhdGVbU3RyZWFtU3RhdGVbXCJQQVVTRURcIl0gPSAxXSA9IFwiUEFVU0VEXCI7XG59KShTdHJlYW1TdGF0ZSB8fCAoU3RyZWFtU3RhdGUgPSB7fSkpO1xuLy8gUmV0cmlldmUgZW51bSBtZXRhZGF0YSB3aXRoOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXG5wcm90bzMudXRpbC5zZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSwgXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFDVElWRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlBBVVNFRFwiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcbiAqL1xudmFyIENhbmRpZGF0ZVByb3RvY29sO1xuKGZ1bmN0aW9uIChDYW5kaWRhdGVQcm90b2NvbCkge1xuICAvKipcbiAgICogQGdlbmVyYXRlZCBmcm9tIGVudW0gdmFsdWU6IFVEUCA9IDA7XG4gICAqL1xuICBDYW5kaWRhdGVQcm90b2NvbFtDYW5kaWRhdGVQcm90b2NvbFtcIlVEUFwiXSA9IDBdID0gXCJVRFBcIjtcbiAgLyoqXG4gICAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIHZhbHVlOiBUQ1AgPSAxO1xuICAgKi9cbiAgQ2FuZGlkYXRlUHJvdG9jb2xbQ2FuZGlkYXRlUHJvdG9jb2xbXCJUQ1BcIl0gPSAxXSA9IFwiVENQXCI7XG4gIC8qKlxuICAgKiBAZ2VuZXJhdGVkIGZyb20gZW51bSB2YWx1ZTogVExTID0gMjtcbiAgICovXG4gIENhbmRpZGF0ZVByb3RvY29sW0NhbmRpZGF0ZVByb3RvY29sW1wiVExTXCJdID0gMl0gPSBcIlRMU1wiO1xufSkoQ2FuZGlkYXRlUHJvdG9jb2wgfHwgKENhbmRpZGF0ZVByb3RvY29sID0ge30pKTtcbi8vIFJldHJpZXZlIGVudW0gbWV0YWRhdGEgd2l0aDogcHJvdG8zLmdldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sKVxucHJvdG8zLnV0aWwuc2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wsIFwibGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVRFBcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJUQ1BcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJUTFNcIlxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpZ25hbFJlcXVlc3RcbiAqL1xuY2xhc3MgU2lnbmFsUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5TaWduYWxSZXF1ZXN0Lm1lc3NhZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNpZ25hbFJlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5TaWduYWxSZXF1ZXN0LnJ1bnRpbWUgPSBwcm90bzM7XG5TaWduYWxSZXF1ZXN0LnR5cGVOYW1lID0gXCJsaXZla2l0LlNpZ25hbFJlcXVlc3RcIjtcblNpZ25hbFJlcXVlc3QuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYWRkX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBZGRUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJ0cmFja19zZXR0aW5nXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVUcmFja1NldHRpbmdzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibGVhdmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IExlYXZlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ1cGRhdGVfbGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVWaWRlb0xheWVycyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzeW5jX3N0YXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTeW5jU3RhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2ltdWxhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsYXRlU2NlbmFyaW8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwicGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcInBpbmdfcmVxXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQaW5nLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaWduYWxSZXNwb25zZVxuICovXG5jbGFzcyBTaWduYWxSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5TaWduYWxSZXNwb25zZS5tZXNzYWdlXG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0ge1xuICAgICAgY2FzZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2lnbmFsUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxSZXNwb25zZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpZ25hbFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTaWduYWxSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblNpZ25hbFJlc3BvbnNlLnJ1bnRpbWUgPSBwcm90bzM7XG5TaWduYWxSZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TaWduYWxSZXNwb25zZVwiO1xuU2lnbmFsUmVzcG9uc2UuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImpvaW5cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEpvaW5SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInRyYWNrX3B1Ymxpc2hlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImxlYXZlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBMZWF2ZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInNwZWFrZXJzX2NoYW5nZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJzQ2hhbmdlZCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJyb29tX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJjb25uZWN0aW9uX3F1YWxpdHlcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJyZWZyZXNoX3Rva2VuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJwb25nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOSxcbiAgbmFtZTogXCJyZWNvbm5lY3RcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlY29ubmVjdFJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDIwLFxuICBuYW1lOiBcInBvbmdfcmVzcFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUG9uZyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcmVzcG9uc2VcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmlwdGlvblJlc3BvbnNlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY1xuICovXG5jbGFzcyBTaW11bGNhc3RDb2RlYyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjb2RlYyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jb2RlYyA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgY2lkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmNpZCA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsY2FzdENvZGVjKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxjYXN0Q29kZWMoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGNhc3RDb2RlYygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxjYXN0Q29kZWMsIGEsIGIpO1xuICB9XG59XG5TaW11bGNhc3RDb2RlYy5ydW50aW1lID0gcHJvdG8zO1xuU2ltdWxjYXN0Q29kZWMudHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNcIjtcblNpbXVsY2FzdENvZGVjLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XG4gKi9cbmNsYXNzIEFkZFRyYWNrUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBjbGllbnQgSUQgb2YgdHJhY2ssIHRvIG1hdGNoIGl0IHdoZW4gUlRDIHRyYWNrIGlzIHJlY2VpdmVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBuYW1lID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1R5cGUgdHlwZSA9IDM7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gVHJhY2tUeXBlLkFVRElPO1xuICAgIC8qKlxuICAgICAqIHRvIGJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbGF5ZXJzXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDQ7XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gNTtcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogdHJ1ZSB0byBhZGQgdHJhY2sgYW5kIGluaXRpYWxpemUgdG8gbXV0ZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBtdXRlZCA9IDY7XG4gICAgICovXG4gICAgdGhpcy5tdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgRFRYIChEaXNjb250aW51b3VzIFRyYW5zbWlzc2lvbikgaXMgZGlzYWJsZWQgZm9yIGF1ZGlvXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZV9kdHggPSA3O1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZUR0eCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5UcmFja1NvdXJjZSBzb3VyY2UgPSA4O1xuICAgICAqL1xuICAgIHRoaXMuc291cmNlID0gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVmlkZW9MYXllciBsYXllcnMgPSA5O1xuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlNpbXVsY2FzdENvZGVjIHNpbXVsY2FzdF9jb2RlY3MgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIHNlcnZlciBJRCBvZiB0cmFjaywgcHVibGlzaCBuZXcgY29kZWMgdG8gZXhpc3QgdHJhY2tcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHNpZCA9IDExO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgc3RlcmVvID0gMTI7XG4gICAgICovXG4gICAgdGhpcy5zdGVyZW8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIFJFRCAoUmVkdW5kYW50IEVuY29kaW5nKSBpcyBkaXNhYmxlZCBmb3IgYXVkaW9cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBkaXNhYmxlX3JlZCA9IDEzO1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZVJlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGUgZW5jcnlwdGlvbiA9IDE0O1xuICAgICAqL1xuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIC8qKlxuICAgICAqIHdoaWNoIHN0cmVhbSB0aGUgdHJhY2sgYmVsb25ncyB0bywgdXNlZCB0byBncm91cCB0cmFja3MgdG9nZXRoZXIuXG4gICAgICogaWYgbm90IHNwZWNpZmllZCwgc2VydmVyIHdpbGwgaW5mZXIgaXQgZnJvbSB0cmFjayBzb3VyY2UgdG8gYnVuZGxlIGNhbWVyYS9taWNyb3Bob25lLCBzY3JlZW5zaGFyZS9hdWRpbyB0b2dldGhlclxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc3RyZWFtID0gMTU7XG4gICAgICovXG4gICAgdGhpcy5zdHJlYW0gPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBZGRUcmFja1JlcXVlc3QoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKEFkZFRyYWNrUmVxdWVzdCwgYSwgYik7XG4gIH1cbn1cbkFkZFRyYWNrUmVxdWVzdC5ydW50aW1lID0gcHJvdG8zO1xuQWRkVHJhY2tSZXF1ZXN0LnR5cGVOYW1lID0gXCJsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFwiO1xuQWRkVHJhY2tSZXF1ZXN0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwid2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInNvdXJjZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJzaW11bGNhc3RfY29kZWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTaW11bGNhc3RDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzdGVyZW9cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3RyZWFtXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Ucmlja2xlUmVxdWVzdFxuICovXG5jbGFzcyBUcmlja2xlUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjYW5kaWRhdGVJbml0ID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmNhbmRpZGF0ZUluaXQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TaWduYWxUYXJnZXQgdGFyZ2V0ID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IFNpZ25hbFRhcmdldC5QVUJMSVNIRVI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyaWNrbGVSZXF1ZXN0KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJpY2tsZVJlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmlja2xlUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJpY2tsZVJlcXVlc3QsIGEsIGIpO1xuICB9XG59XG5Ucmlja2xlUmVxdWVzdC5ydW50aW1lID0gcHJvdG8zO1xuVHJpY2tsZVJlcXVlc3QudHlwZU5hbWUgPSBcImxpdmVraXQuVHJpY2tsZVJlcXVlc3RcIjtcblRyaWNrbGVSZXF1ZXN0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcbiAqL1xuY2xhc3MgTXV0ZVRyYWNrUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgbXV0ZWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMubXV0ZWQgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE11dGVUcmFja1JlcXVlc3QoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNdXRlVHJhY2tSZXF1ZXN0KCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhNdXRlVHJhY2tSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuTXV0ZVRyYWNrUmVxdWVzdC5ydW50aW1lID0gcHJvdG8zO1xuTXV0ZVRyYWNrUmVxdWVzdC50eXBlTmFtZSA9IFwibGl2ZWtpdC5NdXRlVHJhY2tSZXF1ZXN0XCI7XG5NdXRlVHJhY2tSZXF1ZXN0LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkpvaW5SZXNwb25zZVxuICovXG5jbGFzcyBKb2luUmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlBhcnRpY2lwYW50SW5mbyBvdGhlcl9wYXJ0aWNpcGFudHMgPSAzO1xuICAgICAqL1xuICAgIHRoaXMub3RoZXJQYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBkZXByZWNhdGVkLiB1c2Ugc2VydmVyX2luZm8udmVyc2lvbiBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgc2VydmVyX3ZlcnNpb24gPSA0O1xuICAgICAqL1xuICAgIHRoaXMuc2VydmVyVmVyc2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LklDRVNlcnZlciBpY2Vfc2VydmVycyA9IDU7XG4gICAgICovXG4gICAgdGhpcy5pY2VTZXJ2ZXJzID0gW107XG4gICAgLyoqXG4gICAgICogdXNlIHN1YnNjcmliZXIgYXMgdGhlIHByaW1hcnkgUGVlckNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBzdWJzY3JpYmVyX3ByaW1hcnkgPSA2O1xuICAgICAqL1xuICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB3aGVuIHRoZSBjdXJyZW50IHNlcnZlciBpc24ndCBhdmFpbGFibGUsIHJldHVybiBhbHRlcm5hdGUgdXJsIHRvIHJldHJ5IGNvbm5lY3Rpb25cbiAgICAgKiB3aGVuIHRoaXMgaXMgc2V0LCB0aGUgb3RoZXIgZmllbGRzIHdpbGwgYmUgbGFyZ2VseSBlbXB0eVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgYWx0ZXJuYXRpdmVfdXJsID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmFsdGVybmF0aXZlVXJsID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBkZXByZWNhdGVkLiB1c2Ugc2VydmVyX2luZm8ucmVnaW9uIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZXJ2ZXJfcmVnaW9uID0gOTtcbiAgICAgKi9cbiAgICB0aGlzLnNlcnZlclJlZ2lvbiA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBwaW5nX3RpbWVvdXQgPSAxMDtcbiAgICAgKi9cbiAgICB0aGlzLnBpbmdUaW1lb3V0ID0gMDtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIHBpbmdfaW50ZXJ2YWwgPSAxMTtcbiAgICAgKi9cbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IDA7XG4gICAgLyoqXG4gICAgICogU2VydmVyLUluamVjdGVkLUZyYW1lIGJ5dGUgdHJhaWxlciwgdXNlZCB0byBpZGVudGlmeSB1bmVuY3J5cHRlZCBmcmFtZXMgd2hlbiBlMmVlIGlzIGVuYWJsZWRcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYnl0ZXMgc2lmX3RyYWlsZXIgPSAxMztcbiAgICAgKi9cbiAgICB0aGlzLnNpZlRyYWlsZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSm9pblJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSm9pblJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgSm9pblJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhKb2luUmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5Kb2luUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcbkpvaW5SZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5Kb2luUmVzcG9uc2VcIjtcbkpvaW5SZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbSQxXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlcnZlcl92ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IElDRVNlcnZlcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaWJlcl9wcmltYXJ5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImFsdGVybmF0aXZlX3VybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInNlcnZlcl9yZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwicGluZ190aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInNlcnZlcl9pbmZvXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXJ2ZXJJbmZvXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJzaWZfdHJhaWxlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMiAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVjb25uZWN0UmVzcG9uc2VcbiAqL1xuY2xhc3MgUmVjb25uZWN0UmVzcG9uc2UgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LklDRVNlcnZlciBpY2Vfc2VydmVycyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5pY2VTZXJ2ZXJzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlY29ubmVjdFJlc3BvbnNlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVjb25uZWN0UmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWNvbm5lY3RSZXNwb25zZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUmVjb25uZWN0UmVzcG9uc2UsIGEsIGIpO1xuICB9XG59XG5SZWNvbm5lY3RSZXNwb25zZS5ydW50aW1lID0gcHJvdG8zO1xuUmVjb25uZWN0UmVzcG9uc2UudHlwZU5hbWUgPSBcImxpdmVraXQuUmVjb25uZWN0UmVzcG9uc2VcIjtcblJlY29ubmVjdFJlc3BvbnNlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogSUNFU2VydmVyLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjbGllbnRfY29uZmlndXJhdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2xpZW50Q29uZmlndXJhdGlvblxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcbiAqL1xuY2xhc3MgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY2lkID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS5ydW50aW1lID0gcHJvdG8zO1xuVHJhY2tQdWJsaXNoZWRSZXNwb25zZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlXCI7XG5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXG4gKi9cbmNsYXNzIFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSwgYSwgYik7XG4gIH1cbn1cblRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZS5ydW50aW1lID0gcHJvdG8zO1xuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVwiO1xuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblxuICovXG5jbGFzcyBTZXNzaW9uRGVzY3JpcHRpb24gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogXCJhbnN3ZXJcIiB8IFwib2ZmZXJcIiB8IFwicHJhbnN3ZXJcIiB8IFwicm9sbGJhY2tcIlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHlwZSA9IDE7XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBzZHAgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuc2RwID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkRlc2NyaXB0aW9uKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTZXNzaW9uRGVzY3JpcHRpb24sIGEsIGIpO1xuICB9XG59XG5TZXNzaW9uRGVzY3JpcHRpb24ucnVudGltZSA9IHByb3RvMztcblNlc3Npb25EZXNjcmlwdGlvbi50eXBlTmFtZSA9IFwibGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb25cIjtcblNlc3Npb25EZXNjcmlwdGlvbi5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInNkcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcbiAqL1xuY2xhc3MgUGFydGljaXBhbnRVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlBhcnRpY2lwYW50SW5mbyBwYXJ0aWNpcGFudHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpY2lwYW50VXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFydGljaXBhbnRVcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aWNpcGFudFVwZGF0ZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGFydGljaXBhbnRVcGRhdGUsIGEsIGIpO1xuICB9XG59XG5QYXJ0aWNpcGFudFVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuUGFydGljaXBhbnRVcGRhdGUudHlwZU5hbWUgPSBcImxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcIjtcblBhcnRpY2lwYW50VXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cbiAqL1xuY2xhc3MgVXBkYXRlU3Vic2NyaXB0aW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHRyYWNrX3NpZHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWRzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIHN1YnNjcmliZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuUGFydGljaXBhbnRUcmFja3MgcGFydGljaXBhbnRfdHJhY2tzID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tzID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlU3Vic2NyaXB0aW9uLCBhLCBiKTtcbiAgfVxufVxuVXBkYXRlU3Vic2NyaXB0aW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5VcGRhdGVTdWJzY3JpcHRpb24udHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXCI7XG5VcGRhdGVTdWJzY3JpcHRpb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwic3Vic2NyaWJlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3RyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRUcmFja3MsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlVHJhY2tTZXR0aW5nc1xuICovXG5jbGFzcyBVcGRhdGVUcmFja1NldHRpbmdzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHRyYWNrX3NpZHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWRzID0gW107XG4gICAgLyoqXG4gICAgICogd2hlbiB0cnVlLCB0aGUgdHJhY2sgaXMgcGxhY2VkIGluIGEgcGF1c2VkIHN0YXRlLCB3aXRoIG5vIG5ldyBkYXRhIHJldHVybmVkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZGlzYWJsZWQgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHdpZHRoICYgaGVpZ2h0XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSA0O1xuICAgICAqL1xuICAgIHRoaXMucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgLyoqXG4gICAgICogZm9yIHZpZGVvLCB3aWR0aCB0byByZWNlaXZlXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiB3aWR0aCA9IDU7XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqXG4gICAgICogZm9yIHZpZGVvLCBoZWlnaHQgdG8gcmVjZWl2ZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaGVpZ2h0ID0gNjtcbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgZnBzID0gNztcbiAgICAgKi9cbiAgICB0aGlzLmZwcyA9IDA7XG4gICAgLyoqXG4gICAgICogc3Vic2NyaXB0aW9uIHByaW9yaXR5LiAxIGJlaW5nIHRoZSBoaWdoZXN0ICgwIGlzIHVuc2V0KVxuICAgICAqIHdoZW4gdW5zZXQsIHNlcnZlciBzaWxsIGFzc2lnbiBwcmlvcml0eSBiYXNlZCBvbiB0aGUgb3JkZXIgb2Ygc3Vic2NyaXB0aW9uXG4gICAgICogc2VydmVyIHdpbGwgdXNlIHByaW9yaXR5IGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAgICAgKiAxLiB3aGVuIHN1YnNjcmliZWQgdHJhY2tzIGV4Y2VlZCBwZXItcGFydGljaXBhbnQgc3Vic2NyaXB0aW9uIGxpbWl0LCBzZXJ2ZXIgd2lsbFxuICAgICAqICAgIHBhdXNlIHRoZSBsb3dlc3QgcHJpb3JpdHkgdHJhY2tzXG4gICAgICogMi4gd2hlbiB0aGUgbmV0d29yayBpcyBjb25nZXN0ZWQsIHNlcnZlciB3aWxsIGFzc2lnbiBhdmFpbGFibGUgYmFuZHdpZHRoIHRvXG4gICAgICogICAgaGlnaGVyIHByaW9yaXR5IHRyYWNrcyBmaXJzdC4gbG93ZXN0IHByaW9yaXR5IHRyYWNrcyBjYW4gYmUgcGF1c2VkXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHVpbnQzMiBwcmlvcml0eSA9IDg7XG4gICAgICovXG4gICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3MoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVXBkYXRlVHJhY2tTZXR0aW5ncywgYSwgYik7XG4gIH1cbn1cblVwZGF0ZVRyYWNrU2V0dGluZ3MucnVudGltZSA9IHByb3RvMztcblVwZGF0ZVRyYWNrU2V0dGluZ3MudHlwZU5hbWUgPSBcImxpdmVraXQuVXBkYXRlVHJhY2tTZXR0aW5nc1wiO1xuVXBkYXRlVHJhY2tTZXR0aW5ncy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkaXNhYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZnBzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcInByaW9yaXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuTGVhdmVSZXF1ZXN0XG4gKi9cbmNsYXNzIExlYXZlUmVxdWVzdCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBzZW50IHdoZW4gc2VydmVyIGluaXRpYXRlcyB0aGUgZGlzY29ubmVjdCBkdWUgdG8gc2VydmVyLXJlc3RhcnRcbiAgICAgKiBpbmRpY2F0ZXMgY2xpZW50cyBzaG91bGQgYXR0ZW1wdCBmdWxsLXJlY29ubmVjdCBzZXF1ZW5jZVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBib29sIGNhbl9yZWNvbm5lY3QgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuY2FuUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb24gcmVhc29uID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnJlYXNvbiA9IERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExlYXZlUmVxdWVzdCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExlYXZlUmVxdWVzdCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExlYXZlUmVxdWVzdCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoTGVhdmVSZXF1ZXN0LCBhLCBiKTtcbiAgfVxufVxuTGVhdmVSZXF1ZXN0LnJ1bnRpbWUgPSBwcm90bzM7XG5MZWF2ZVJlcXVlc3QudHlwZU5hbWUgPSBcImxpdmVraXQuTGVhdmVSZXF1ZXN0XCI7XG5MZWF2ZVJlcXVlc3QuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbl9yZWNvbm5lY3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicmVhc29uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbilcbn1dKTtcbi8qKlxuICogbWVzc2FnZSB0byBpbmRpY2F0ZSBwdWJsaXNoZWQgdmlkZW8gdHJhY2sgZGltZW5zaW9ucyBhcmUgY2hhbmdpbmdcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVZpZGVvTGF5ZXJzXG4gKi9cbmNsYXNzIFVwZGF0ZVZpZGVvTGF5ZXJzIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlZpZGVvTGF5ZXIgbGF5ZXJzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVWaWRlb0xheWVycygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFVwZGF0ZVZpZGVvTGF5ZXJzLCBhLCBiKTtcbiAgfVxufVxuVXBkYXRlVmlkZW9MYXllcnMucnVudGltZSA9IHByb3RvMztcblVwZGF0ZVZpZGVvTGF5ZXJzLnR5cGVOYW1lID0gXCJsaXZla2l0LlVwZGF0ZVZpZGVvTGF5ZXJzXCI7XG5VcGRhdGVWaWRlb0xheWVycy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBWaWRlb0xheWVyLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcbiAqL1xuY2xhc3MgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBtZXRhZGF0YSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5tZXRhZGF0YSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgbmFtZSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLCBhLCBiKTtcbiAgfVxufVxuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YS5ydW50aW1lID0gcHJvdG8zO1xuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YS50eXBlTmFtZSA9IFwibGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhXCI7XG5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LklDRVNlcnZlclxuICovXG5jbGFzcyBJQ0VTZXJ2ZXIgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBzdHJpbmcgdXJscyA9IDE7XG4gICAgICovXG4gICAgdGhpcy51cmxzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdXNlcm5hbWUgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudXNlcm5hbWUgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIGNyZWRlbnRpYWwgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuY3JlZGVudGlhbCA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IElDRVNlcnZlcigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoSUNFU2VydmVyLCBhLCBiKTtcbiAgfVxufVxuSUNFU2VydmVyLnJ1bnRpbWUgPSBwcm90bzM7XG5JQ0VTZXJ2ZXIudHlwZU5hbWUgPSBcImxpdmVraXQuSUNFU2VydmVyXCI7XG5JQ0VTZXJ2ZXIuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVybHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidXNlcm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjcmVkZW50aWFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcbiAqL1xuY2xhc3MgU3BlYWtlcnNDaGFuZ2VkIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5TcGVha2VySW5mbyBzcGVha2VycyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5zcGVha2VycyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2Vyc0NoYW5nZWQoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2Vyc0NoYW5nZWQoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVha2Vyc0NoYW5nZWQoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFNwZWFrZXJzQ2hhbmdlZCwgYSwgYik7XG4gIH1cbn1cblNwZWFrZXJzQ2hhbmdlZC5ydW50aW1lID0gcHJvdG8zO1xuU3BlYWtlcnNDaGFuZ2VkLnR5cGVOYW1lID0gXCJsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFwiO1xuU3BlYWtlcnNDaGFuZ2VkLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2Vyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlckluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUm9vbVVwZGF0ZVxuICovXG5jbGFzcyBSb29tVXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSb29tVXBkYXRlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUm9vbVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJvb21VcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJvb21VcGRhdGUsIGEsIGIpO1xuICB9XG59XG5Sb29tVXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5Sb29tVXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlJvb21VcGRhdGVcIjtcblJvb21VcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1xuICovXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUluZm8gZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHkgcXVhbGl0eSA9IDI7XG4gICAgICovXG4gICAgdGhpcy5xdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkkMS5QT09SO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogZmxvYXQgc2NvcmUgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuc2NvcmUgPSAwO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eUluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKENvbm5lY3Rpb25RdWFsaXR5SW5mbywgYSwgYik7XG4gIH1cbn1cbkNvbm5lY3Rpb25RdWFsaXR5SW5mby5ydW50aW1lID0gcHJvdG8zO1xuQ29ubmVjdGlvblF1YWxpdHlJbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1wiO1xuQ29ubmVjdGlvblF1YWxpdHlJbmZvLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkkMSlcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic2NvcmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcbiAqL1xuY2xhc3MgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mbyB1cGRhdGVzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cbkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiO1xuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInVwZGF0ZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cbiAqL1xuY2xhc3MgU3RyZWFtU3RhdGVJbmZvIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHBhcnRpY2lwYW50X3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgdHJhY2tfc2lkID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrU2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGxpdmVraXQuU3RyZWFtU3RhdGUgc3RhdGUgPSAzO1xuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBTdHJlYW1TdGF0ZS5BQ1RJVkU7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3RyZWFtU3RhdGVJbmZvLCBhLCBiKTtcbiAgfVxufVxuU3RyZWFtU3RhdGVJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5TdHJlYW1TdGF0ZUluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXCI7XG5TdHJlYW1TdGF0ZUluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInN0YXRlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcbiAqL1xuY2xhc3MgU3RyZWFtU3RhdGVVcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN0cmVhbVN0YXRlSW5mbyBzdHJlYW1fc3RhdGVzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnN0cmVhbVN0YXRlcyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1TdGF0ZVVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVN0YXRlVXBkYXRlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtU3RhdGVVcGRhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN0cmVhbVN0YXRlVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuU3RyZWFtU3RhdGVVcGRhdGUucnVudGltZSA9IHByb3RvMztcblN0cmVhbVN0YXRlVXBkYXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN0cmVhbVN0YXRlVXBkYXRlXCI7XG5TdHJlYW1TdGF0ZVVwZGF0ZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtU3RhdGVJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5XG4gKi9cbmNsYXNzIFN1YnNjcmliZWRRdWFsaXR5IGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5WaWRlb1F1YWxpdHkgcXVhbGl0eSA9IDE7XG4gICAgICovXG4gICAgdGhpcy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkxPVztcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGJvb2wgZW5hYmxlZCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5KCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHkoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU3Vic2NyaWJlZFF1YWxpdHksIGEsIGIpO1xuICB9XG59XG5TdWJzY3JpYmVkUXVhbGl0eS5ydW50aW1lID0gcHJvdG8zO1xuU3Vic2NyaWJlZFF1YWxpdHkudHlwZU5hbWUgPSBcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcIjtcblN1YnNjcmliZWRRdWFsaXR5LmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlbmFibGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZENvZGVjXG4gKi9cbmNsYXNzIFN1YnNjcmliZWRDb2RlYyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBjb2RlYyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5jb2RlYyA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5IHF1YWxpdGllcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5xdWFsaXRpZXMgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZENvZGVjKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpYmVkQ29kZWMsIGEsIGIpO1xuICB9XG59XG5TdWJzY3JpYmVkQ29kZWMucnVudGltZSA9IHByb3RvMztcblN1YnNjcmliZWRDb2RlYy50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIjtcblN1YnNjcmliZWRDb2RlYy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJxdWFsaXRpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXG4gKi9cbmNsYXNzIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5IHN1YnNjcmliZWRfcXVhbGl0aWVzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmliZWRRdWFsaXRpZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuU3Vic2NyaWJlZENvZGVjIHN1YnNjcmliZWRfY29kZWNzID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnN1YnNjcmliZWRDb2RlY3MgPSBbXTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgYSwgYik7XG4gIH1cbn1cblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0aWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1Blcm1pc3Npb25cbiAqL1xuY2xhc3MgVHJhY2tQZXJtaXNzaW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHBlcm1pc3Npb24gY291bGQgYmUgZ3JhbnRlZCBlaXRoZXIgYnkgcGFydGljaXBhbnQgc2lkIG9yIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBwYXJ0aWNpcGFudF9zaWQgPSAxO1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxfdHJhY2tzID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLmFsbFRyYWNrcyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgc3RyaW5nIHRyYWNrX3NpZHMgPSAzO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWRzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfaWRlbnRpdHkgPSA0O1xuICAgICAqL1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IFwiXCI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbigpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVHJhY2tQZXJtaXNzaW9uLCBhLCBiKTtcbiAgfVxufVxuVHJhY2tQZXJtaXNzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5UcmFja1Blcm1pc3Npb24udHlwZU5hbWUgPSBcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCI7XG5UcmFja1Blcm1pc3Npb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFsbF90cmFja3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblxuICovXG5jbGFzcyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxfcGFydGljaXBhbnRzID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmFsbFBhcnRpY2lwYW50cyA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogcmVwZWF0ZWQgbGl2ZWtpdC5UcmFja1Blcm1pc3Npb24gdHJhY2tfcGVybWlzc2lvbnMgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbigpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmlwdGlvblBlcm1pc3Npb24sIGEsIGIpO1xuICB9XG59XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uLnJ1bnRpbWUgPSBwcm90bzM7XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cIjtcblN1YnNjcmlwdGlvblBlcm1pc3Npb24uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFsbF9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfcGVybWlzc2lvbnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrUGVybWlzc2lvbixcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBzdHJpbmcgcGFydGljaXBhbnRfc2lkID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB0cmFja19zaWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudHJhY2tTaWQgPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogYm9vbCBhbGxvd2VkID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmFsbG93ZWQgPSBmYWxzZTtcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZS50eXBlTmFtZSA9IFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XG5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhbGxvd2VkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3luY1N0YXRlXG4gKi9cbmNsYXNzIFN5bmNTdGF0ZSBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHJlcGVhdGVkIGxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZSBwdWJsaXNoX3RyYWNrcyA9IDM7XG4gICAgICovXG4gICAgdGhpcy5wdWJsaXNoVHJhY2tzID0gW107XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LkRhdGFDaGFubmVsSW5mbyBkYXRhX2NoYW5uZWxzID0gNDtcbiAgICAgKi9cbiAgICB0aGlzLmRhdGFDaGFubmVscyA9IFtdO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTeW5jU3RhdGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN5bmNTdGF0ZSwgYSwgYik7XG4gIH1cbn1cblN5bmNTdGF0ZS5ydW50aW1lID0gcHJvdG8zO1xuU3luY1N0YXRlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN5bmNTdGF0ZVwiO1xuU3luY1N0YXRlLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvblxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvblxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwdWJsaXNoX3RyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGF0YV9jaGFubmVsc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YUNoYW5uZWxJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJvZmZlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXG4gKi9cbmNsYXNzIERhdGFDaGFubmVsSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyBsYWJlbCA9IDE7XG4gICAgICovXG4gICAgdGhpcy5sYWJlbCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiB1aW50MzIgaWQgPSAyO1xuICAgICAqL1xuICAgIHRoaXMuaWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogbGl2ZWtpdC5TaWduYWxUYXJnZXQgdGFyZ2V0ID0gMztcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IFNpZ25hbFRhcmdldC5QVUJMSVNIRVI7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFDaGFubmVsSW5mbygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFDaGFubmVsSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERhdGFDaGFubmVsSW5mbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoRGF0YUNoYW5uZWxJbmZvLCBhLCBiKTtcbiAgfVxufVxuRGF0YUNoYW5uZWxJbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5EYXRhQ2hhbm5lbEluZm8udHlwZU5hbWUgPSBcImxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXCI7XG5EYXRhQ2hhbm5lbEluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhYmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW9cbiAqL1xuY2xhc3MgU2ltdWxhdGVTY2VuYXJpbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gb25lb2YgbGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvLnNjZW5hcmlvXG4gICAgICovXG4gICAgdGhpcy5zY2VuYXJpbyA9IHtcbiAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNpbXVsYXRlU2NlbmFyaW8oKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW11bGF0ZVNjZW5hcmlvKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU2ltdWxhdGVTY2VuYXJpbygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoU2ltdWxhdGVTY2VuYXJpbywgYSwgYik7XG4gIH1cbn1cblNpbXVsYXRlU2NlbmFyaW8ucnVudGltZSA9IHByb3RvMztcblNpbXVsYXRlU2NlbmFyaW8udHlwZU5hbWUgPSBcImxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1wiO1xuU2ltdWxhdGVTY2VuYXJpby5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vZGVfZmFpbHVyZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtaWdyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2VydmVyX2xlYXZlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInN3aXRjaF9jYW5kaWRhdGVfcHJvdG9jb2xcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDYW5kaWRhdGVQcm90b2NvbCksXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaWJlcl9iYW5kd2lkdGhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGluZ1xuICovXG5jbGFzcyBQaW5nIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBydHQgaW4gbWlsbGlzZWNvbmRzIGNhbGN1bGF0ZWQgYnkgY2xpZW50XG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHJ0dCA9IDI7XG4gICAgICovXG4gICAgdGhpcy5ydHQgPSBwcm90b0ludDY0Lnplcm87XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBpbmcoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQaW5nKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGluZygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUGluZywgYSwgYik7XG4gIH1cbn1cblBpbmcucnVudGltZSA9IHByb3RvMztcblBpbmcudHlwZU5hbWUgPSBcImxpdmVraXQuUGluZ1wiO1xuUGluZy5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJydHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUG9uZ1xuICovXG5jbGFzcyBQb25nIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIHRpbWVzdGFtcCBmaWVsZCBvZiBsYXN0IHJlY2VpdmVkIHBpbmcgcmVxdWVzdFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBsYXN0X3BpbmdfdGltZXN0YW1wID0gMTtcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaW5nVGltZXN0YW1wID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgdGltZXN0YW1wID0gMjtcbiAgICAgKi9cbiAgICB0aGlzLnRpbWVzdGFtcCA9IHByb3RvSW50NjQuemVybztcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9uZygpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvbmcoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQb25nKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhQb25nLCBhLCBiKTtcbiAgfVxufVxuUG9uZy5ydW50aW1lID0gcHJvdG8zO1xuUG9uZy50eXBlTmFtZSA9IFwibGl2ZWtpdC5Qb25nXCI7XG5Qb25nLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYXN0X3BpbmdfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59XSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVnaW9uU2V0dGluZ3NcbiAqL1xuY2xhc3MgUmVnaW9uU2V0dGluZ3MgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiByZXBlYXRlZCBsaXZla2l0LlJlZ2lvbkluZm8gcmVnaW9ucyA9IDE7XG4gICAgICovXG4gICAgdGhpcy5yZWdpb25zID0gW107XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvblNldHRpbmdzKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uU2V0dGluZ3MoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25TZXR0aW5ncygpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoUmVnaW9uU2V0dGluZ3MsIGEsIGIpO1xuICB9XG59XG5SZWdpb25TZXR0aW5ncy5ydW50aW1lID0gcHJvdG8zO1xuUmVnaW9uU2V0dGluZ3MudHlwZU5hbWUgPSBcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIjtcblJlZ2lvblNldHRpbmdzLmZpZWxkcyA9IHByb3RvMy51dGlsLm5ld0ZpZWxkTGlzdCgoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZWdpb25zXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWdpb25JbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJlZ2lvbkluZm9cbiAqL1xuY2xhc3MgUmVnaW9uSW5mbyBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyByZWdpb24gPSAxO1xuICAgICAqL1xuICAgIHRoaXMucmVnaW9uID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IHN0cmluZyB1cmwgPSAyO1xuICAgICAqL1xuICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IGRpc3RhbmNlID0gMztcbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gcHJvdG9JbnQ2NC56ZXJvO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdpb25JbmZvKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUmVnaW9uSW5mbygpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ2lvbkluZm8oKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFJlZ2lvbkluZm8sIGEsIGIpO1xuICB9XG59XG5SZWdpb25JbmZvLnJ1bnRpbWUgPSBwcm90bzM7XG5SZWdpb25JbmZvLnR5cGVOYW1lID0gXCJsaXZla2l0LlJlZ2lvbkluZm9cIjtcblJlZ2lvbkluZm8uZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRpc3RhbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblJlc3BvbnNlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogc3RyaW5nIHRyYWNrX3NpZCA9IDE7XG4gICAgICovXG4gICAgdGhpcy50cmFja1NpZCA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yIGVyciA9IDI7XG4gICAgICovXG4gICAgdGhpcy5lcnIgPSBTdWJzY3JpcHRpb25FcnJvci5TRV9VTktOT1dOO1xuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25SZXNwb25zZSgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvblJlc3BvbnNlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uUmVzcG9uc2UoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gcHJvdG8zLnV0aWwuZXF1YWxzKFN1YnNjcmlwdGlvblJlc3BvbnNlLCBhLCBiKTtcbiAgfVxufVxuU3Vic2NyaXB0aW9uUmVzcG9uc2UucnVudGltZSA9IHByb3RvMztcblN1YnNjcmlwdGlvblJlc3BvbnNlLnR5cGVOYW1lID0gXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCI7XG5TdWJzY3JpcHRpb25SZXNwb25zZS5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiZXJyXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpXG59XSk7XG5cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cbn1cblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50cyA9IFtdO1xuY2xhc3MgVHJhY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxuICAgICAqL1xuICAgIHRoaXMuc3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XG4gICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5iYWNrZ3JvdW5kVGltZW91dCk7XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cbiAgICAgIC8vIHVwZGF0ZSBpbW1lZGlhdGVseSBpZiBpdCBjb21lcyBiYWNrIHRvIGZvY3VzXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVRyYWNrO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHVzZWQgZm9yIGtlZXAgbWVkaWFTdHJlYW0ncyBmaXJzdCBpZCwgc2luY2UgaXQncyBpZCBtaWdodCBjaGFuZ2VcbiAgICogaWYgd2UgZGlzYWJsZS9lbmFibGUgYSB0cmFja1xuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gcG9vbFxuICAgICAgICAgIHJlY3ljbGVkRWxlbWVudHMuc3BsaWNlKHJlY3ljbGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgIC8vIHRoZSBlbGVtZW50J3Mgc3JjT2JqZWN0IHdhcyBzZXQgdG8gc29tZXRoaW5nIGVsc2Ugb3V0IG9mIGJhbmQuXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgLy8gaGFuZGxlIGF1dG8gcGxheWJhY2sgZmFpbHVyZXNcbiAgICBjb25zdCBhbGxNZWRpYVN0cmVhbVRyYWNrcyA9IGVsZW1lbnQuc3JjT2JqZWN0LmdldFRyYWNrcygpO1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcbiAgICAvLyBtYW51YWxseSBwbGF5IG1lZGlhIHRvIGRldGVjdCBhdXRvIHBsYXliYWNrIHN0YXR1c1xuICAgIGVsZW1lbnQucGxheSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgLy8gY29tbW9ubHkgdHJpZ2dlcmVkIGJ5IGFub3RoZXIgYHBsYXlgIHJlcXVlc3QsIG9ubHkgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nLCBcIiBwbGF5YmFjayBhYm9ydGVkLCBsaWtlbHkgZHVlIHRvIG5ldyBwbGF5IHJlcXVlc3RcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiY291bGQgbm90IHBsYXliYWNrIFwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nKSwgZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBhdWRpbyBwbGF5YmFjayBpc24ndCBhbGxvd2VkIG1ha2Ugc3VyZSB3ZSBzdGlsbCBwbGF5IGJhY2sgdGhlIHZpZGVvXG4gICAgICBpZiAoaGFzQXVkaW8gJiYgZWxlbWVudCAmJiBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICd2aWRlbycpICYmIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBjYXRjaCBmb3IgU2FmYXJpLCBleGNlZWRlZCBvcHRpb25zIGF0IHRoaXMgcG9pbnQgdG8gYXV0b21hdGljYWxseSBwbGF5IHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXRhY2hlZCA9IFtdO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxtID0+IHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xuICAgICAgICBkZXRhY2hlZC5wdXNoKGVsbSk7XG4gICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxtKTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbG0pO1xuICAgICAgfSk7XG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0b3BNb25pdG9yKCkge1xuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JJbnRlcnZhbCk7XG4gICAgfVxuICB9XG4gIHJlY3ljbGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byByZS11c2UgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgbGV0IHNob3VsZENhY2hlID0gdHJ1ZTtcbiAgICAgIGVsZW1lbnQucGF1c2UoKTtcbiAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgaWYgKCFlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICB9KTtcbiAgfVxuICBhZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRvRWxlbWVudCh0cmFjaywgZWxlbWVudCkge1xuICBsZXQgbWVkaWFTdHJlYW07XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgfSBlbHNlIHtcbiAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICB9XG4gIC8vIGNoZWNrIGlmIHRyYWNrIG1hdGNoZXMgZXhpc3RpbmcgdHJhY2tcbiAgbGV0IGV4aXN0aW5nVHJhY2tzO1xuICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgfSBlbHNlIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gIH1cbiAgaWYgKCFleGlzdGluZ1RyYWNrcy5pbmNsdWRlcyh0cmFjaykpIHtcbiAgICBleGlzdGluZ1RyYWNrcy5mb3JFYWNoKGV0ID0+IHtcbiAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGV0KTtcbiAgICB9KTtcbiAgICBtZWRpYVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgaWYgKCFpc1NhZmFyaSgpIHx8ICEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgLy8gd2hlbiBpbiBsb3cgcG93ZXIgbW9kZSAoYXBwbGllcyB0byBib3RoIG1hY09TIGFuZCBpT1MpLCBTYWZhcmkgd2lsbCBzaG93IGEgcGxheS9wYXVzZSBvdmVybGF5XG4gICAgLy8gd2hlbiBhIHZpZGVvIHN0YXJ0cyB0aGF0IGhhcyB0aGUgYGF1dG9wbGF5YCBhdHRyaWJ1dGUgaXMgc2V0LlxuICAgIC8vIHdlIHdvcmsgYXJvdW5kIHRoaXMgYnkgX25vdF8gc2V0dGluZyB0aGUgYXV0b3BsYXkgYXR0cmlidXRlIG9uIHNhZmFyaSBhbmQgaW5zdGVhZCBjYWxsIGBzZXRUaW1lb3V0KCgpID0+IGVsLnBsYXkoKSwwKWAgZnVydGhlciBkb3duXG4gICAgZWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gIH1cbiAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgbm8gYXVkaW8gdHJhY2tzIHByZXNlbnQgb24gdGhlIG1lZGlhc3RyZWFtLCB3ZSBzZXQgdGhlIGVsZW1lbnQgYXMgbXV0ZWQgdG8gZW5zdXJlIGF1dG9wbGF5IHdvcmtzXG4gIGVsZW1lbnQubXV0ZWQgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA9PT0gMDtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gIH1cbiAgLy8gYXZvaWQgZmxpY2tlclxuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgIT09IG1lZGlhU3RyZWFtKSB7XG4gICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICBpZiAoKGlzU2FmYXJpKCkgfHwgaXNGaXJlRm94KCkpICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAvLyBGaXJlZm94IGFsc28gaGFzIGEgdGltaW5nIGlzc3VlIHdoZXJlIHZpZGVvIGRvZXNuJ3QgYWN0dWFsbHkgZ2V0IGF0dGFjaGVkIHVubGVzc1xuICAgICAgLy8gcGVyZm9ybWVkIG91dC1vZi1iYW5kXG4gICAgICAvLyBTYWZhcmkgMTUgaGFzIGEgYnVnIHdoZXJlIGluIGNlcnRhaW4gbGF5b3V0cywgdmlkZW8gZWxlbWVudCByZW5kZXJzXG4gICAgICAvLyBibGFjayB1bnRpbCB0aGUgcGFnZSBpcyByZXNpemVkIG9yIG90aGVyIGNoYW5nZXMgdGFrZSBwbGFjZS5cbiAgICAgIC8vIFJlc2V0dGluZyB0aGUgc3JjIHRyaWdnZXJzIGl0IHRvIHJlbmRlci5cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb3J1bXMvdGhyZWFkLzY5MDUyM1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIC8vIFNhZmFyaSAxNSBzb21ldGltZXMgZmFpbHMgdG8gc3RhcnQgYSB2aWRlb1xuICAgICAgICAvLyB3aGVuIHRoZSB3aW5kb3cgaXMgYmFja2dyb3VuZGVkIGJlZm9yZSB0aGUgZmlyc3QgZnJhbWUgaXMgZHJhd25cbiAgICAgICAgLy8gbWFudWFsbHkgY2FsbGluZyBwbGF5IGhlcmUgc2VlbXMgdG8gZml4IHRoYXRcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8qKiBkbyBub3RoaW5nICovXG4gICAgICAgIH0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBkZXRhY2hUcmFjayh0cmFjaywgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgIGlmIChtZWRpYVN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG4oZnVuY3Rpb24gKFRyYWNrKSB7XG4gIGxldCBLaW5kO1xuICAoZnVuY3Rpb24gKEtpbmQpIHtcbiAgICBLaW5kW1wiQXVkaW9cIl0gPSBcImF1ZGlvXCI7XG4gICAgS2luZFtcIlZpZGVvXCJdID0gXCJ2aWRlb1wiO1xuICAgIEtpbmRbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKEtpbmQgPSBUcmFjay5LaW5kIHx8IChUcmFjay5LaW5kID0ge30pKTtcbiAgbGV0IFNvdXJjZTtcbiAgKGZ1bmN0aW9uIChTb3VyY2UpIHtcbiAgICBTb3VyY2VbXCJDYW1lcmFcIl0gPSBcImNhbWVyYVwiO1xuICAgIFNvdXJjZVtcIk1pY3JvcGhvbmVcIl0gPSBcIm1pY3JvcGhvbmVcIjtcbiAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZVwiXSA9IFwic2NyZWVuX3NoYXJlXCI7XG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVBdWRpb1wiXSA9IFwic2NyZWVuX3NoYXJlX2F1ZGlvXCI7XG4gICAgU291cmNlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShTb3VyY2UgPSBUcmFjay5Tb3VyY2UgfHwgKFRyYWNrLlNvdXJjZSA9IHt9KSk7XG4gIGxldCBTdHJlYW1TdGF0ZSQxO1xuICAoZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XG4gICAgU3RyZWFtU3RhdGVbXCJBY3RpdmVcIl0gPSBcImFjdGl2ZVwiO1xuICAgIFN0cmVhbVN0YXRlW1wiUGF1c2VkXCJdID0gXCJwYXVzZWRcIjtcbiAgICBTdHJlYW1TdGF0ZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoU3RyZWFtU3RhdGUkMSA9IFRyYWNrLlN0cmVhbVN0YXRlIHx8IChUcmFjay5TdHJlYW1TdGF0ZSA9IHt9KSk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24ga2luZFRvUHJvdG8oaykge1xuICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBLaW5kLkF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgY2FzZSBLaW5kLlZpZGVvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUUgdGhpcyB3YXMgVU5SRUNPR05JWkVEIGJlZm9yZVxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XG4gICAgfVxuICB9XG4gIFRyYWNrLmtpbmRUb1Byb3RvID0ga2luZFRvUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24ga2luZEZyb21Qcm90byh0KSB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuQXVkaW87XG4gICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuVmlkZW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gS2luZC5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5raW5kRnJvbVByb3RvID0ga2luZEZyb21Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBzb3VyY2VUb1Byb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgU291cmNlLkNhbWVyYTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLkNBTUVSQTtcbiAgICAgIGNhc2UgU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5NSUNST1BIT05FO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlVOS05PV047XG4gICAgfVxuICB9XG4gIFRyYWNrLnNvdXJjZVRvUHJvdG8gPSBzb3VyY2VUb1Byb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzKSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5DYW1lcmE7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuTWljcm9waG9uZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTb3VyY2UuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc291cmNlRnJvbVByb3RvID0gc291cmNlRnJvbVByb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHN0cmVhbVN0YXRlRnJvbVByb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuQUNUSVZFOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5BY3RpdmU7XG4gICAgICBjYXNlIFN0cmVhbVN0YXRlLlBBVVNFRDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuUGF1c2VkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuVW5rbm93bjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc3RyZWFtU3RhdGVGcm9tUHJvdG8gPSBzdHJlYW1TdGF0ZUZyb21Qcm90bztcbn0pKFRyYWNrIHx8IChUcmFjayA9IHt9KSk7XG5cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cykge1xuICB2YXIgX2E7XG4gIGNvbnN0IG9wdHMgPSAoX2EgPSBjbG9uZURlZXAob3B0aW9ucykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICBpZiAob3B0cy5hdWRpbyA9PT0gdHJ1ZSkgb3B0cy5hdWRpbyA9IHt9O1xuICBpZiAob3B0cy52aWRlbyA9PT0gdHJ1ZSkgb3B0cy52aWRlbyA9IHt9O1xuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKG9wdHMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhvcHRzLmF1ZGlvLCBhdWRpb0RlZmF1bHRzKTtcbiAgfVxuICBpZiAob3B0cy52aWRlbykge1xuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG9wdHMudmlkZW8sIHZpZGVvRGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcobWFpbk9iamVjdCwgb2JqZWN0VG9NZXJnZSkge1xuICBPYmplY3Qua2V5cyhvYmplY3RUb01lcmdlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKG1haW5PYmplY3Rba2V5XSA9PT0gdW5kZWZpbmVkKSBtYWluT2JqZWN0W2tleV0gPSBvYmplY3RUb01lcmdlW2tleV07XG4gIH0pO1xuICByZXR1cm4gbWFpbk9iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0ge307XG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgLy8gZGVmYXVsdCB2aWRlbyBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgdmlkZW9PcHRpb25zID0ge307XG4gICAgICBjb25zdCB0YXJnZXQgPSB2aWRlb09wdGlvbnM7XG4gICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnZpZGVvO1xuICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcbiAgICAgICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKHRhcmdldCwgc291cmNlLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB2aWRlb09wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gb3B0aW9ucy5hdWRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHNpbGVuY2Ugb24gYSBnaXZlbiBbW1RyYWNrXV0gaW5zdGFuY2UuXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYWNrIHNlZW1zIHRvIGJlIGVudGlyZWx5IHNpbGVudC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZSh0cmFjaykge1xuICBsZXQgdGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjAwO1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGN0eCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICBhbmFseXNlci5mZnRTaXplID0gMjA0ODtcbiAgICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RyYWNrLm1lZGlhU3RyZWFtVHJhY2tdKSk7XG4gICAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgICB5aWVsZCBzbGVlcCh0aW1lT2Zmc2V0KTtcbiAgICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShkYXRhQXJyYXkpO1xuICAgICAgY29uc3Qgc29tZU5vaXNlID0gZGF0YUFycmF5LnNvbWUoc2FtcGxlID0+IHNhbXBsZSAhPT0gMTI4ICYmIHNhbXBsZSAhPT0gMCk7XG4gICAgICBjdHguY2xvc2UoKTtcbiAgICAgIHJldHVybiAhc29tZU5vaXNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TmV3QXVkaW9Db250ZXh0KCkge1xuICBjb25zdCBBdWRpb0NvbnRleHQgPVxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRleHQoe1xuICAgICAgbGF0ZW5jeUhpbnQ6ICdpbnRlcmFjdGl2ZSdcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkge1xuICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgcmV0dXJuICd2aWRlb2lucHV0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHZpZGVvQ29uc3RyYWludHMgPSAoX2EgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uKSB7XG4gICAgdmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzID09PSAnYm9vbGVhbicgPyB7fSA6IHZpZGVvQ29uc3RyYWludHM7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgbWF4OiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICB2aWRlbzogdmlkZW9Db25zdHJhaW50cyxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBkaXNwbGF5IG1lZGlhIGZlYXR1cmVzXG4gICAgY29udHJvbGxlcjogb3B0aW9ucy5jb250cm9sbGVyLFxuICAgIHNlbGZCcm93c2VyU3VyZmFjZTogb3B0aW9ucy5zZWxmQnJvd3NlclN1cmZhY2UsXG4gICAgc3VyZmFjZVN3aXRjaGluZzogb3B0aW9ucy5zdXJmYWNlU3dpdGNoaW5nLFxuICAgIHN5c3RlbUF1ZGlvOiBvcHRpb25zLnN5c3RlbUF1ZGlvXG4gIH07XG59XG5mdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZSkge1xuICBjb25zdCBjb2RlYyA9IG1pbWVUeXBlLnNwbGl0KCcvJylbMV0udG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF2aWRlb0NvZGVjcy5pbmNsdWRlcyhjb2RlYykpIHtcbiAgICB0aHJvdyBFcnJvcihcIlZpZGVvIGNvZGVjIG5vdCBzdXBwb3J0ZWQ6IFwiLmNvbmNhdChjb2RlYykpO1xuICB9XG4gIHJldHVybiBjb2RlYztcbn1cbmZ1bmN0aW9uIGdldFRyYWNrUHVibGljYXRpb25JbmZvKHRyYWNrcykge1xuICBjb25zdCBpbmZvcyA9IFtdO1xuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2gobmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uoe1xuICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgIHRyYWNrOiB0cmFjay50cmFja0luZm9cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5mb3M7XG59XG5cbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcbmNvbnN0IGRkRXh0ZW5zaW9uVVJJID0gJ2h0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtcnRwLXNwZWMvI2RlcGVuZGVuY3ktZGVzY3JpcHRvci1ydHAtaGVhZGVyLWV4dGVuc2lvbic7XG5mdW5jdGlvbiB1bnBhY2tTdHJlYW1JZChwYWNrZWQpIHtcbiAgY29uc3QgcGFydHMgPSBwYWNrZWQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gW3BhcnRzWzBdLCBwYWNrZWQuc3Vic3RyKHBhcnRzWzBdLmxlbmd0aCArIDEpXTtcbiAgfVxuICByZXR1cm4gW3BhY2tlZCwgJyddO1xufVxuZnVuY3Rpb24gc2xlZXAoZHVyYXRpb24pIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcbiAgcmV0dXJuICdhZGRUcmFuc2NlaXZlcicgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNBZGRUcmFjaygpIHtcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNEeW5hY2FzdCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzQVYxKCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vQVYxJykge1xuICAgICAgICBoYXNBVjEgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0FWMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzVlA5KCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpcmVGb3goKSkge1xuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cbmZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0pIHtcbiAgaWYgKCFkb2N1bWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVsbSkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIH1cbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcbn1cbmNvbnN0IHNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyA9IHtcbiAgQ2hyb21lOiAnMTAwJyxcbiAgU2FmYXJpOiAnMTUnLFxuICBGaXJlZm94OiAnMTAwJ1xufTtcbmZ1bmN0aW9uIHN1cHBvcnRzU2V0Q29kZWNQcmVmZXJlbmNlcyh0cmFuc2NlaXZlcikge1xuICBpZiAoIWlzV2ViKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoJ3NldENvZGVjUHJlZmVyZW5jZXMnIGluIHRyYW5zY2VpdmVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICBpZiAoIShicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgfHwgIWJyb3dzZXIudmVyc2lvbikge1xuICAgIC8vIHZlcnNpb24gaXMgcmVxdWlyZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdiA9IHNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9uc1ticm93c2VyLm5hbWVdO1xuICBpZiAodikge1xuICAgIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCB2KSA+PSAwO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XG59XG5mdW5jdGlvbiBpc0ZpcmVGb3goKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0ZpcmVmb3gnO1xufVxuZnVuY3Rpb24gaXNDaHJvbWl1bUJhc2VkKCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdDaHJvbWUnO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ1NhZmFyaSc7XG59XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgaWYgKCFpc1dlYigpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAvVGFibGV0fGlQYWR8TW9iaWxlfEFuZHJvaWR8QmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmZ1bmN0aW9uIGlzV2ViKCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpO1xufVxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKSB7XG4gIC8vIGdsb2JhbCBkZWZpbmVkIG9ubHkgZm9yIFJlYWN0TmF0aXZlLlxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpIHtcbiAgaWYgKCFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgaWYgKGlzV2ViKCkpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGsgPSBNYXRoLm1pbihwYXJ0czEubGVuZ3RoLCBwYXJ0czIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xuICAgIGNvbnN0IHAyID0gcGFyc2VJbnQocGFydHMyW2ldLCAxMCk7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XG4gICAgaWYgKGkgPT09IGsgLSAxICYmIHAxID09PSBwMikgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHJvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVSZXNpemUoZW50cnkpO1xuICB9XG59XG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJvRGlzcGF0Y2hDYWxsYmFjayk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn07XG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpb0Rpc3BhdGNoQ2FsbGJhY2ssIHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICByb290TWFyZ2luOiAnMHB4J1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn07XG5mdW5jdGlvbiBnZXRDbGllbnRJbmZvKCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGluZm8gPSBuZXcgQ2xpZW50SW5mbyh7XG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxuICAgIHZlcnNpb25cbiAgfSk7XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBpbmZvLm9zID0gKF9hID0gZ2V0UmVhY3ROYXRpdmVPcygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBsZXQgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE2O1xuICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgbGV0IGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBsZXQgcGFpbnRDb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCA1MCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkdW1teVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xuICBpZiAoIWR1bW15VHJhY2spIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gdmlkZW8gdHJhY2snKTtcbiAgfVxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cbiAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgZ2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xuICAgIGdhaW4uY29ubmVjdChkc3QpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XG4gICAgfVxuICAgIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuY2xhc3MgRnV0dXJlIHtcbiAgY29uc3RydWN0b3IoZnV0dXJlQmFzZSwgb25GaW5hbGx5KSB7XG4gICAgdGhpcy5vbkZpbmFsbHkgPSBvbkZpbmFsbHk7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcbiAgICAgICAgeWllbGQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9uRmluYWxseSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhbmFseXNlciB3ZWIgYXVkaW8gbm9kZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB0cmFjay5cbiAqIEFkZGl0aW9uYWxseSByZXR1cm5zIGEgY29udmVuaWVuY2UgbWV0aG9kIGBjYWxjdWxhdGVWb2x1bWVgIHRvIHBlcmZvcm0gaW5zdGFudCB2b2x1bWUgcmVhZGluZ3Mgb24gdGhhdCB0cmFjay5cbiAqIENhbGwgdGhlIHJldHVybmVkIGBjbGVhbnVwYCBmdW5jdGlvbiB0byBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIGluc3RhbmNlIG9mIHRoaXMgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQW5hbHlzZXIodHJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGNsb25lVHJhY2s6IGZhbHNlLFxuICAgIGZmdFNpemU6IDIwNDgsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjgsXG4gICAgbWluRGVjaWJlbHM6IC0xMDAsXG4gICAgbWF4RGVjaWJlbHM6IC04MFxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBDb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG4gIH1cbiAgY29uc3Qgc3RyZWFtVHJhY2sgPSBvcHRzLmNsb25lVHJhY2sgPyB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCkgOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICBjb25zdCBtZWRpYVN0cmVhbVNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3N0cmVhbVRyYWNrXSkpO1xuICBjb25zdCBhbmFseXNlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICBhbmFseXNlci5taW5EZWNpYmVscyA9IG9wdHMubWluRGVjaWJlbHM7XG4gIGFuYWx5c2VyLm1heERlY2liZWxzID0gb3B0cy5tYXhEZWNpYmVscztcbiAgYW5hbHlzZXIuZmZ0U2l6ZSA9IG9wdHMuZmZ0U2l6ZTtcbiAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gb3B0cy5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG4gIG1lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICB5aWVsZCBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICBpZiAob3B0cy5jbG9uZVRyYWNrKSB7XG4gICAgICBzdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxjdWxhdGVWb2x1bWUsXG4gICAgYW5hbHlzZXIsXG4gICAgY2xlYW51cFxuICB9O1xufVxuY2xhc3MgTXV0ZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sb2NraW5nID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbG9ja3MgPSAwO1xuICB9XG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XG4gIH1cbiAgbG9jaygpIHtcbiAgICB0aGlzLl9sb2NrcyArPSAxO1xuICAgIGxldCB1bmxvY2tOZXh0O1xuICAgIGNvbnN0IHdpbGxMb2NrID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB1bmxvY2tOZXh0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fbG9ja3MgLT0gMTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgICBjb25zdCB3aWxsVW5sb2NrID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHVubG9ja05leHQpO1xuICAgIHRoaXMuX2xvY2tpbmcgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gd2lsbExvY2spO1xuICAgIHJldHVybiB3aWxsVW5sb2NrO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZpZGVvQ29kZWMobWF5YmVDb2RlYykge1xuICByZXR1cm4gdmlkZW9Db2RlY3MuaW5jbHVkZXMobWF5YmVDb2RlYyk7XG59XG5mdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb25zdHJhaW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5mdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmwpIHtcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14oaHR0cCkvLCAnd3MnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gdG9IdHRwVXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3dzJykpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL14od3MpLywgJ2h0dHAnKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XG5jbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuICBnZXREZXZpY2VzKGtpbmQpIHtcbiAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCgoX2EgPSBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSA+IDApIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnYXdhaXRpbmcgZ2V0VXNlck1lZGlhIHByb21pc2UnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoa2luZCkge1xuICAgICAgICAgICAgeWllbGQgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmdldChraW5kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnZhbHVlcygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vycm9yIHdhaXRpbmcgZm9yIG1lZGlhIHBlcm1pc3NvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMgJiZcbiAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xuICAgICAgIShpc1NhZmFyaSgpICYmIHRoaXMuaGFzRGV2aWNlSW5Vc2Uoa2luZCkpKSB7XG4gICAgICAgIGNvbnN0IGlzRHVtbXlEZXZpY2VPckVtcHR5ID0gZGV2aWNlcy5sZW5ndGggPT09IDAgfHwgZGV2aWNlcy5zb21lKGRldmljZSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgY29uc3QgaXNSZWxldmFudCA9IGtpbmQgPyBkZXZpY2Uua2luZCA9PT0ga2luZCA6IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0R1bW15RGV2aWNlT3JFbXB0eSkge1xuICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zVG9BY3F1aXJlID0ge1xuICAgICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxuICAgICAgICAgICAgYXVkaW86IGtpbmQgIT09ICd2aWRlb2lucHV0J1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xuICAgICAgICAgIGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChraW5kKSB7XG4gICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcbiAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgfVxuICAgICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXG4gICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5nZXREZXZpY2VzKGtpbmQpO1xuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKGQgPT4gZC5ncm91cElkID09PSBncm91cElkICYmIGQuZGV2aWNlSWQgIT09IGRlZmF1bHRJZCk7XG4gICAgICByZXR1cm4gZGV2aWNlID09PSBudWxsIHx8IGRldmljZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGV2aWNlLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIGhhc0RldmljZUluVXNlKGtpbmQpIHtcbiAgICByZXR1cm4ga2luZCA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZCkgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XG4gIH1cbn1cbkRldmljZU1hbmFnZXIubWVkaWFEZXZpY2VLaW5kcyA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5EZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCA9IDEwMDA7XG5jbGFzcyBMb2NhbFRyYWNrIGV4dGVuZHMgVHJhY2sge1xuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kKTtcbiAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCA9ICgpID0+IHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlcigpLmNhdGNoKCgpID0+IGxpdmVraXRMb2dnZXIuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JykpO1xuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciA9IHIoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtKCk7XG4gICAgfSksIDUwMDApO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ3VubXV0ZScpO1xuICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlRW5kZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjaztcbiAgICB0aGlzLm11dGVMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5wYXVzZVVwc3RyZWFtTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMucHJvY2Vzc29yTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhtZWRpYVRyYWNrLCB0cnVlKTtcbiAgICAvLyBhZGRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyLCBjb25zdHJhaW50cyBhcmUgc3luY2VkIHdpdGggTWVkaWFTdHJlYW1UcmFja1xuICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbWVkaWFUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgICB9XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmlkO1xuICB9XG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmtpbmQgIT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG4gIGdldCBpc1VzZXJQcm92aWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlZEJ5VXNlcjtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb2Nlc3NlZFRyYWNrKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG4gIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2ssIGZvcmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgLy8gZGV0YWNoXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCduZXctdHJhY2snKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZWRCeVVzZXIgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAhPT0gbmV3VHJhY2spIHtcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBtZWRpYS4gSW4gdGhpcyBjYXNlIHdlJ2xsIG5lZWQgdG8gc2lnbmFsIHdpdGggcmVtb3RlIHRoYXRcbiAgICAgICAgLy8gdGhlIHRyYWNrIGlzIFwibXV0ZWRcIlxuICAgICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gdG91Y2ggTWVkaWFTdHJlYW1UcmFjay5lbmFibGVkXG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBuZXdUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3NlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIG5ld1RyYWNrICYmIHRoaXMucHJvY2Vzc29yRWxlbWVudCkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicpO1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgcHJvY2Vzc29yIG9uIHRyYWNrIG9mIHVua25vd24ga2luZCcpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGFjaFRvRWxlbWVudChuZXdUcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgeWllbGQgdGhpcy5wcm9jZXNzb3IucmVzdGFydCh7XG4gICAgICAgICAgdHJhY2s6IG5ld1RyYWNrLFxuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Nlc3NlZFRyYWNrID0gdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2s7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZW5kZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICAvLyBzeW5jIG11dGVkIHN0YXRlIHdpdGggdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG5ld2x5IHByb3ZpZGVkIHRyYWNrXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXG4gICAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjaywgZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yRGltZW5zaW9ucygpIHtcbiAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0O1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZGltZW5zaW9ucyBmb3IgYXVkaW8gdHJhY2tzJyk7XG4gICAgICB9XG4gICAgICBpZiAoKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9zKSA9PT0gJ2lPUycpIHtcbiAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXG4gICAgICAgIC8vIHdoZW4gc2xpZ2h0bHkgZGVsYXlpbmcgdGhlIGNhbGwgdG8gLmdldFNldHRpbmdzKCksIHRoZSBjb3JyZWN0IHJlc29sdXRpb24gaXMgYmVpbmcgcmVwb3J0ZWRcbiAgICAgICAgeWllbGQgc2xlZXAoMTApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0ZWQgPCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gZ2V0IHRyYWNrIGRpbWVuc2lvbnMgYWZ0ZXIgdGltZW91dCcpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldERldmljZUlkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgZ3JvdXBJZFxuICAgICAgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8gPyAnYXVkaW9pbnB1dCcgOiAndmlkZW9pbnB1dCc7XG4gICAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKTtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnNldFRyYWNrTXV0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuICByZXBsYWNlVHJhY2sodHJhY2spIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gcmVwbGFjZSBhbiB1bnB1Ymxpc2hlZCB0cmFjaycpO1xuICAgICAgfVxuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJyk7XG4gICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sodHJhY2spO1xuICAgICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXG4gICAgICAvLyBvbiB0aGUgcHJldmlvdXMgc3RhdGUgaW4gb3JkZXIgdG8gY2xlYW51cFxuICAgICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydChjb25zdHJhaW50cykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIWNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHM7XG4gICAgICB9XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdyZXN0YXJ0aW5nIHRyYWNrIHdpdGggY29uc3RyYWludHMnLCBjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHtcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICB2aWRlbzogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzO1xuICAgICAgfVxuICAgICAgLy8gdGhlc2Ugc3RlcHMgYXJlIGR1cGxpY2F0ZWQgZnJvbSBzZXRNZWRpYVN0cmVhbVRyYWNrIGJlY2F1c2Ugd2UgbXVzdCBzdG9wXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdHJhY2tzIGJlZm9yZSBuZXcgdHJhY2tzIGNhbiBiZSBhY3F1aXJlZFxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXG4gICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgdHJhY2sgYW5kIGF0dGFjaFxuICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzdHJlYW1Db25zdHJhaW50cyk7XG4gICAgICBjb25zdCBuZXdUcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3JlLWFjcXVpcmVkIE1lZGlhU3RyZWFtVHJhY2snKTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhuZXdUcmFjayk7XG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0dGluZyBcIi5jb25jYXQodGhpcy5raW5kLCBcIiB0cmFjayBcIikuY29uY2F0KG11dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJykpO1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICB9XG4gIGdldCBuZWVkc1JlQWNxdWlzaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2subXV0ZWQgfHwgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fCB0aGlzLnJlYWNxdWlyZVRyYWNrO1xuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInZpc2liaWxpdHkgY2hhbmdlZCwgaXMgaW4gQmFja2dyb3VuZDogXCIuY29uY2F0KHRoaXMuaXNJbkJhY2tncm91bmQpKTtcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nIFwiLmNvbmNhdCh0aGlzLnNvdXJjZSkpO1xuICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBwYXVzZXMgcHVibGlzaGluZyB0byB0aGUgc2VydmVyIHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xuICAgKiB0aGUgc2VydmVyLlxuICAgKiB0aGlzIEFQSSBpcyB1bnN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMiBkdWUgdG8gYSBidWdcbiAgICoqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3VuYWJsZSB0byBwYXVzZSB1cHN0cmVhbSBmb3IgYW4gdW5wdWJsaXNoZWQgdHJhY2snKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDkxMVxuICAgICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcbiAgICAgICAgLy8gdGhpcyBvcGVyYXRpb24gaXMgbm9vcCBpZiBtZWRpYXN0cmVhbXRyYWNrIGlzIGFscmVhZHkgYmVpbmcgc2VudFxuICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBMb2NhbFRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBTZW5kZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c1JlcG9ydCA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBwcm9jZXNzb3Igb24gdGhpcyB0cmFjay5cbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKlxuICAgKiBAcGFyYW0gcHJvY2Vzc29yXG4gICAqIEBwYXJhbSBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc2V0dGluZyB1cCBwcm9jZXNzb3InKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSAoX2EgPSB0aGlzLnByb2Nlc3NvckVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5raW5kKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JFbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIHRoaXMucHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyb3IgPT4gbGl2ZWtpdExvZ2dlci5lcnJvcignZmFpbGVkIHRvIHBsYXkgcHJvY2Vzc29yIGVsZW1lbnQnLCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsICE9PSB0aGlzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWwpO1xuICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2ssIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgKF9iID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgdHJhY2sgcHJvY2Vzc29yXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0b3BQcm9jZXNzb3IoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnByb2Nlc3NvcikgcmV0dXJuO1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc3RvcHBpbmcgcHJvY2Vzc29yJyk7XG4gICAgICAoX2EgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc29yLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICAgICAgKF9iID0gdGhpcy5wcm9jZXNzb3JFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuY2xhc3MgRTJFRU1hbmFnZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gZXYgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2luZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IGV2LmRhdGE7XG4gICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZGF0YS5lcnJvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXRBY2snOlxuICAgICAgICAgIGlmIChkYXRhLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW5hYmxlJzpcbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSAoX2IgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY291bGRuJ3Qgc2V0IGVuY3J5cHRpb24gc3RhdHVzLCBwYXJ0aWNpcGFudCBub3QgZm91bmRcIi5jb25jYXQoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGRhdGEubWF0ZXJpYWwsIGRhdGEua2V5SW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbldvcmtlckVycm9yID0gZXYgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6Jywge1xuICAgICAgICBlcnJvcjogZXYuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yKTtcbiAgICB9O1xuICAgIHRoaXMua2V5UHJvdmlkZXIgPSBvcHRpb25zLmtleVByb3ZpZGVyO1xuICAgIHRoaXMud29ya2VyID0gb3B0aW9ucy53b3JrZXI7XG4gICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwKHJvb20pIHtcbiAgICBpZiAoIWlzRTJFRVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigndHJpZWQgdG8gc2V0dXAgZW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9uIGFuIHVuc3VwcG9ydGVkIGJyb3dzZXInKTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdzZXR0aW5nIHVwIGUyZWUnKTtcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIHRoaXMua2V5UHJvdmlkZXIpO1xuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAga2V5UHJvdmlkZXJPcHRpb25zOiB0aGlzLmtleVByb3ZpZGVyLmdldE9wdGlvbnMoKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcImluaXRpYWxpemluZyB3b3JrZXJcIiwge1xuICAgICAgICAgIHdvcmtlcjogdGhpcy53b3JrZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IHRoaXMub25Xb3JrZXJNZXNzYWdlO1xuICAgICAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5vbldvcmtlckVycm9yO1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0IGUyZWUgdG8gXCIuY29uY2F0KGVuYWJsZWQsIFwiIGZvciBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0U2lmVHJhaWxlcih0cmFpbGVyKSB7XG4gICAgaWYgKCF0cmFpbGVyIHx8IHRyYWlsZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJpZ25vcmluZyBzZXJ2ZXIgc2VudCB0cmFpbGVyIGFzIGl0J3MgZW1wdHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucG9zdFNpZlRyYWlsZXIodHJhaWxlcik7XG4gICAgfVxuICB9XG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xuICAgIGVuZ2luZS5vbihFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwID0+IHtcbiAgICAgIHRoaXMucG9zdFJUUE1hcChydHBNYXApO1xuICAgIH0pO1xuICB9XG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwga2V5UHJvdmlkZXIpIHtcbiAgICByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHB1YiwgcGFydGljaXBhbnQpID0+IHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSkpO1xuICAgIHJvb20ub24oUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHN0YXRlID0+IHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICByb29tLnBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIF8sIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdyZW1vdmVUcmFuc2Zvcm0nLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2subWVkaWFTdHJlYW1JRFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKF9hID0gdGhpcy53b3JrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHViLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdGhpcy5zZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcGFydGljaXBhbnQuaWRlbnRpdHksIHB1Yi50cmFja0luZm8pO1xuICAgIH0pLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5yb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCByb29tIHRvIGJlIHByZXNlbnQgb24gc2lnbmFsIGNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQodGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaXNFMkVFRW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgICAga2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XG4gICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFU2VuZGVyKHB1YmxpY2F0aW9uLnRyYWNrLCBwdWJsaWNhdGlvbi50cmFjay5zZW5kZXIpO1xuICAgIH0pKTtcbiAgICBrZXlQcm92aWRlci5vbihLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyA9PiB0aGlzLnBvc3RLZXkoa2V5SW5mbykpLm9uKEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4gdGhpcy5wb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZCwga2V5SW5kZXgpKTtcbiAgfVxuICBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHJhdGNoZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAncmF0Y2hldFJlcXVlc3QnLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBrZXlJbmRleFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0S2V5KF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldEtleScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSksXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBjb25zdCBlbmFibGVNc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmFibGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShlbmFibGVNc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xuICAgIH1cbiAgfVxuICBwb3N0UlRQTWFwKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFJUUE1hcCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgcG9zdFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3QgcG9zdCBTSUYgdHJhaWxlciwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3NldFNpZlRyYWlsZXInLFxuICAgICAgZGF0YToge1xuICAgICAgICB0cmFpbGVyXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCByZW1vdGVJZCwgdHJhY2tJbmZvKSB7XG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0cmFja0luZm8gPT09IG51bGwgfHwgdHJhY2tJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0luZm8ubWltZVR5cGUpIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pbWVUeXBlIG1pc3NpbmcgZnJvbSB0cmFja0luZm8sIGNhbm5vdCBzZXQgdXAgRTJFRSBjcnlwdG9yJyk7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIodHJhY2sucmVjZWl2ZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHJlbW90ZUlkLCB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgc2V0dXBFMkVFU2VuZGVyKHRyYWNrLCBzZW5kZXIpIHtcbiAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2spIHx8ICFzZW5kZXIpIHtcbiAgICAgIGlmICghc2VuZGVyKSBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vhcmx5IHJldHVybiBiZWNhdXNlIHNlbmRlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlUmVjZWl2ZXIocmVjZWl2ZXIsIHRyYWNrSWQsIHBhcnRpY2lwYW50SWRlbnRpdHksIGNvZGVjKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgY29kZWNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZWNlaXZlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChFMkVFX0ZMQUcgaW4gcmVjZWl2ZXIgJiYgY29kZWMpIHtcbiAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjb2RlY1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHRyYWNrSWQsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCB3cml0YWJsZSA9IHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCByZWFkYWJsZSA9IHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdCByZWNlaXZlclN0cmVhbXMgPSByZWNlaXZlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICByZWNlaXZlci53cml0YWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICB3cml0YWJsZSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIucmVhZGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgICAgcmVhZGFibGUgPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlU3RyZWFtOiB3cml0YWJsZSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWQsXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3JlYWRhYmxlLCB3cml0YWJsZV0pO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVjZWl2ZXJbRTJFRV9GTEFHXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBTZW5kZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBlbmNvZGVyLlxuICAgKlxuICAgKi9cbiAgaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2tJZCwgY29kZWMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKEUyRUVfRkxBRyBpbiBzZW5kZXIgfHwgIXRoaXMud29ya2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xuICAgIH1cbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIHNjcmlwdCB0cmFuc2Zvcm0nKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgY29kZWNcbiAgICAgIH07XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzZW5kZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnaW5pdGlhbGl6ZSBlbmNvZGVkIHN0cmVhbXMnKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHNlbmRlclN0cmVhbXMgPSBzZW5kZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2VuY29kZScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWFkYWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSxcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy53cml0YWJsZSxcbiAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLCBzZW5kZXJTdHJlYW1zLndyaXRhYmxlXSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZW5kZXJbRTJFRV9GTEFHXSA9IHRydWU7XG4gIH1cbn1cblxudmFyIFF1ZXVlVGFza1N0YXR1cztcbihmdW5jdGlvbiAoUXVldWVUYXNrU3RhdHVzKSB7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJXQUlUSU5HXCJdID0gMF0gPSBcIldBSVRJTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiQ09NUExFVEVEXCJdID0gMl0gPSBcIkNPTVBMRVRFRFwiO1xufSkoUXVldWVUYXNrU3RhdHVzIHx8IChRdWV1ZVRhc2tTdGF0dXMgPSB7fSkpO1xuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGFza011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuICBydW4odGFzaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB0YXNrSW5mbyA9IHtcbiAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJbmRleCsrLFxuICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnRhc2tNdXRleC5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgIHJldHVybiB5aWVsZCB0YXNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHt9KSk7XG4gICAgfSk7XG4gIH1cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG5cbmNvbnN0IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzID0gWydzeW5jU3RhdGUnLCAndHJpY2tsZScsICdvZmZlcicsICdhbnN3ZXInLCAnc2ltdWxhdGUnLCAnbGVhdmUnXTtcbmZ1bmN0aW9uIGNhblBhc3NUaHJvdWdoUXVldWUocmVxKSB7XG4gIGNvbnN0IGNhblBhc3MgPSBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscy5pbmRleE9mKHJlcS5jYXNlKSA+PSAwO1xuICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyZXF1ZXN0IGFsbG93ZWQgdG8gYnlwYXNzIHF1ZXVlOicsIHtcbiAgICBjYW5QYXNzLFxuICAgIHJlcVxuICB9KTtcbiAgcmV0dXJuIGNhblBhc3M7XG59XG52YXIgU2lnbmFsQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChTaWduYWxDb25uZWN0aW9uU3RhdGUpIHtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMV0gPSBcIkNPTk5FQ1RFRFwiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVElOR1wiXSA9IDNdID0gXCJESVNDT05ORUNUSU5HXCI7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJESVNDT05ORUNURURcIl0gPSA0XSA9IFwiRElTQ09OTkVDVEVEXCI7XG59KShTaWduYWxDb25uZWN0aW9uU3RhdGUgfHwgKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5jbGFzcyBTaWduYWxDbGllbnQge1xuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG4gIGdldCBpc0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgdXNlSlNPTiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgLyoqIHNpZ25hbCBydHQgaW4gbWlsbGlzZWNvbmRzICovXG4gICAgdGhpcy5ydHQgPSAwO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnJlc2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uT2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLnVzZUpTT04gPSB1c2VKU09OO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICB0aGlzLnF1ZXVlZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgfVxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGR1cmluZyBhIGZ1bGwgcmVjb25uZWN0LCB3ZSdkIHdhbnQgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIGV2ZW4gaWYgY3VycmVudGx5XG4gICAgICAvLyBjb25uZWN0ZWRcbiAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORztcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICByZWNvbm5lY3QodXJsLCB0b2tlbiwgc2lkLCByZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhdHRlbXB0ZWQgdG8gcmVjb25uZWN0IHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgYmVpbmcgc2V0LCBpZ25vcmluZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAgIC8vIGNsZWFyIHBpbmcgaW50ZXJ2YWwgYW5kIHJlc3RhcnQgaXQgb25jZSByZWNvbm5lY3RlZFxuICAgICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwge1xuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHNpZCxcbiAgICAgICAgcmVjb25uZWN0UmVhc29uOiByZWFzb25cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHRoaXMuY29ubmVjdE9wdGlvbnMgPSBvcHRzO1xuICAgIHVybCA9IHRvV2Vic29ja2V0VXJsKHVybCk7XG4gICAgLy8gc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICB1cmwgKz0gJy9ydGMnO1xuICAgIGNvbnN0IGNsaWVudEluZm8gPSBnZXRDbGllbnRJbmZvKCk7XG4gICAgY29uc3QgcGFyYW1zID0gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbkxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCAoc2lnbmFsKScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyB0aW1lZCBvdXQgKHNpZ25hbCknKSk7XG4gICAgICAgIH0sIG9wdHMud2Vic29ja2V0VGltZW91dCk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdCh1cmwgKyBwYXJhbXMpKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodXJsICsgcGFyYW1zKTtcbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IGV2ID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXNwID0geWllbGQgZmV0Y2goXCJodHRwXCIuY29uY2F0KHVybC5zdWJzdHJpbmcoMiksIFwiL3ZhbGlkYXRlXCIpLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IobXNnLCAwIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkICovLCByZXNwLnN0YXR1cykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdJbnRlcm5hbCBlcnJvcicsIDIgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IgKi8sIHJlc3Auc3RhdHVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3NlcnZlciB3YXMgbm90IHJlYWNoYWJsZScsIDEgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyIGVycm9ycywgaGFuZGxlXG4gICAgICAgICAgdGhpcy5oYW5kbGVXU0Vycm9yKGV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAvLyBub3QgY29uc2lkZXJlZCBjb25uZWN0ZWQgdW50aWwgSm9pblJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgICAgbGV0IHJlc3A7XG4gICAgICAgICAgaWYgKHR5cGVvZiBldi5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUpzb24oanNvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChldi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGV2LmRhdGEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihcImNvdWxkIG5vdCBkZWNvZGUgd2Vic29ja2V0IG1lc3NhZ2U6IFwiLmNvbmNhdCh0eXBlb2YgZXYuZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgbGV0IHNob3VsZFByb2Nlc3NNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBoYW5kbGUgam9pbiBtZXNzYWdlIG9ubHlcbiAgICAgICAgICAgIGlmICgoKF9hID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FzZSkgPT09ICdqb2luJykge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID0gcmVzcC5tZXNzYWdlLnZhbHVlLnBpbmdUaW1lb3V0O1xuICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uID0gcmVzcC5tZXNzYWdlLnZhbHVlLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncGluZyBjb25maWcnLCB7XG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgLy8gaW4gcmVjb25uZWN0aW5nLCBhbnkgbWVzc2FnZSByZWNlaXZlZCBtZWFucyBzaWduYWwgcmVjb25uZWN0ZWRcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKChfYyA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAvLyBub24tcmVjb25uZWN0IGNhc2UsIHNob3VsZCByZWNlaXZlIGpvaW4gcmVzcG9uc2UgZmlyc3RcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoXCJkaWQgbm90IHJlY2VpdmUgam9pbiByZXNwb25zZSwgZ290IFwiLmNvbmNhdCgoX2QgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYXNlLCBcIiBpbnN0ZWFkXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNob3VsZFByb2Nlc3NNZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgICAgeWllbGQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IGV2ID0+IHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJ3ZWJzb2NrZXQgY2xvc2VkXCIsIHtcbiAgICAgICAgICAgIGV2XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKGV2LnJlYXNvbik7XG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAvLyBjYWxsaW5nIGB3cy5jbG9zZSgpYCBvbmx5IHN0YXJ0cyB0aGUgY2xvc2luZyBoYW5kc2hha2UgKENMT1NJTkcgc3RhdGUpLCBwcmVmZXIgdG8gd2FpdCB1bnRpbCBzdGF0ZSBpcyBhY3R1YWxseSBDTE9TRURcbiAgICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMud3MucmVhZHlTdGF0ZSA8IHRoaXMud3MuQ0xPU0lORykge1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gMjUwbXMgZ3JhY2UgcGVyaW9kIGZvciB3cyB0byBjbG9zZSBncmFjZWZ1bGx5XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW2Nsb3NlUHJvbWlzZSwgc2xlZXAoMjUwKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBpbml0aWFsIG9mZmVyIGFmdGVyIGpvaW5pbmdcbiAgc2VuZE9mZmVyKG9mZmVyKSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc2VuZGluZyBvZmZlcicsIG9mZmVyKTtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdvZmZlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlcilcbiAgICB9KTtcbiAgfVxuICAvLyBhbnN3ZXIgYSBzZXJ2ZXItaW5pdGlhdGVkIG9mZmVyXG4gIHNlbmRBbnN3ZXIoYW5zd2VyKSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc2VuZGluZyBhbnN3ZXInKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYW5zd2VyJyxcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcilcbiAgICB9KTtcbiAgfVxuICBzZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZSgnc2VuZGluZyBpY2UgY2FuZGlkYXRlJywgY2FuZGlkYXRlKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndHJpY2tsZScsXG4gICAgICB2YWx1ZTogbmV3IFRyaWNrbGVSZXF1ZXN0KHtcbiAgICAgICAgY2FuZGlkYXRlSW5pdDogSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ211dGUnLFxuICAgICAgdmFsdWU6IG5ldyBNdXRlVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgc2lkOiB0cmFja1NpZCxcbiAgICAgICAgbXV0ZWRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZEFkZFRyYWNrKHJlcSkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhZGRUcmFjaycsXG4gICAgICB2YWx1ZTogcmVxXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEobWV0YWRhdGEsIG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTWV0YWRhdGEnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIG5hbWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmFja1NldHRpbmcnLFxuICAgICAgdmFsdWU6IHNldHRpbmdzXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgIHZhbHVlOiBzdWJcbiAgICB9KTtcbiAgfVxuICBzZW5kU3luY1N0YXRlKHN5bmMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3luY1N0YXRlJyxcbiAgICAgIHZhbHVlOiBzeW5jXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVZpZGVvTGF5ZXJzKHRyYWNrU2lkLCBsYXllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTGF5ZXJzJyxcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoe1xuICAgICAgICB0cmFja1NpZCxcbiAgICAgICAgbGF5ZXJzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHMsIHRyYWNrUGVybWlzc2lvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbicsXG4gICAgICB2YWx1ZTogbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oe1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHMsXG4gICAgICAgIHRyYWNrUGVybWlzc2lvbnNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc2ltdWxhdGUnLFxuICAgICAgdmFsdWU6IHNjZW5hcmlvXG4gICAgfSk7XG4gIH1cbiAgc2VuZFBpbmcoKSB7XG4gICAgLyoqIHNlbmQgYm90aCBvZiBwaW5nIGFuZCBwaW5nUmVxIGZvciBjb21wYXRpYmlsaXR5IHRvIG9sZCBhbmQgbmV3IHNlcnZlciAqL1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAncGluZycsXG4gICAgICB2YWx1ZTogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKVxuICAgIH0pLCB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdwaW5nUmVxJyxcbiAgICAgIHZhbHVlOiBuZXcgUGluZyh7XG4gICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKSxcbiAgICAgICAgcnR0OiBwcm90b0ludDY0LnBhcnNlKHRoaXMucnR0KVxuICAgICAgfSlcbiAgICB9KV0pO1xuICB9XG4gIHNlbmRMZWF2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnbGVhdmUnLFxuICAgICAgdmFsdWU6IG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICBjYW5SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgbGV0IGZyb21RdWV1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGNhcHR1cmUgYWxsIHJlcXVlc3RzIHdoaWxlIHJlY29ubmVjdGluZyBhbmQgcHV0IHRoZW0gaW4gYSBxdWV1ZVxuICAgICAgLy8gdW5sZXNzIHRoZSByZXF1ZXN0IG9yaWdpbmF0ZXMgZnJvbSB0aGUgcXVldWUsIHRoZW4gZG9uJ3QgZW5xdWV1ZSBhZ2FpblxuICAgICAgY29uc3QgY2FuUXVldWUgPSAhZnJvbVF1ZXVlICYmICFjYW5QYXNzVGhyb3VnaFF1ZXVlKG1lc3NhZ2UpO1xuICAgICAgaWYgKGNhblF1ZXVlICYmIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cy5wdXNoKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KG1lc3NhZ2UsIHRydWUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIG1ha2Ugc3VyZSBwcmV2aW91c2x5IHF1ZXVlZCByZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBmaXJzdFxuICAgICAgaWYgKCFmcm9tUXVldWUpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0UXVldWUuZmx1c2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgeWllbGQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLndzLnJlYWR5U3RhdGUgIT09IHRoaXMud3MuT1BFTikge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKFwiY2Fubm90IHNlbmQgc2lnbmFsIHJlcXVlc3QgYmVmb3JlIGNvbm5lY3RlZCwgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5jYXNlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBTaWduYWxSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy51c2VKU09OKSB7XG4gICAgICAgICAgdGhpcy53cy5zZW5kKHJlcS50b0pzb25TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53cy5zZW5kKHJlcS50b0JpbmFyeSgpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbXNnID0gcmVzLm1lc3NhZ2U7XG4gICAgaWYgKG1zZyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBpbmdIYW5kbGVkID0gZmFsc2U7XG4gICAgaWYgKG1zZy5jYXNlID09PSAnYW5zd2VyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XG4gICAgICAgIHRoaXMub25BbnN3ZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdvZmZlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyKSB7XG4gICAgICAgIHRoaXMub25PZmZlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1bnN1cHBvcnRlZCBtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gICAgaWYgKCFwaW5nSGFuZGxlZCkge1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfVxuICB9XG4gIHNldFJlY29ubmVjdGVkKCkge1xuICAgIHdoaWxlICh0aGlzLnF1ZXVlZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcSA9IHRoaXMucXVldWVkUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucnVuKHJlcSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZU9uQ2xvc2UocmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEKSByZXR1cm47XG4gICAgICBjb25zdCBvbkNsb3NlQ2FsbGJhY2sgPSB0aGlzLm9uQ2xvc2U7XG4gICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkOiBcIi5jb25jYXQocmVhc29uKSk7XG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVdTRXJyb3IoZXYpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBldik7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgcGluZyB0aW1lb3V0IGFuZCBzdGFydHMgYSBuZXcgdGltZW91dC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHJlY2VpdmluZyBhIHBvbmcgbWVzc2FnZVxuICAgKi9cbiAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ1RpbWVvdXREdXJhdGlvbikge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdwaW5nIHRpbWVvdXQgZHVyYXRpb24gbm90IHNldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpbmdUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJwaW5nIHRpbWVvdXQgdHJpZ2dlcmVkLiBsYXN0IHBvbmcgcmVjZWl2ZWQgYXQ6IFwiLmNvbmNhdChuZXcgRGF0ZShEYXRlLm5vdygpIC0gdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCkudG9VVENTdHJpbmcoKSkpO1xuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgICB9LCB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHBpbmcgdGltZW91dCAoZG9lcyBub3Qgc3RhcnQgYSBuZXcgdGltZW91dClcbiAgICovXG4gIGNsZWFyUGluZ1RpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucGluZ1RpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgc3RhcnRQaW5nSW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIGlmICghdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbikge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcpO1xuICAgIHRoaXMucGluZ0ludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5zZW5kUGluZygpO1xuICAgIH0sIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICBjbGVhclBpbmdJbnRlcnZhbCgpIHtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdjbGVhcmluZyBwaW5nIGludGVydmFsJyk7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihzZCkge1xuICBjb25zdCByc2QgPSB7XG4gICAgdHlwZTogJ29mZmVyJyxcbiAgICBzZHA6IHNkLnNkcFxuICB9O1xuICBzd2l0Y2ggKHNkLnR5cGUpIHtcbiAgICBjYXNlICdhbnN3ZXInOlxuICAgIGNhc2UgJ29mZmVyJzpcbiAgICBjYXNlICdwcmFuc3dlcic6XG4gICAgY2FzZSAncm9sbGJhY2snOlxuICAgICAgcnNkLnR5cGUgPSBzZC50eXBlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cbmZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ocnNkKSB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwLFxuICAgIHR5cGU6IHJzZC50eXBlXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBpbmZvLCBvcHRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG4gIC8vIG9wdHNcbiAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcbiAgICBpZiAob3B0cy5zaWQpIHtcbiAgICAgIHBhcmFtcy5zZXQoJ3NpZCcsIG9wdHMuc2lkKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnNldCgnYXV0b19zdWJzY3JpYmUnLCBvcHRzLmF1dG9TdWJzY3JpYmUgPyAnMScgOiAnMCcpO1xuICAvLyBDbGllbnRJbmZvXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcbiAgcGFyYW1zLnNldCgndmVyc2lvbicsIGluZm8udmVyc2lvbik7XG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcbiAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgfVxuICBpZiAoaW5mby5vcykge1xuICAgIHBhcmFtcy5zZXQoJ29zJywgaW5mby5vcyk7XG4gIH1cbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnb3NfdmVyc2lvbicsIGluZm8ub3NWZXJzaW9uKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyX3ZlcnNpb24nLCBpbmZvLmJyb3dzZXJWZXJzaW9uKTtcbiAgfVxuICBpZiAob3B0cy5wdWJsaXNoT25seSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNldCgncHVibGlzaCcsIG9wdHMucHVibGlzaE9ubHkpO1xuICB9XG4gIGlmIChvcHRzLmFkYXB0aXZlU3RyZWFtKSB7XG4gICAgcGFyYW1zLnNldCgnYWRhcHRpdmVfc3RyZWFtJywgJzEnKTtcbiAgfVxuICBpZiAob3B0cy5yZWNvbm5lY3RSZWFzb24pIHtcbiAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3RfcmVhc29uJywgb3B0cy5yZWNvbm5lY3RSZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoKF9hID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBhcmFtcy5zZXQoJ25ldHdvcmsnLCBuYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlKTtcbiAgfVxuICByZXR1cm4gXCI/XCIuY29uY2F0KHBhcmFtcy50b1N0cmluZygpKTtcbn1cblxudmFyIHBhcnNlciQxID0ge307XG5cbnZhciBncmFtbWFyJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ3JhbW1hciQxID0gZ3JhbW1hciQyLmV4cG9ydHMgPSB7XG4gIHY6IFt7XG4gICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgIHJlZzogL14oXFxkKikkL1xuICB9XSxcbiAgbzogW3tcbiAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcbiAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICBuYW1lOiAnb3JpZ2luJyxcbiAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgZm9ybWF0OiAnJXMgJXMgJWQgJXMgSVAlZCAlcydcbiAgfV0sXG4gIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICBzOiBbe1xuICAgIG5hbWU6ICduYW1lJ1xuICB9XSxcbiAgaTogW3tcbiAgICBuYW1lOiAnZGVzY3JpcHRpb24nXG4gIH1dLFxuICB1OiBbe1xuICAgIG5hbWU6ICd1cmknXG4gIH1dLFxuICBlOiBbe1xuICAgIG5hbWU6ICdlbWFpbCdcbiAgfV0sXG4gIHA6IFt7XG4gICAgbmFtZTogJ3Bob25lJ1xuICB9XSxcbiAgejogW3tcbiAgICBuYW1lOiAndGltZXpvbmVzJ1xuICB9XSxcbiAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFjdHVhbGx5IGJlIHBhcnNlZCBwcm9wZXJseS4uLlxuICByOiBbe1xuICAgIG5hbWU6ICdyZXBlYXRzJ1xuICB9XSxcbiAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgdDogW3tcbiAgICAvLyB0PTAgMFxuICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgZm9ybWF0OiAnJWQgJWQnXG4gIH1dLFxuICBjOiBbe1xuICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICB9XSxcbiAgYjogW3tcbiAgICAvLyBiPUFTOjQwMDBcbiAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgIGZvcm1hdDogJyVzOiVzJ1xuICB9XSxcbiAgbTogW3tcbiAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcbiAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICBmb3JtYXQ6ICclcyAlZCAlcyAlcydcbiAgfV0sXG4gIGE6IFt7XG4gICAgLy8gYT1ydHBtYXA6MTEwIG9wdXMvNDgwMDAvMlxuICAgIHB1c2g6ICdydHAnLFxuICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb2RlYycsICdyYXRlJywgJ2VuY29kaW5nJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uZW5jb2RpbmcgPyAncnRwbWFwOiVkICVzLyVzLyVzJyA6IG8ucmF0ZSA/ICdydHBtYXA6JWQgJXMvJXMnIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgLy8gYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICBwdXNoOiAnZm10cCcsXG4gICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29uZmlnJ10sXG4gICAgZm9ybWF0OiAnZm10cDolZCAlcydcbiAgfSwge1xuICAgIC8vIGE9Y29udHJvbDpzdHJlYW1pZD0wXG4gICAgbmFtZTogJ2NvbnRyb2wnLFxuICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgIGZvcm1hdDogJ2NvbnRyb2w6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICBuYW1lOiAncnRjcCcsXG4gICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiBvLmFkZHJlc3MgIT0gbnVsbCA/ICdydGNwOiVkICVzIElQJWQgJXMnIDogJ3J0Y3A6JWQnO1xuICAgIH1cbiAgfSwge1xuICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxuICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcbiAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG4gICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSAoW1xcdy1fXSopKD86IChbXFx3LV9dKikpPy8sXG4gICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gby5zdWJ0eXBlICE9IG51bGwgPyAncnRjcC1mYjolcyAlcyAlcycgOiAncnRjcC1mYjolcyAlcyc7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4gICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICBwdXNoOiAnZXh0JyxcbiAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICByZXR1cm4gJ2V4dG1hcDolZCcgKyAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICsgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICsgJyAlcycgKyAoby5jb25maWcgPyAnICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxuICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICByZWc6IC9eKGV4dG1hcC1hbGxvdy1taXhlZCkvXG4gIH0sIHtcbiAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgIHB1c2g6ICdjcnlwdG8nLFxuICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsID8gJ2NyeXB0bzolZCAlcyAlcyAlcycgOiAnY3J5cHRvOiVkICVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXNldHVwOmFjdHBhc3NcbiAgICBuYW1lOiAnc2V0dXAnLFxuICAgIHJlZzogL15zZXR1cDooXFx3KikvLFxuICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1jb25uZWN0aW9uOm5ld1xuICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXG4gICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgIGZvcm1hdDogJ2Nvbm5lY3Rpb246JXMnXG4gIH0sIHtcbiAgICAvLyBhPW1pZDoxXG4gICAgbmFtZTogJ21pZCcsXG4gICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgIGZvcm1hdDogJ21pZDolcydcbiAgfSwge1xuICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXG4gICAgbmFtZTogJ21zaWQnLFxuICAgIHJlZzogL15tc2lkOiguKikvLFxuICAgIGZvcm1hdDogJ21zaWQ6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXB0aW1lOjIwXG4gICAgbmFtZTogJ3B0aW1lJyxcbiAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICBmb3JtYXQ6ICdwdGltZTolZCdcbiAgfSwge1xuICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICBuYW1lOiAnbWF4cHRpbWUnLFxuICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICB9LCB7XG4gICAgLy8gYT1zZW5kcmVjdlxuICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgIHJlZzogL14oc2VuZHJlY3Z8cmVjdm9ubHl8c2VuZG9ubHl8aW5hY3RpdmUpL1xuICB9LCB7XG4gICAgLy8gYT1pY2UtbGl0ZVxuICAgIG5hbWU6ICdpY2VsaXRlJyxcbiAgICByZWc6IC9eKGljZS1saXRlKS9cbiAgfSwge1xuICAgIC8vIGE9aWNlLXVmcmFnOkY3Z0lcbiAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICBmb3JtYXQ6ICdpY2UtdWZyYWc6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgIG5hbWU6ICdpY2VQd2QnLFxuICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXG4gICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgfSwge1xuICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcbiAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgIHJlZzogL15maW5nZXJwcmludDooXFxTKikgKFxcUyopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcbiAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHVkcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgIHB1c2g6ICdjYW5kaWRhdGVzJyxcbiAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXG4gICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xuICAgICAgc3RyICs9IG8ucmFkZHIgIT0gbnVsbCA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xuICAgICAgc3RyICs9IG8udGNwdHlwZSAhPSBudWxsID8gJyB0Y3B0eXBlICVzJyA6ICcldic7XG4gICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gb1snbmV0d29yay1pZCddICE9IG51bGwgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgIHN0ciArPSBvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cbiAgfSwge1xuICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcbiAgICByZWc6IC9ecmVtb3RlLWNhbmRpZGF0ZXM6KC4qKS8sXG4gICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gIH0sIHtcbiAgICAvLyBhPWljZS1vcHRpb25zOmdvb2dsZS1pY2VcbiAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXG4gICAgZm9ybWF0OiAnaWNlLW9wdGlvbnM6JXMnXG4gIH0sIHtcbiAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXG4gICAgcHVzaDogJ3NzcmNzJyxcbiAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xuICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJzolcyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcbiAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDLUZSIDMwMDQzNjQxOTUgMTA4MDc3MjI0MVxuICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgIHJlZzogL15zc3JjLWdyb3VwOihbXFx4MjFcXHgyM1xceDI0XFx4MjVcXHgyNlxceDI3XFx4MkFcXHgyQlxceDJEXFx4MkVcXHddKikgKC4qKS8sXG4gICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxuICAgIHJlZzogL15tc2lkLXNlbWFudGljOlxccz8oXFx3KikgKFxcUyopLyxcbiAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcbiAgfSwge1xuICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgcHVzaDogJ2dyb3VwcycsXG4gICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcbiAgfSwge1xuICAgIC8vIGE9cnRjcC1tdXhcbiAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgcmVnOiAvXihydGNwLW11eCkvXG4gIH0sIHtcbiAgICAvLyBhPXJ0Y3AtcnNpemVcbiAgICBuYW1lOiAncnRjcFJzaXplJyxcbiAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICB9LCB7XG4gICAgLy8gYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgIG5hbWVzOiBbJ3NjdHBtYXBOdW1iZXInLCAnYXBwJywgJ21heE1lc3NhZ2VTaXplJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbCA/ICdzY3RwbWFwOiVzICVzICVzJyA6ICdzY3RwbWFwOiVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgIG5hbWU6ICd4R29vZ2xlRmxhZycsXG4gICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICB9LCB7XG4gICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICBwdXNoOiAncmlkcycsXG4gICAgcmVnOiAvXnJpZDooW1xcZFxcd10rKSAoXFx3KykoPzogKFtcXFN8IF0qKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgcmV0dXJuIG8ucGFyYW1zID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPWltYWdlYXR0cjo5NyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICBwdXNoOiAnaW1hZ2VhdHRycycsXG4gICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgIC8vIGE9aW1hZ2VhdHRyOjk3XG4gICAgJ15pbWFnZWF0dHI6KFxcXFxkK3xcXFxcKiknICtcbiAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXG4gICAgLy8gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nKSxcbiAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcbiAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgLy8gYT1zaW11bGNhc3Q6XG4gICAgJ15zaW11bGNhc3Q6JyArXG4gICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgIC8vIHNwYWNlICsgcmVjdiA2O343LH44XG4gICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAvLyBlbmRcbiAgICAnJCcpLFxuICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAnc2ltdWxjYXN0OiVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvLyBvbGQgc2ltdWxjYXN0IGRyYWZ0IDAzIChpbXBsZW1lbnRlZCBieSBGaXJlZm94KVxuICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgLy8gYT1zaW11bGNhc3Q6IHNlbmQgcmlkPTU7Njs3IHBhdXNlZD02LDdcbiAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgIG5hbWVzOiBbJ3ZhbHVlJ10sXG4gICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgfSwge1xuICAgIC8vIGE9ZnJhbWVyYXRlOjI1XG4gICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICBuYW1lOiAnZnJhbWVyYXRlJyxcbiAgICByZWc6IC9eZnJhbWVyYXRlOihcXGQrKD86JHxcXC5cXGQrKSkvLFxuICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgfSwge1xuICAgIC8vIFJGQzQ1NzBcbiAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXG4gICAgcmVnOiAvXnNvdXJjZS1maWx0ZXI6ICooZXhjbHxpbmNsKSAoXFxTKikgKElQNHxJUDZ8XFwqKSAoXFxTKikgKC4qKS8sXG4gICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXG4gIH0sIHtcbiAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgbmFtZTogJ2J1bmRsZU9ubHknLFxuICAgIHJlZzogL14oYnVuZGxlLW9ubHkpL1xuICB9LCB7XG4gICAgLy8gYT1sYWJlbDoxXG4gICAgbmFtZTogJ2xhYmVsJyxcbiAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgZm9ybWF0OiAnbGFiZWw6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XG4gICAgbmFtZTogJ3NjdHBQb3J0JyxcbiAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcbiAgfSwge1xuICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcbiAgICBuYW1lOiAnbWF4TWVzc2FnZVNpemUnLFxuICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXG4gIH0sIHtcbiAgICAvLyBSRkM3MjczXG4gICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcbiAgICBwdXNoOiAndHNSZWZDbG9ja3MnLFxuICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxuICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gUkZDNzI3M1xuICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxuICAgIG5hbWU6ICdtZWRpYUNsaycsXG4gICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICBzdHIgKz0gby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJztcbiAgICAgIHN0ciArPSBvLm1lZGlhQ2xvY2tWYWx1ZSAhPSBudWxsID8gJz0lcycgOiAnJztcbiAgICAgIHN0ciArPSBvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJztcbiAgICAgIHN0ciArPSBvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJztcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9LCB7XG4gICAgLy8gYT1rZXl3ZHM6a2V5d29yZHNcbiAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxuICAgIGZvcm1hdDogJ2tleXdkczolcydcbiAgfSwge1xuICAgIC8vIGE9Y29udGVudDptYWluXG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXG4gIH0sXG4gIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAge1xuICAgIC8vIGE9Zmxvb3JjdHJsOmMtc1xuICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxuICAgIGZvcm1hdDogJ2Zsb29yY3RybDolcydcbiAgfSwge1xuICAgIC8vIGE9Y29uZmlkOjFcbiAgICBuYW1lOiAnYmZjcENvbmZJZCcsXG4gICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgIGZvcm1hdDogJ2NvbmZpZDolcydcbiAgfSwge1xuICAgIC8vIGE9dXNlcmlkOjFcbiAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXG4gICAgcmVnOiAvXnVzZXJpZDooXFxkKykvLFxuICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgfSwge1xuICAgIC8vIGE9Zmxvb3JpZDoxXG4gICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcbiAgICBuYW1lczogWydpZCcsICdtU3RyZWFtJ10sXG4gICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgfSwge1xuICAgIC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdCB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgcHVzaDogJ2ludmFsaWQnLFxuICAgIG5hbWVzOiBbJ3ZhbHVlJ11cbiAgfV1cbn07XG5cbi8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xuT2JqZWN0LmtleXMoZ3JhbW1hciQxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIG9ianMgPSBncmFtbWFyJDFba2V5XTtcbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgfVxuICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIGdyYW1tYXJFeHBvcnRzID0gZ3JhbW1hciQyLmV4cG9ydHM7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuICB2YXIgdG9JbnRJZkludCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbiAgfTtcbiAgdmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICAgIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xuICAgICAgbG9jYXRpb25bcmF3TmFtZV0gPSB0b0ludElmSW50KG1hdGNoWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobWF0Y2hbaSArIDFdICE9IG51bGwpIHtcbiAgICAgICAgICBsb2NhdGlvbltuYW1lc1tpXV0gPSB0b0ludElmSW50KG1hdGNoW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gICAgdmFyIG5lZWRzQmxhbmsgPSBvYmoubmFtZSAmJiBvYmoubmFtZXM7XG4gICAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICAgIH0gZWxzZSBpZiAobmVlZHNCbGFuayAmJiAhbG9jYXRpb25bb2JqLm5hbWVdKSB7XG4gICAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgICB9XG4gICAgdmFyIGtleUxvY2F0aW9uID0gb2JqLnB1c2ggPyB7fSA6XG4gICAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICBuZWVkc0JsYW5rID8gbG9jYXRpb25bb2JqLm5hbWVdIDogbG9jYXRpb247IC8vIG90aGVyd2lzZSwgbmFtZWQgbG9jYXRpb24gb3Igcm9vdFxuXG4gICAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG4gICAgaWYgKG9iai5wdXNoKSB7XG4gICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XG4gICAgfVxuICB9O1xuICB2YXIgZ3JhbW1hciA9IGdyYW1tYXJFeHBvcnRzO1xuICB2YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcbiAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzZHApIHtcbiAgICB2YXIgc2Vzc2lvbiA9IHt9LFxuICAgICAgbWVkaWEgPSBbXSxcbiAgICAgIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgICAvLyBwYXJzZSBsaW5lcyB3ZSB1bmRlcnN0YW5kXG4gICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgICAgdmFyIGNvbnRlbnQgPSBsLnNsaWNlKDIpO1xuICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgICBtZWRpYS5wdXNoKHtcbiAgICAgICAgICBydHA6IFtdLFxuICAgICAgICAgIGZtdHA6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBsb2NhdGlvbiA9IG1lZGlhW21lZGlhLmxlbmd0aCAtIDFdOyAvLyBwb2ludCBhdCBsYXRlc3QgbWVkaWEgbGluZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIG9iaiA9IGdyYW1tYXJbdHlwZV1bal07XG4gICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfTtcbiAgdmFyIHBhcmFtUmVkdWNlciA9IGZ1bmN0aW9uIChhY2MsIGV4cHIpIHtcbiAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBhY2Nbc1swXV0gPSB0b0ludElmSW50KHNbMV0pO1xuICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH07XG4gIGV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gIH07XG5cbiAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcbiAgZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuICBleHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG4gIH07XG4gIGV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXG4gICAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9O1xuICBleHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aCAtIDEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgIH0pO1xuICB9O1xuICBleHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB2YXIgc2NpZCxcbiAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgICBwYXVzZWQ6IHBhdXNlZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59KShwYXJzZXIkMSk7XG5cbnZhciBncmFtbWFyID0gZ3JhbW1hckV4cG9ydHM7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclJSc6XG4gICAgICAgIHJldHVybiAnJSc7XG4gICAgICBjYXNlICclcyc6XG4gICAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICAgIGNhc2UgJyVkJzpcbiAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgICAgY2FzZSAnJXYnOlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9KTtcbiAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxufTtcbnZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pIDogb2JqLmZvcm1hdDtcbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xuICB9XG4gIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XG59O1xuXG4vLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4vLyBUT0RPOiBleHRlbmQgdGhpcyB3aXRoIGFsbCB0aGUgcmVzdFxudmFyIGRlZmF1bHRPdXRlck9yZGVyID0gWyd2JywgJ28nLCAncycsICdpJywgJ3UnLCAnZScsICdwJywgJ2MnLCAnYicsICd0JywgJ3InLCAneicsICdhJ107XG52YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcbnZhciB3cml0ZXIkMSA9IGZ1bmN0aW9uIChzZXNzaW9uLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gIGlmIChzZXNzaW9uLnZlcnNpb24gPT0gbnVsbCkge1xuICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcbiAgfVxuICBpZiAoc2Vzc2lvbi5uYW1lID09IG51bGwpIHtcbiAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxuICB9XG4gIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xuICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICB9XG4gIH0pO1xuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfSBlbHNlIGlmIChvYmoucHVzaCBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc2RwLmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbic7XG59O1xuXG52YXIgcGFyc2VyID0gcGFyc2VyJDE7XG52YXIgd3JpdGVyID0gd3JpdGVyJDE7XG52YXIgd3JpdGUgPSB3cml0ZXI7XG52YXIgcGFyc2UgPSBwYXJzZXIucGFyc2U7XG5wYXJzZXIucGFyc2VQYXJhbXM7XG5wYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxucGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5wYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xucGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xucGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcblxuLyogVGhlIHN2YyBjb2RlYyAoYXYxL3ZwOSkgd291bGQgdXNlIGEgdmVyeSBsb3cgYml0cmF0ZSBhdCB0aGUgYmVnaW5pbmcgYW5kXG5pbmNyZWFzZSBzbG93bHkgYnkgdGhlIGJhbmR3aWR0aCBlc3RpbWF0b3IgdW50aWwgaXQgcmVhY2ggdGhlIHRhcmdldCBiaXRyYXRlLiBUaGVcbnByb2Nlc3MgY29tbW9ubHkgY29zdCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBjYXVzZSBzdWJzY3JpYmVyIHdpbGwgZ2V0IGJsdXIgdmlkZW8gYXRcbnRoZSBmaXJzdCBmZXcgc2Vjb25kcy4gU28gd2UgdXNlIGEgNzAlIG9mIHRhcmdldCBiaXRyYXRlIGhlcmUgYXMgdGhlIHN0YXJ0IGJpdHJhdGUgdG9cbmVsaW1pbmF0ZSB0aGlzIGlzc3VlLlxuKi9cbmNvbnN0IHN0YXJ0Qml0cmF0ZUZvclNWQyA9IDAuNztcbmNvbnN0IFBDRXZlbnRzID0ge1xuICBOZWdvdGlhdGlvblN0YXJ0ZWQ6ICduZWdvdGlhdGlvblN0YXJ0ZWQnLFxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBwYygpIHtcbiAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGxldCBtZWRpYUNvbnN0cmFpbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzID0gW107XG4gICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gW107XG4gICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IFtdO1xuICAgIC8vIGRlYm91bmNlZCBuZWdvdGlhdGUgaW50ZXJmYWNlXG4gICAgdGhpcy5uZWdvdGlhdGUgPSByKG9uRXJyb3IgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCAxMDApO1xuICAgIHRoaXMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhQ29uc3RyYWludHMgPSBtZWRpYUNvbnN0cmFpbnRzO1xuICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICB9XG4gIGNyZWF0ZVBDKCkge1xuICAgIGNvbnN0IHBjID0gaXNDaHJvbWl1bUJhc2VkKCkgP1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2hyb21lIGFsbG93cyBhZGRpdGlvbmFsIG1lZGlhIGNvbnN0cmFpbnRzIHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBSVENQZWVyQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZywgdGhpcy5tZWRpYUNvbnN0cmFpbnRzKSA6IG5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLmNvbmZpZyk7XG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIWV2LmNhbmRpZGF0ZSkgcmV0dXJuO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYuY2FuZGlkYXRlKTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlZXJyb3IgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHBjLm9udHJhY2sgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBwYztcbiAgfVxuICBnZXQgaXNJQ0VDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjICE9PSBudWxsICYmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKTtcbiAgfVxuICBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbihzZCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IG11bmdlZFNEUCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc3RlcmVvTWlkcyxcbiAgICAgICAgICBuYWNrTWlkc1xuICAgICAgICB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XG4gICAgICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IHN0ZXJlb01pZHM7XG4gICAgICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBuYWNrTWlkcztcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoKF9hID0gc2Quc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XG4gICAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtZWRpYS5taWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyA9IGZtdHAuY29uZmlnLnNwbGl0KCc7JykuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaW5jbHVkZXMoJ21heGF2ZXJhZ2ViaXRyYXRlJykpLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjttYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IFwibWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbXVuZ2VkU0RQID0gd3JpdGUoc2RwUGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWRTRFAsIHRydWUpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgIHRoaXMucGMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmVuZWdvdGlhdGUpIHtcbiAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XG4gICAgICAgIGlmIChzZC5zZHApIHtcbiAgICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShzZC5zZHApO1xuICAgICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgbWVkaWEucnRwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJyk7XG4gICAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgICAvLyB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgcGVlciB0byBhY2NlcHQgb3VyIG9mZmVyLCBzbyB3ZSdsbCBqdXN0IHdhaXRcbiAgICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcbiAgICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpICYmIGN1cnJlbnRTRCkge1xuICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxuICAgICAgICAgIHlpZWxkIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGN1cnJlbnRTRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJyk7XG4gICAgICBjb25zdCBvZmZlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEpO1xuICAgICAgICAgIC8vIG11bmcgc2RwIGZvciBjb2RlYyBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcbiAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcbiAgICAgICAgICAgIGlmICghbWVkaWEubXNpZCB8fCAhdHJhY2tici5jaWQgfHwgIW1lZGlhLm1zaWQuaW5jbHVkZXModHJhY2tici5jaWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xuICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1zdGFydC1iaXRyYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KE1hdGgucm91bmQodHJhY2tici5tYXhiciAqIHN0YXJ0Qml0cmF0ZUZvclNWQykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCd4LWdvb2dsZS1tYXgtYml0cmF0ZScpKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjt4LWdvb2dsZS1tYXgtYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhicik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZtdHBGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogXCJ4LWdvb2dsZS1zdGFydC1iaXRyYXRlPVwiLmNvbmNhdChNYXRoLnJvdW5kKHRyYWNrYnIubWF4YnIgKiBzdGFydEJpdHJhdGVGb3JTVkMpLCBcIjt4LWdvb2dsZS1tYXgtYml0cmF0ZT1cIikuY29uY2F0KHRyYWNrYnIubWF4YnIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAob2ZmZXIsIHdyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBbmRTZXRBbnN3ZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoKF9hID0gYW5zd2VyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgdGhpcy5yZW1vdGVTdGVyZW9NaWRzLCB0aGlzLnJlbW90ZU5hY2tNaWRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChhbnN3ZXIsIHdyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFja0NvZGVjQml0cmF0ZShpbmZvKSB7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzLnB1c2goaW5mbyk7XG4gIH1cbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gIH1cbiAgY2FuUmVtb3ZlVHJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldElDRUNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmljZUNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsaW5nU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldFRyYW5zY2VpdmVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRTZW5kZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VuZGVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uO1xuICB9XG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZURlc2NyaXB0aW9uO1xuICB9XG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gJyc7XG4gICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXAoKTtcbiAgICAgIC8vIGlkIC0+IGNhbmRpZGF0ZSBpcFxuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIHN3aXRjaCAodi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9IHYuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZW1vdGUtY2FuZGlkYXRlJzpcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIFwiXCIuY29uY2F0KHYuYWRkcmVzcywgXCI6XCIpLmNvbmNhdCh2LnBvcnQpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkSUQgPSAoX2EgPSBjYW5kaWRhdGVQYWlycy5nZXQoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgICBpZiAoc2VsZWN0ZWRJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlcy5nZXQoc2VsZWN0ZWRJRCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWQsIHJlbW90ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAobXVuZ2VkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2RwID0gc2Quc2RwO1xuICAgICAgICBzZC5zZHAgPSBtdW5nZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNldHRpbmcgbXVuZ2VkIFwiLmNvbmNhdChyZW1vdGUgPyAncmVtb3RlJyA6ICdsb2NhbCcsIFwiIGRlc2NyaXB0aW9uXCIpKTtcbiAgICAgICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwibm90IGFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlLCBcIiwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwXCIpLCB7XG4gICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgIHNkcDogbXVuZ2VkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2Quc2RwID0gb3JpZ2luYWxTZHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2Fubm90IGFsd2F5cyBiZSBjYXVnaHQuXG4gICAgICAgIC8vIElmIHRoZSBsb2NhbCBkZXNjcmlwdGlvbiBoYXMgYSBzZXRDb2RlY1ByZWZlcmVuY2VzIGVycm9yLCB0aGlzIGVycm9yIHdpbGwgYmUgdW5jYXVnaHRcbiAgICAgICAgbGV0IG1zZyA9ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG1zZyA9IGUubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtc2cgPSBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHtcbiAgICAgICAgICBlcnJvcjogbXNnLFxuICAgICAgICAgIHNkcDogc2Quc2RwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVtb3RlICYmIHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKFwidW5hYmxlIHRvIHNldCBcIi5jb25jYXQoc2QudHlwZSksIGZpZWxkcyk7XG4gICAgICAgIHRocm93IG5ldyBOZWdvdGlhdGlvbkVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgc3RlcmVvTWlkcywgbmFja01pZHMpIHtcbiAgLy8gZm91bmQgb3B1cyBjb2RlYyB0byBhZGQgbmFjayBmYlxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xuICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICAvLyBhZGQgbmFjayBydGNwZmIgaWYgbm90IGV4aXN0XG4gIGlmIChvcHVzUGF5bG9hZCA+IDApIHtcbiAgICBpZiAoIW1lZGlhLnJ0Y3BGYikge1xuICAgICAgbWVkaWEucnRjcEZiID0gW107XG4gICAgfVxuICAgIGlmIChuYWNrTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpICYmICFtZWRpYS5ydGNwRmIuc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XG4gICAgICBtZWRpYS5ydGNwRmIucHVzaCh7XG4gICAgICAgIHBheWxvYWQ6IG9wdXNQYXlsb2FkLFxuICAgICAgICB0eXBlOiAnbmFjaydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RlcmVvTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpKSB7XG4gICAgICBtZWRpYS5mbXRwLnNvbWUoZm10cCA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJztzdGVyZW89MSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IGNvZGVjID0gKF9iID0gKF9hID0gbWVkaWEucnRwWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZWMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWlzU1ZDQ29kZWMoY29kZWMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtYXhJRCA9IDA7XG4gIGNvbnN0IGRkRm91bmQgPSAoX2MgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zb21lKGV4dCA9PiB7XG4gICAgaWYgKGV4dC51cmkgPT09IGRkRXh0ZW5zaW9uVVJJKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGV4dC52YWx1ZSA+IG1heElEKSB7XG4gICAgICBtYXhJRCA9IGV4dC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgaWYgKCFkZEZvdW5kKSB7XG4gICAgKF9kID0gbWVkaWEuZXh0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucHVzaCh7XG4gICAgICB2YWx1ZTogbWF4SUQgKyAxLFxuICAgICAgdXJpOiBkZEV4dGVuc2lvblVSSVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKG9mZmVyKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc3RlcmVvTWlkcyA9IFtdO1xuICBjb25zdCBuYWNrTWlkcyA9IFtdO1xuICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcbiAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgbWVkaWEucnRwLnNvbWUocnRwID0+IHtcbiAgICAgICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmICgoX2EgPSBtZWRpYS5ydGNwRmIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgICAgbmFja01pZHMucHVzaChtZWRpYS5taWQpO1xuICAgICAgfVxuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xuICAgICAgICAgIGlmIChmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3Byb3Atc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgc3RlcmVvTWlkcy5wdXNoKG1lZGlhLm1pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3RlcmVvTWlkcyxcbiAgICBuYWNrTWlkc1xuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0VmlkZW9Db2RlYyA9ICd2cDgnO1xuY29uc3QgcHVibGlzaERlZmF1bHRzID0ge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGF1ZGlvQml0cmF0ZTogQXVkaW9QcmVzZXRzLm11c2ljLm1heEJpdHJhdGUsXG4gIGF1ZGlvUHJlc2V0OiBBdWRpb1ByZXNldHMubXVzaWMsXG4gIGR0eDogdHJ1ZSxcbiAgcmVkOiB0cnVlLFxuICBmb3JjZVN0ZXJlbzogZmFsc2UsXG4gIHNpbXVsY2FzdDogdHJ1ZSxcbiAgc2NyZWVuU2hhcmVFbmNvZGluZzogU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMTUuZW5jb2RpbmcsXG4gIHN0b3BNaWNUcmFja09uTXV0ZTogZmFsc2UsXG4gIHZpZGVvQ29kZWM6IGRlZmF1bHRWaWRlb0NvZGVjLFxuICBiYWNrdXBDb2RlYzogdHJ1ZVxufTtcbmNvbnN0IGF1ZGlvRGVmYXVsdHMgPSB7XG4gIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZVxufTtcbmNvbnN0IHZpZGVvRGVmYXVsdHMgPSB7XG4gIHJlc29sdXRpb246IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb25cbn07XG5jb25zdCByb29tT3B0aW9uRGVmYXVsdHMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgZXhwV2ViQXVkaW9NaXg6IGZhbHNlXG59O1xuY29uc3Qgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyA9IHtcbiAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgbWF4UmV0cmllczogMSxcbiAgcGVlckNvbm5lY3Rpb25UaW1lb3V0OiAxNTAwMCxcbiAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcbn07XG5cbnZhciBQQ1RyYW5zcG9ydFN0YXRlO1xuKGZ1bmN0aW9uIChQQ1RyYW5zcG9ydFN0YXRlKSB7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIk5FV1wiXSA9IDBdID0gXCJORVdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDJdID0gXCJDT05ORUNURURcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiRkFJTEVEXCJdID0gM10gPSBcIkZBSUxFRFwiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TSU5HXCJdID0gNF0gPSBcIkNMT1NJTkdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0VEXCJdID0gNV0gPSBcIkNMT1NFRFwiO1xufSkoUENUcmFuc3BvcnRTdGF0ZSB8fCAoUENUcmFuc3BvcnRTdGF0ZSA9IHt9KSk7XG5jbGFzcyBQQ1RyYW5zcG9ydE1hbmFnZXIge1xuICBnZXQgbmVlZHNQdWJsaXNoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cbiAgZ2V0IG5lZWRzU3Vic2NyaWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBjb25zdHJ1Y3RvcihydGNDb25maWcsIHN1YnNjcmliZXJQcmltYXJ5KSB7XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKHRyID0+IHRyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY29ubmVjdGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQ7XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuc29tZShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnbmV3JykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInBjIHN0YXRlIGNoYW5nZTogZnJvbSBcIi5jb25jYXQoUENUcmFuc3BvcnRTdGF0ZVtwcmV2aW91c1N0YXRlXSwgXCIgdG8gXCIpLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3RoaXMuc3RhdGVdKSk7XG4gICAgICAgIChfYSA9IHRoaXMub25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksIHRoaXMuc3Vic2NyaWJlci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkID0gIXN1YnNjcmliZXJQcmltYXJ5O1xuICAgIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkID0gc3Vic2NyaWJlclByaW1hcnk7XG4gICAgY29uc3QgZ29vZ0NvbnN0cmFpbnRzID0ge1xuICAgICAgb3B0aW9uYWw6IFt7XG4gICAgICAgIGdvb2dEc2NwOiB0cnVlXG4gICAgICB9XVxuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBnb29nQ29uc3RyYWludHMpO1xuICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcpO1xuICAgIHRoaXMucHVibGlzaGVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xuICAgIH07XG4gICAgLy8gaW4gc3Vic2NyaWJlciBwcmltYXJ5IG1vZGUsIHNlcnZlciBzaWRlIG9wZW5zIHN1YiBkYXRhIGNoYW5uZWxzLlxuICAgIHRoaXMuc3Vic2NyaWJlci5vbkRhdGFDaGFubmVsID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25UcmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgdGhpcy5wdWJsaXNoZXIub25PZmZlciA9IG9mZmVyID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25QdWJsaXNoZXJPZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgb2ZmZXIpO1xuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgfVxuICByZXF1aXJlUHVibGlzaGVyKCkge1xuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuICByZXF1aXJlU3Vic2NyaWJlcigpIHtcbiAgICBsZXQgcmVxdWlyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcbiAgfVxuICBzZXRQdWJsaXNoZXJBbnN3ZXIoc2QpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICB9XG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wdWJsaXNoZXIgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBoYXZlIHJlbW92ZVRyYWNrIHlldC5cbiAgICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xuICAgICAgICAgICAgICBwdWJsaXNoZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZW1vdmVUcmFjaycsIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW3RoaXMucHVibGlzaGVyLmNsb3NlKCksIHRoaXMuc3Vic2NyaWJlci5jbG9zZSgpXSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJpZ2dlckljZVJlc3RhcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLm5lZWRzUHVibGlzaGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKHtcbiAgICAgICAgICBpY2VSZXN0YXJ0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIG9mZmVyJywge1xuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxuICAgICAgICBzaWduYWxpbmdTdGF0ZTogdGhpcy5zdWJzY3JpYmVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgIC8vIGFuc3dlciB0aGUgb2ZmZXJcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICAgIHJldHVybiBhbnN3ZXI7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWcsIGljZVJlc3RhcnQpIHtcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgdGhpcy5zdWJzY3JpYmVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICBpZiAoaWNlUmVzdGFydCkge1xuICAgICAgdGhpcy50cmlnZ2VySWNlUmVzdGFydCgpO1xuICAgIH1cbiAgfVxuICBlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnbmVnb3RpYXRpb24gcmVxdWlyZWQsIHN0YXJ0IG5lZ290aWF0aW5nJyk7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoKF9hID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAodHJhbnNwb3J0ID0+IHRoaXMuZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHRyYW5zcG9ydCwgYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBuZWdvdGlhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKGUgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcmVxdWlyZWQgdHJhbnNwb3J0J3MgYWRkcmVzcyBpZiBubyBleHBsaWNpdCB0YXJnZXQgaXMgc3BlY2lmaWVkXG4gICAqL1xuICBnZXRDb25uZWN0ZWRBZGRyZXNzKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHNbMF0uZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICB9XG4gIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0cyA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQocGNUcmFuc3BvcnQsIGFib3J0Q29udHJvbGxlcikge1xuICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlID0gcGNUcmFuc3BvcnQuZ2V0Q29ubmVjdGlvblN0YXRlKCk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhYm9ydCB0cmFuc3BvcnQgY29ubmVjdGlvbicpO1xuICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQnLCAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdjb3VsZCBub3QgZXN0YWJsaXNoIHBjIGNvbm5lY3Rpb24nKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIDMgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAqLykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG52YXIgUENTdGF0ZTtcbihmdW5jdGlvbiAoUENTdGF0ZSkge1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJOZXdcIl0gPSAwXSA9IFwiTmV3XCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDFdID0gXCJDb25uZWN0ZWRcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMl0gPSBcIkRpc2Nvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSAzXSA9IFwiUmVjb25uZWN0aW5nXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcbn0pKFBDU3RhdGUgfHwgKFBDU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkO1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydGNDb25maWcgPSB7fTtcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IGZhbHNlO1xuICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBmYWxzZTtcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLk5ldztcbiAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnMgPSB7fTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gMDtcbiAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAvKioga2VlcHMgdHJhY2sgb2YgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGhhcyBiZWVuIHRyaWVkICovXG4gICAgdGhpcy5qb2luQXR0ZW1wdHMgPSAwO1xuICAgIC8qKiBzcGVjaWZpZXMgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gcmV0cnkgKi9cbiAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IDE7XG4gICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwgPSBfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNoYW5uZWxcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsLmxhYmVsID09PSBsb3NzeURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIm9uIGRhdGEgY2hhbm5lbCBcIi5jb25jYXQoY2hhbm5lbC5pZCwgXCIsIFwiKS5jb25jYXQoY2hhbm5lbC5sYWJlbCkpO1xuICAgICAgICBjaGFubmVsLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2UgPSBtZXNzYWdlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzcGVjdCBpbmNvbWluZyBkYXRhIG1lc3NhZ2Ugb3JkZXIgYnkgcHJvY2Vzc2luZyBtZXNzYWdlIGV2ZW50cyBvbmUgYWZ0ZXIgdGhlIG90aGVyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmRhdGFQcm9jZXNzTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBkZWNvZGVcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICBidWZmZXIgPSB5aWVsZCBtZXNzYWdlLmRhdGEuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCd1bnN1cHBvcnRlZCBkYXRhIHR5cGUnLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcCA9IERhdGFQYWNrZXQuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgaWYgKCgoX2EgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBzcGVha2VyIHVwZGF0ZXNcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKF9iID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgZHAudmFsdWUudmFsdWUsIGRwLmtpbmQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZURhdGFFcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gJ2xvc3N5JyA6ICdyZWxpYWJsZSc7XG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFcnJvckV2ZW50ICYmIGV2ZW50LmVycm9yKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9ID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoXCJEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQsIFwiOiBcIikuY29uY2F0KGV2ZW50Lm1lc3NhZ2UpLCBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKFwiVW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQpLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyBEYXRhUGFja2V0X0tpbmQuTE9TU1kgOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XG4gICAgfTtcbiAgICAvLyB3ZWJzb2NrZXQgcmVjb25uZWN0IGJlaGF2aW9yLiBpZiB3ZWJzb2NrZXQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aGUgUGVlckNvbm5lY3Rpb25cbiAgICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cbiAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IChjb25uZWN0aW9uLCBkaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiXCIuY29uY2F0KGNvbm5lY3Rpb24sIFwiIGRpc2Nvbm5lY3RlZFwiKSk7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xuICAgICAgICAvLyBvbmx5IHJlc2V0IHN0YXJ0IHRpbWUgb24gdGhlIGZpcnN0IHRyeVxuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2Nvbm5lY3QgPSBkdXJhdGlvbiA9PiB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KGR1cmF0aW9uLCBcIm1zLiBnaXZpbmcgdXBcIikpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XG4gICAgICBsZXQgZGVsYXkgPSB0aGlzLmdldE5leHRSZXRyeURlbGF5KHtcbiAgICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcbiAgICAgICAgcmV0cnlDb3VudDogdGhpcy5yZWNvbm5lY3RBdHRlbXB0c1xuICAgICAgfSk7XG4gICAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcbiAgICAgICAgZGlzY29ubmVjdChkdXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uZWN0aW9uID09PSBsZWF2ZVJlY29ubmVjdCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwicmVjb25uZWN0aW5nIGluIFwiLmNvbmNhdChkZWxheSwgXCJtc1wiKSk7XG4gICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXG4gICAgICAgIC8vIHNpbmNlIHRoZSBjdXJyZW50IGVuZ2luZSBtYXkgaGF2ZSBpbmhlcml0ZWQgYSByZWdpb25hbCB1cmxcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRlbXB0UmVjb25uZWN0KGRpc2Nvbm5lY3RSZWFzb24pLCBkZWxheSk7XG4gICAgfTtcbiAgICB0aGlzLndhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvblJlc3RhcnRlZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMgPSBraW5kID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCk7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdHVzICE9PSB0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xuICAgICAgICB0aGlzLmRjQnVmZmVyU3RhdHVzLnNldChraW5kLCBzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyA9IGtpbmQgPT4ge1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICByZXR1cm4gZGMuYnVmZmVyZWRBbW91bnQgPD0gZGMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUgPSAoKSA9PiB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHJlY29ubmVjdGluZywgYXR0ZW1wdCBhIHJlY29ubmVjdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYnJvd3NlciBzdGF0ZSBoYXMgY2hhbmdlZCB0byAnb25MaW5lJ1xuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgdGhpcy5jbGllbnQuc2lnbmFsTGF0ZW5jeSA9IHRoaXMub3B0aW9ucy5leHBTaWduYWxMYXRlbmN5O1xuICAgIHRoaXMucmVjb25uZWN0UG9saWN5ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdFBvbGljeTtcbiAgICB0aGlzLnJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmRjQnVmZmVyU3RhdHVzID0gbmV3IE1hcChbW0RhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZV0sIFtEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWVdXSk7XG4gICAgdGhpcy5jbGllbnQub25QYXJ0aWNpcGFudFVwZGF0ZSA9IHVwZGF0ZXMgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB1cGRhdGVzKTtcbiAgICB0aGlzLmNsaWVudC5vbkNvbm5lY3Rpb25RdWFsaXR5ID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblJvb21VcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25FcnJvciA9IHJlc3AgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCByZXNwKTtcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TcGVha2Vyc0NoYW5nZWQgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblN0cmVhbVN0YXRlVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHVwZGF0ZSk7XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuc2lnbmFsT3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IG9wdHMubWF4UmV0cmllcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5jbGllbnQuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlID0gam9pblJlc3BvbnNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgb2ZmZXJcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJQcmltYXJ5KSB7XG4gICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24gPSBqb2luUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIGpvaW5SZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICBpZiAoZS5yZWFzb24gPT09IDEgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlICovKSB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5qb2luQXR0ZW1wdHMsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5tYXhKb2luQXR0ZW1wdHMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNsb3NpbmdMb2NrLmxvY2soKTtcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5DbG9zaW5nKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cFBlZXJDb25uZWN0aW9ucygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZGNDbGVhbnVwID0gZGMgPT4ge1xuICAgICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICAgIGRjLmNsb3NlKCk7XG4gICAgICAgIGRjLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zaW5nID0gbnVsbDtcbiAgICAgICAgZGMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGRjLm9ub3BlbiA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDU3ViKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlREMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG4gICAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvc3N5RENTdWIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlREMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cENsaWVudCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlc2V0Q2FsbGJhY2tzKCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkVHJhY2socmVxKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ2EgdHJhY2sgd2l0aCB0aGUgc2FtZSBJRCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHVibGljYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXTtcbiAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInKSk7XG4gICAgICB9LCAxMDAwMCk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSA9IHtcbiAgICAgICAgcmVzb2x2ZTogaW5mbyA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0OiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2FuY2VsbGVkIHB1YmxpY2F0aW9uIGJ5IGNhbGxpbmcgdW5wdWJsaXNoJykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgc2VuZGVyIGZyb20gUGVlckNvbm5lY3Rpb24sIHJldHVybmluZyB0cnVlIGlmIGl0IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseVxuICAgKiBhbmQgYSBuZWdvdGlhdGlvbiBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHNlbmRlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlci50cmFjayAmJiB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlamVjdFxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBjTWFuYWdlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdmYWlsZWQgdG8gcmVtb3ZlIHRyYWNrJywge1xuICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgbWV0aG9kOiAncmVtb3ZlVHJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZU11dGVTdGF0dXModHJhY2tTaWQsIG11dGVkKSB7XG4gICAgdGhpcy5jbGllbnQuc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpO1xuICB9XG4gIGdldCBkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJlbGlhYmxlRENTdWIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlO1xuICB9XG4gIGdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHNldFJlZ2lvblVybFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHByb3ZpZGVyO1xuICB9XG4gIGNvbmZpZ3VyZShqb2luUmVzcG9uc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxuICAgICAgaWYgKHRoaXMucGNNYW5hZ2VyICYmIHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcbiAgICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHRoaXMubWFrZVJUQ0NvbmZpZ3VyYXRpb24oam9pblJlc3BvbnNlKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gbmV3IFBDVHJhbnNwb3J0TWFuYWdlcihydGNDb25maWcsIGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeSk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuVHJhbnNwb3J0c0NyZWF0ZWQsIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlciwgdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlcik7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblB1Ymxpc2hlck9mZmVyID0gb2ZmZXIgPT4ge1xuICAgICAgICB0aGlzLmNsaWVudC5zZW5kT2ZmZXIob2ZmZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25TdGF0ZUNoYW5nZSA9IChjb25uZWN0aW9uU3RhdGUsIHB1Ymxpc2hlclN0YXRlLCBzdWJzY3JpYmVyU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInByaW1hcnkgUEMgc3RhdGUgY2hhbmdlZCBcIi5jb25jYXQoY29ubmVjdGlvblN0YXRlKSk7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5OZXc7XG4gICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgICAgaWYgKHNob3VsZEVtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQpIHtcbiAgICAgICAgICAvLyBvbiBTYWZhcmksIFBlZXJDb25uZWN0aW9uIHdpbGwgc3dpdGNoIHRvICdkaXNjb25uZWN0ZWQnIGR1cmluZyByZW5lZ290aWF0aW9uXG4gICAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLCBzdWJzY3JpYmVyU3RhdGUgPT09ICdmYWlsZWQnID8gUmVjb25uZWN0UmVhc29uLlJSX1NVQlNDUklCRVJfRkFJTEVEIDogUmVjb25uZWN0UmVhc29uLlJSX1BVQkxJU0hFUl9GQUlMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBjTWFuYWdlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCBldi50cmFjaywgZXYuc3RyZWFtc1swXSwgZXYucmVjZWl2ZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKSB7XG4gICAgLy8gY29uZmlndXJlIHNpZ25hbGluZyBjbGllbnRcbiAgICB0aGlzLmNsaWVudC5vbkFuc3dlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIGFuc3dlcicsIHtcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5zZXRQdWJsaXNoZXJBbnN3ZXIoc2QpO1xuICAgIH0pO1xuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdnb3QgSUNFIGNhbmRpZGF0ZSBmcm9tIHBlZXInLCB7XG4gICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNlcnZlciBjcmVhdGVzIGFuIG9mZmVyIGZvciB0aGUgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25PZmZlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcmVzID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3JlY2VpdmVkIHRyYWNrUHVibGlzaGVkUmVzcG9uc2UnLCByZXMpO1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKFwibWlzc2luZyB0cmFjayByZXNvbHZlciBmb3IgXCIuY29uY2F0KHJlcy5jaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXNvbHZlXG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICByZXNvbHZlKHJlcy50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9IHRva2VuID0+IHtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgdHJhY2tTaWQsIG11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25MZWF2ZSA9IGxlYXZlID0+IHtcbiAgICAgIGlmIChsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUuY2FuUmVjb25uZWN0KSB7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG5leHQgYXR0ZW1wdFxuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvbik7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGxpdmVraXRMb2dnZXIudHJhY2UoJ2xlYXZlIHJlcXVlc3QnLCB7XG4gICAgICAgIGxlYXZlXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIG1ha2VSVENDb25maWd1cmF0aW9uKHNlcnZlclJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucnRjQ29uZmlnKTtcbiAgICBpZiAoKF9hID0gdGhpcy5zaWduYWxPcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZTJlZUVuYWJsZWQpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ0UyRUUgLSBzZXR0aW5nIHVwIHRyYW5zcG9ydHMgd2l0aCBpbnNlcnRhYmxlIHN0cmVhbXMnKTtcbiAgICAgIC8vICB0aGlzIG1ha2VzIHN1cmUgdGhhdCBubyBkYXRhIGlzIHNlbnQgYmVmb3JlIHRoZSB0cmFuc2Zvcm1zIGFyZSByZWFkeVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcnRjQ29uZmlnLmVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBJQ0Ugc2VydmVycyBiZWZvcmUgY3JlYXRpbmcgUGVlckNvbm5lY3Rpb25cbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycyAmJiAhcnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMuZm9yRWFjaChpY2VTZXJ2ZXIgPT4ge1xuICAgICAgICBjb25zdCBydGNJY2VTZXJ2ZXIgPSB7XG4gICAgICAgICAgdXJsczogaWNlU2VydmVyLnVybHNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGljZVNlcnZlci51c2VybmFtZSkgcnRjSWNlU2VydmVyLnVzZXJuYW1lID0gaWNlU2VydmVyLnVzZXJuYW1lO1xuICAgICAgICBpZiAoaWNlU2VydmVyLmNyZWRlbnRpYWwpIHtcbiAgICAgICAgICBydGNJY2VTZXJ2ZXIuY3JlZGVudGlhbCA9IGljZVNlcnZlci5jcmVkZW50aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJ0Y0ljZVNlcnZlcnMucHVzaChydGNJY2VTZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgICBydGNDb25maWcuaWNlU2VydmVycyA9IHJ0Y0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uICYmIHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24uZm9yY2VSZWxheSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5FTkFCTEVEKSB7XG4gICAgICBydGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5ID0gJ3JlbGF5JztcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5zZHBTZW1hbnRpY3MgPSAndW5pZmllZC1wbGFuJztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLmNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSA9ICdnYXRoZXJfY29udGludWFsbHknO1xuICAgIHJldHVybiBydGNDb25maWc7XG4gIH1cbiAgY3JlYXRlRGF0YUNoYW5uZWxzKCkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2xlYXIgb2xkIGRhdGEgY2hhbm5lbCBjYWxsYmFja3MgaWYgcmVjcmVhdGVcbiAgICBpZiAodGhpcy5sb3NzeURDKSB7XG4gICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsaWFibGVEQykge1xuICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IG51bGw7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBkYXRhIGNoYW5uZWxzXG4gICAgdGhpcy5sb3NzeURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobG9zc3lEYXRhQ2hhbm5lbCwge1xuICAgICAgLy8gd2lsbCBkcm9wIG9sZGVyIHBhY2tldHMgdGhhdCBhcnJpdmVcbiAgICAgIG9yZGVyZWQ6IHRydWUsXG4gICAgICBtYXhSZXRyYW5zbWl0czogMFxuICAgIH0pO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKHJlbGlhYmxlRGF0YUNoYW5uZWwsIHtcbiAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICB9KTtcbiAgICAvLyBhbHNvIGhhbmRsZSBtZXNzYWdlcyBvdmVyIHRoZSBwdWIgY2hhbm5lbCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XG4gICAgLy8gaGFuZGxlIGRhdGFjaGFubmVsIGVycm9yc1xuICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XG4gICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICAvLyBzZXQgdXAgZGMgYnVmZmVyIHRocmVzaG9sZCwgc2V0IHRvIDY0a0IgKG90aGVyd2lzZSAwIGJ5IGRlZmF1bHQpXG4gICAgdGhpcy5sb3NzeURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG4gICAgdGhpcy5yZWxpYWJsZURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG4gICAgLy8gaGFuZGxlIGJ1ZmZlciBhbW91bnQgbG93IGV2ZW50c1xuICAgIHRoaXMubG9zc3lEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgICB0aGlzLnJlbGlhYmxlREMub25idWZmZXJlZGFtb3VudGxvdyA9IHRoaXMuaGFuZGxlQnVmZmVyZWRBbW91bnRMb3c7XG4gIH1cbiAgc2V0UHJlZmVycmVkQ29kZWModHJhbnNjZWl2ZXIsIGtpbmQsIHZpZGVvQ29kZWMpIHtcbiAgICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhcCA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoa2luZCk7XG4gICAgaWYgKCFjYXApIHJldHVybjtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdnZXQgY2FwYWJpbGl0aWVzJywgY2FwKTtcbiAgICBjb25zdCBtYXRjaGVkID0gW107XG4gICAgY29uc3QgcGFydGlhbE1hdGNoZWQgPSBbXTtcbiAgICBjb25zdCB1bm1hdGNoZWQgPSBbXTtcbiAgICBjYXAuY29kZWNzLmZvckVhY2goYyA9PiB7XG4gICAgICBjb25zdCBjb2RlYyA9IGMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChjb2RlYyA9PT0gJ2F1ZGlvL29wdXMnKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF0Y2hlc1ZpZGVvQ29kZWMgPSBjb2RlYyA9PT0gXCJ2aWRlby9cIi5jb25jYXQodmlkZW9Db2RlYyk7XG4gICAgICBpZiAoIW1hdGNoZXNWaWRlb0NvZGVjKSB7XG4gICAgICAgIHVubWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBmb3IgaDI2NCBjb2RlY3MgdGhhdCBoYXZlIHNkcEZtdHBMaW5lIGF2YWlsYWJsZSwgdXNlIG9ubHkgaWYgdGhlXG4gICAgICAvLyBwcm9maWxlLWxldmVsLWlkIGlzIDQyZTAxZiBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAodmlkZW9Db2RlYyA9PT0gJ2gyNjQnKSB7XG4gICAgICAgIGlmIChjLnNkcEZtdHBMaW5lICYmIGMuc2RwRm10cExpbmUuaW5jbHVkZXMoJ3Byb2ZpbGUtbGV2ZWwtaWQ9NDJlMDFmJykpIHtcbiAgICAgICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydGlhbE1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaGVkLnB1c2goYyk7XG4gICAgfSk7XG4gICAgaWYgKHN1cHBvcnRzU2V0Q29kZWNQcmVmZXJlbmNlcyh0cmFuc2NlaXZlcikpIHtcbiAgICAgIHRyYW5zY2VpdmVyLnNldENvZGVjUHJlZmVyZW5jZXMobWF0Y2hlZC5jb25jYXQocGFydGlhbE1hdGNoZWQsIHVubWF0Y2hlZCkpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybigndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJyk7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1JlcXVpcmVkIHdlYlJUQyBBUElzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gc3RvcmUgUlRDUnRwU2VuZGVyXG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgICBpZiAodHJhY2subWVkaWFTdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKHRyYWNrLm1lZGlhU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcbiAgICAgICAgZGlyZWN0aW9uOiAnc2VuZG9ubHknLFxuICAgICAgICBzdHJlYW1zXG4gICAgICB9O1xuICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0geWllbGQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2subWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIG9wdHMudmlkZW9Db2RlYykge1xuICAgICAgICB0aGlzLnNldFByZWZlcnJlZENvZGVjKHRyYW5zY2VpdmVyLCB0cmFjay5raW5kLCBvcHRzLnZpZGVvQ29kZWMpO1xuICAgICAgICB0cmFjay5jb2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seSdcbiAgICAgIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcihzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgaWYgKCFvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQcmVmZXJyZWRDb2RlYyh0cmFuc2NlaXZlciwgdHJhY2sua2luZCwgb3B0cy52aWRlb0NvZGVjKTtcbiAgICAgIHRyYWNrLnNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKG9wdHMudmlkZW9Db2RlYywgdHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFjayh0cmFjayk7XG4gICAgfSk7XG4gIH1cbiAgYXR0ZW1wdFJlY29ubmVjdChyZWFzb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcbiAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVDb25uZWN0aW9uKSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5ESVNBQkxFRCB8fFxuICAgICAgLy8gc2lnbmFsaW5nIHN0YXRlIGNvdWxkIGNoYW5nZSB0byBjbG9zZWQgZHVlIHRvIGhhcmR3YXJlIHNsZWVwXG4gICAgICAvLyB0aG9zZSBjb25uZWN0aW9ucyBjYW5ub3QgYmUgcmVzdW1lZFxuICAgICAgKChfYyA9IChfYiA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VycmVudFN0YXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5mdWxsUmVjb25uZWN0T25OZXh0KSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdW1lQ29ubmVjdGlvbihyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzICs9IDE7XG4gICAgICAgIGxldCByZWNvdmVyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3JlY2VpdmVkIHVucmVjb3ZlcmFibGUgZXJyb3InLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIHVucmVjb3ZlcmFibGVcbiAgICAgICAgICByZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xuICAgICAgICAgIC8vIGNhbm5vdCByZXN1bWVcbiAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncmVjb25uZWN0JywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0LCBcIm1zLiBnaXZpbmcgdXBcIikpO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dFJldHJ5RGVsYXkoY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RQb2xpY3kubmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIHtcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlcnJvciBpbiB1c2VyIGNvZGUgd2l0aCBwcm92aWRlZCByZWNvbm5lY3QgcG9saWN5LCBzdG9wIHJlY29ubmVjdGluZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3RhcnRDb25uZWN0aW9uKHJlZ2lvblVybCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJyZWNvbm5lY3RpbmcsIGF0dGVtcHQ6IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBDbGllbnQoKTtcbiAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2lnbmFsT3B0cykge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhdHRlbXB0ZWQgY29ubmVjdGlvbiByZXN0YXJ0LCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIHByZXNlbnQnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbiBjYXNlIGEgcmVnaW9uVXJsIGlzIHBhc3NlZCwgdGhlIHJlZ2lvbiBVUkwgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgIGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuam9pbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSAwIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkICovKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xuICAgICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcbiAgICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuICAgICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSB5aWVsZCAoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKG5leHRSZWdpb25VcmwpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBtb3JlIHJlZ2lvbnMgdG8gdHJ5IChvciB3ZSdyZSBub3Qgb24gY2xvdWQpXG4gICAgICAgICAgKF9jID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc2V0QXR0ZW1wdHMoKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgIC8vIHBlcm1hbmVudCBmYWlsdXJlLCBkb24ndCBhdHRlbXB0IHJlY29ubmVjdGlvblxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgICAgfVxuICAgICAgLy8gdHJpZ2dlciBwdWJsaXNoZXIgcmVjb25uZWN0XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcbiAgICAgIH1cbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcInJlc3VtaW5nIHNpZ25hbCBjb25uZWN0aW9uLCBhdHRlbXB0IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5yZWNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMucGFydGljaXBhbnRTaWQsIHJlYXNvbik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKHJlcyk7XG4gICAgICAgICAgdGhpcy5wY01hbmFnZXIudXBkYXRlQ29uZmlndXJhdGlvbihydGNDb25maWcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlLnJlYXNvbiA9PT0gMCAvKiBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCAqLykge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci50cmlnZ2VySWNlUmVzdGFydCgpO1xuICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgICAvLyAoZm9yIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0Njg4KVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlbGlhYmxlREMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nICYmIHRoaXMucmVsaWFibGVEQy5pZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgICAgLy8gcmVzdW1lIHN1Y2Nlc3NcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWVkKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JQQ1JlY29ubmVjdGVkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3dhaXRpbmcgZm9yIHBlZXIgY29ubmVjdGlvbiB0byByZWNvbm5lY3QnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHNsZWVwKG1pblJlY29ubmVjdFdhaXQpOyAvLyBGSVhNRSBzZXRUaW1lb3V0IGFnYWluIG5vdCBpZGVhbCBmb3IgYSBjb25uZWN0aW9uIGNyaXRpY2FsIHBhdGhcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCBhIGBmYWlsZWRgIHN0YXRlIGhlcmUgZm9yIHRoZSBQQz9cbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sIFwiLmNvbmNhdChlLm1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IHBhY2tldC50b0JpbmFyeSgpO1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpO1xuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICAgIGlmIChkYykge1xuICAgICAgICBkYy5zZW5kKG1zZyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhraW5kKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmQpIHtcbiAgICBsZXQgc3Vic2NyaWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBzdWJzY3JpYmVyID8gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlciA6IHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlcjtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSBzdWJzY3JpYmVyID8gJ1N1YnNjcmliZXInIDogJ1B1Ymxpc2hlcic7XG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24gbm90IHNldFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN1YnNjcmliZXIgJiYgIXRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5pc0lDRUNvbm5lY3RlZCAmJiB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkgIT09ICdjaGVja2luZycpIHtcbiAgICAgICAgLy8gc3RhcnQgbmVnb3RpYXRpb25cbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKTtcbiAgICAgIGlmICgodGFyZ2V0Q2hhbm5lbCA9PT0gbnVsbCB8fCB0YXJnZXRDaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDaGFubmVsLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gd2FpdCB1bnRpbCBJQ0UgY29ubmVjdGVkXG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHdoaWxlIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA8IGVuZFRpbWUpIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJiAoKF9hID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uLCBzdGF0ZTogXCIpLmNvbmNhdCh0cmFuc3BvcnQuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkpKTtcbiAgICB9KTtcbiAgfVxuICBlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICB2ZXJpZnlUcmFuc3BvcnQoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwcmltYXJ5IGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgc2lnbmFsIGlzIGNvbm5lY3RlZFxuICAgIGlmICghdGhpcy5jbGllbnQud3MgfHwgdGhpcy5jbGllbnQud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIG5lZ290aWF0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gb2JzZXJ2ZSBzaWduYWwgc3RhdGVcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgICByZWplY3QobmV3IE5lZ290aWF0aW9uRXJyb3IoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBjTWFuYWdlci5yZXF1aXJlUHVibGlzaGVyKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2VuZ2luZSBkaXNjb25uZWN0ZWQgd2hpbGUgbmVnb3RpYXRpb24gd2FzIG9uZ29pbmcnKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgIHJlamVjdCgnY2Fubm90IG5lZ290aWF0ZSBvbiBjbG9zZWQgZW5naW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgcnRwVHlwZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ0cE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBydHBUeXBlcy5mb3JFYWNoKHJ0cCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IHJ0cC5jb2RlYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGlzVmlkZW9Db2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgICAgcnRwTWFwLnNldChydHAucGF5bG9hZCwgY29kZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIubmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOZWdvdGlhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ25lZ290aWF0aW9uJywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1Yikge1xuICAgIGlmICghc3ViKSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5REM7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlREM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQ1N1YjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2Fybignc3luYyBzdGF0ZSBjYW5ub3QgYmUgc2VudCB3aXRob3V0IHBlZXIgY29ubmVjdGlvbiBzZXR1cCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Fuc3dlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzT2ZmZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XG4gICAgLyogMS4gYXV0b3N1YnNjcmliZSBvbiwgc28gc3Vic2NyaWJlZCB0cmFja3MgPSBhbGwgdHJhY2tzIC0gdW5zdWIgdHJhY2tzLFxuICAgICAgICAgIGluIHRoaXMgY2FzZSwgd2Ugc2VuZCB1bnN1YiB0cmFja3MsIHNvIHNlcnZlciBhZGQgYWxsIHRyYWNrcyB0byB0aGlzXG4gICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxuICAgICAgIDIuIGF1dG9zdWJzY3JpYmUgb2ZmLCB3ZSBzZW5kIHN1YnNjcmliZWQgdHJhY2tzLlxuICAgICovXG4gICAgY29uc3QgYXV0b1N1YnNjcmliZSA9IChfYiA9IChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgaWYgKHRyYWNrLmlzRGVzaXJlZCAhPT0gYXV0b1N1YnNjcmliZSkge1xuICAgICAgICB0cmFja1NpZHMucHVzaCh0cmFjay50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQuc2VuZFN5bmNTdGF0ZShuZXcgU3luY1N0YXRlKHtcbiAgICAgIGFuc3dlcjogcHJldmlvdXNBbnN3ZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c0Fuc3dlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzQW5zd2VyLnR5cGVcbiAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgb2ZmZXI6IHByZXZpb3VzT2ZmZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgc2RwOiBwcmV2aW91c09mZmVyLnNkcCxcbiAgICAgICAgdHlwZTogcHJldmlvdXNPZmZlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIHN1YnNjcmlwdGlvbjogbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIHRyYWNrU2lkcyxcbiAgICAgICAgc3Vic2NyaWJlOiAhYXV0b1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtdXG4gICAgICB9KSxcbiAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcbiAgICAgIGRhdGFDaGFubmVsczogdGhpcy5kYXRhQ2hhbm5lbHNJbmZvKClcbiAgICB9KSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGZhaWxOZXh0KCkge1xuICAgIC8vIGRlYnVnZ2luZyBtZXRob2QgdG8gZmFpbCB0aGUgbmV4dCByZWNvbm5lY3QvcmVzdW1lIGF0dGVtcHRcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gdHJ1ZTtcbiAgfVxuICBkYXRhQ2hhbm5lbHNJbmZvKCkge1xuICAgIGNvbnN0IGluZm9zID0gW107XG4gICAgY29uc3QgZ2V0SW5mbyA9IChkYywgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoKGRjID09PSBudWxsIHx8IGRjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYy5pZCkgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgIGxhYmVsOiBkYy5sYWJlbCxcbiAgICAgICAgICBpZDogZGMuaWQsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICByZXR1cm4gaW5mb3M7XG4gIH1cbiAgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgfVxuICByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbiAgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgUmVnaW9uVXJsUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSAwO1xuICAgIHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUgPSAzMDAwO1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICB1cGRhdGVUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuICBpc0Nsb3VkKCkge1xuICAgIHJldHVybiBpc0Nsb3VkKHRoaXMuc2VydmVyVXJsKTtcbiAgfVxuICBnZXRTZXJ2ZXJVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyVXJsO1xuICB9XG4gIGdldE5leHRCZXN0UmVnaW9uVXJsKGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlZ2lvblNldHRpbmdzIHx8IERhdGUubm93KCkgLSB0aGlzLmxhc3RVcGRhdGVBdCA+IHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUpIHtcbiAgICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IHlpZWxkIHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb25zTGVmdCA9IHRoaXMucmVnaW9uU2V0dGluZ3MucmVnaW9ucy5maWx0ZXIocmVnaW9uID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZChhdHRlbXB0ZWQgPT4gYXR0ZW1wdGVkLnVybCA9PT0gcmVnaW9uLnVybCkpO1xuICAgICAgaWYgKHJlZ2lvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dFJlZ2lvbiA9IHJlZ2lvbnNMZWZ0WzBdO1xuICAgICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIm5leHQgcmVnaW9uOiBcIi5jb25jYXQobmV4dFJlZ2lvbi5yZWdpb24pKTtcbiAgICAgICAgcmV0dXJuIG5leHRSZWdpb24udXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRBdHRlbXB0cygpIHtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3NSZXNwb25zZSA9IHlpZWxkIGZldGNoKFwiXCIuY29uY2F0KGdldENsb3VkQ29uZmlnVXJsKHRoaXMuc2VydmVyVXJsKSwgXCIvcmVnaW9uc1wiKSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRoaXMudG9rZW4pXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBpZiAocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IHlpZWxkIHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZWdpb25TZXR0aW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8gOiB1bmRlZmluZWQsIHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzZXJ2ZXJVcmwucHJvdG9jb2wucmVwbGFjZSgnd3MnLCAnaHR0cCcpLCBcIi8vXCIpLmNvbmNhdChzZXJ2ZXJVcmwuaG9zdCwgXCIvc2V0dGluZ3NcIik7XG59XG5cbmNvbnN0IG1vbml0b3JGcmVxdWVuY3kgPSAyMDAwO1xuZnVuY3Rpb24gY29tcHV0ZUJpdHJhdGUoY3VycmVudFN0YXRzLCBwcmV2U3RhdHMpIHtcbiAgaWYgKCFwcmV2U3RhdHMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgYnl0ZXNOb3c7XG4gIGxldCBieXRlc1ByZXY7XG4gIGlmICgnYnl0ZXNSZWNlaXZlZCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgfSBlbHNlIGlmICgnYnl0ZXNTZW50JyBpbiBjdXJyZW50U3RhdHMpIHtcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1NlbnQ7XG4gICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzU2VudDtcbiAgfVxuICBpZiAoYnl0ZXNOb3cgPT09IHVuZGVmaW5lZCB8fCBieXRlc1ByZXYgPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQgfHwgcHJldlN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIChieXRlc05vdyAtIGJ5dGVzUHJldikgKiA4ICogMTAwMCAvIChjdXJyZW50U3RhdHMudGltZXN0YW1wIC0gcHJldlN0YXRzLnRpbWVzdGFtcCk7XG59XG5cbmNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBsZXQgYXVkaW9Db250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2suS2luZC5BdWRpbywgY29uc3RyYWludHMsIHVzZXJQcm92aWRlZFRyYWNrKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCdjb3VsZCBub3QgZ2V0IGF1ZGlvIHNlbmRlciBzdGF0cycsIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pc011dGVkIHx8IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBkaXNhYmxlZCBzcGVjaWFsIGhhbmRsaW5nIGFzIGl0IHdpbGwgY2F1c2UgQlQgaGVhZHNldHMgdG8gc3dpdGNoIGNvbW11bmljYXRpb24gbW9kZXNcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiB0aGlzLnN0b3BPbk11dGUgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snKTtcbiAgICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IG1pY3JvcGhvbmUgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHVubXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPSB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09IHVud3JhcENvbnN0cmFpbnQodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQpO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVhY3F1aXJpbmcgbWljIHRyYWNrJyk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgX3N1cGVyLnJlc3RhcnQuY2FsbCh0aGlzLCBjb25zdHJhaW50cyk7XG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzb3IgXCIuY29uY2F0KHByb2Nlc3Nvci5uYW1lKSk7XG4gICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgeWllbGQgKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuICBnZXRTZW5kZXJTdGF0cygpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgYXVkaW9TdGF0cztcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgYXVkaW9TdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBieXRlc1NlbnQ6IHYuYnl0ZXNTZW50LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhdWRpb1N0YXRzO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrRm9yU2lsZW5jZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIud2Fybignc2lsZW5jZSBkZXRlY3RlZCBvbiBsb2NhbCBhdWRpbyB0cmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvU2lsZW5jZURldGVjdGVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFja0lzU2lsZW50O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMpIHtcbiAgc3dpdGNoIChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UpO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxWaWRlb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6IFwiLmNvbmNhdChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpKTtcbiAgfVxufVxuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcbi8qIEBpbnRlcm5hbCAqL1xuY29uc3QgcHJlc2V0c1NjcmVlblNoYXJlID0gT2JqZWN0LnZhbHVlcyhTY3JlZW5TaGFyZVByZXNldHMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xuLyogQGludGVybmFsICovXG5jb25zdCBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyA9IGZyb21QcmVzZXQgPT4ge1xuICBjb25zdCBsYXllcnMgPSBbe1xuICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMixcbiAgICBmcHM6IDNcbiAgfV07XG4gIHJldHVybiBsYXllcnMubWFwKHQgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFZpZGVvUHJlc2V0KE1hdGguZmxvb3IoZnJvbVByZXNldC53aWR0aCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmhlaWdodCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5tYXgoMTUwMDAwLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvIChNYXRoLnBvdyh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSwgMikgKiAoKChfYSA9IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMCkgLyB0LmZwcykpKSksIHQuZnBzLCBmcm9tUHJlc2V0LmVuY29kaW5nLnByaW9yaXR5KTtcbiAgfSk7XG59O1xuLy8gLyoqXG4vLyAgKlxuLy8gICogQGludGVybmFsXG4vLyAgKiBAZXhwZXJpbWVudGFsXG4vLyAgKi9cbi8vIGNvbnN0IGNvbXB1dGVEZWZhdWx0TXVsdGlDb2RlY1NpbXVsY2FzdEVuY29kaW5ncyA9ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xuLy8gICAvLyB1c2UgdnA4IGFzIGEgZGVmYXVsdFxuLy8gICBjb25zdCB2cDggPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGZhbHNlLCB3aWR0aCwgaGVpZ2h0KTtcbi8vICAgY29uc3QgdnA5ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC45IH07XG4vLyAgIGNvbnN0IGgyNjQgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAxLjEgfTtcbi8vICAgY29uc3QgYXYxID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC43IH07XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdnA4LFxuLy8gICAgIHZwOSxcbi8vICAgICBoMjY0LFxuLy8gICAgIGF2MSxcbi8vICAgfTtcbi8vIH07XG5jb25zdCB2aWRlb1JpZHMgPSBbJ3EnLCAnaCcsICdmJ107XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGNvbXB1dGVWaWRlb0VuY29kaW5ncyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvRW5jb2Rpbmc7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZUVuY29kaW5nO1xuICB9XG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaW11bGNhc3Q7XG4gIGNvbnN0IHNjYWxhYmlsaXR5TW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsYWJpbGl0eU1vZGU7XG4gIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9Db2RlYztcbiAgaWYgKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgIC8vIHdoZW4gd2UgYXJlbid0IHNpbXVsY2FzdGluZyBvciBzdmMsIHdpbGwgbmVlZCB0byByZXR1cm4gYSBzaW5nbGUgZW5jb2Rpbmcgd2l0aG91dFxuICAgIC8vIGNhcHBpbmcgYmFuZHdpZHRoLiB3ZSBhbHdheXMgcmVxdWlyZSBhIGVuY29kaW5nIGZvciBkeW5hY2FzdFxuICAgIHJldHVybiBbe31dO1xuICB9XG4gIGlmICghdmlkZW9FbmNvZGluZykge1xuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VzaW5nIHZpZGVvIGVuY29kaW5nJywgdmlkZW9FbmNvZGluZyk7XG4gIH1cbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQod2lkdGgsIGhlaWdodCwgdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLCB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSwgdmlkZW9FbmNvZGluZy5wcmlvcml0eSk7XG4gIGlmIChzY2FsYWJpbGl0eU1vZGUgJiYgaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ1c2luZyBzdmMgd2l0aCBzY2FsYWJpbGl0eU1vZGUgXCIuY29uY2F0KHNjYWxhYmlsaXR5TW9kZSkpO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICAgIGlmIChzbS5zcGF0aWFsID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NhbGFiaWxpdHlNb2RlOiBcIi5jb25jYXQoc2NhbGFiaWxpdHlNb2RlKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBlbmNvZGluZ3MucHVzaCh7XG4gICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gTWF0aC5wb3coMywgaSksXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSA9IHNjYWxhYmlsaXR5TW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdlbmNvZGluZ3MnLCBlbmNvZGluZ3MpO1xuICAgIHJldHVybiBlbmNvZGluZ3M7XG4gIH1cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG4gIGxldCBwcmVzZXRzID0gW107XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcHJlc2V0cyA9IChfYSA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xuICB9IGVsc2Uge1xuICAgIHByZXNldHMgPSAoX2IgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9TaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0O1xuICBpZiAocHJlc2V0cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbG93UHJlc2V0ID0gcHJlc2V0c1swXTtcbiAgICBpZiAocHJlc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICBbLCBtaWRQcmVzZXRdID0gcHJlc2V0cztcbiAgICB9XG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gaW9uLXNmdSB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgLy8gYmFja3VwQ29kZWMgc2hvdWxkIG5vdCBiZSB0cnVlIGFueW1vcmUsIGRlZmF1bHQgY29kZWMgaXMgc2V0IGluIExvY2FsUGFydGljaXBhbnQucHVibGlzaFxuICBpZiAoIW9wdHMuYmFja3VwQ29kZWMgfHwgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fCBvcHRzLmJhY2t1cENvZGVjLmNvZGVjID09PSBvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xuICAgIGxpdmVraXRMb2dnZXIud2FybigncmVxdWVzdGVkIGEgZGlmZmVyZW50IGNvZGVjIHRoYW4gc3BlY2lmaWVkIGFzIGJhY2t1cCcsIHtcbiAgICAgIHNlcnZlclJlcXVlc3RlZDogdmlkZW9Db2RlYyxcbiAgICAgIGJhY2t1cDogb3B0cy5iYWNrdXBDb2RlYy5jb2RlY1xuICAgIH0pO1xuICB9XG4gIG9wdHMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gIC8vIHVzZSBiYWNrdXAgZW5jb2Rpbmcgc2V0dGluZyBhcyB2aWRlb0VuY29kaW5nIGZvciBiYWNrdXAgY29kZWMgcHVibGlzaGluZ1xuICBvcHRzLnZpZGVvRW5jb2RpbmcgPSBvcHRzLmJhY2t1cENvZGVjLmVuY29kaW5nO1xuICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgY29uc3Qgd2lkdGggPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdHJhY2suZGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSAoX2MgPSBzZXR0aW5ncy5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQ7XG4gIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0cyk7XG4gIHJldHVybiBlbmNvZGluZ3M7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgY29kZWMpIHtcbiAgY29uc3QgcHJlc2V0cyA9IHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpO1xuICBsZXQge1xuICAgIGVuY29kaW5nXG4gIH0gPSBwcmVzZXRzWzBdO1xuICAvLyBoYW5kbGUgcG9ydHJhaXQgYnkgc3dhcHBpbmcgZGltZW5zaW9uc1xuICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcbiAgLy8gZm9yIG90aGVyIGNvZGVjcyB3ZSBhZGp1c3QgdGhlIG1heEJpdHJhdGUgaWYgbm8gc3BlY2lmaWMgdmlkZW9FbmNvZGluZyBoYXMgYmVlbiBwcm92aWRlZFxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcbiAgLy8gYml0cmF0ZSBmb3Igbm9uLVNWQyBjb2RlY3MgZG9lcyBub3QgaW5jbHVkZSBvdGhlciBzaW11bGNhc3QgbGF5ZXJzLlxuICBpZiAoY29kZWMpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdjEnOlxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndnA5JzpcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBlbmNvZGluZy5tYXhCaXRyYXRlICogMC44NTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBwcmVzZXRzU2NyZWVuU2hhcmU7XG4gIH1cbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gcHJlc2V0czQzO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzKG9yaWdpbmFsKTtcbiAgfVxuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBvcmlnaW5hbDtcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDM7XG59XG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXG5mdW5jdGlvbiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBwcmVzZXRzKSB7XG4gIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xuICBwcmVzZXRzLmZvckVhY2goKHByZXNldCwgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA+PSB2aWRlb1JpZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCByaWQgPSB2aWRlb1JpZHNbaWR4XTtcbiAgICBjb25zdCBlbmNvZGluZyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGVcbiAgICB9O1xuICAgIGlmIChwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSB7XG4gICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgIH1cbiAgICBjb25zdCBjYW5TZXRQcmlvcml0eSA9IGlzRmlyZUZveCgpIHx8IGlkeCA9PT0gMDtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLnByaW9yaXR5ICYmIGNhblNldFByaW9yaXR5KSB7XG4gICAgICBlbmNvZGluZy5wcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICAgIGVuY29kaW5nLm5ldHdvcmtQcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICB9XG4gICAgZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuICB9KTtcbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlID0gdW5kZWZpbmVkO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIGlmICghdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIHRvcEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICYmIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA+IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChlbmNvZGluZy5tYXhGcmFtZXJhdGUgIT0gdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIGlmIChub3RpZnlPbmNlKSB7XG4gICAgICAgICAgbm90aWZ5T25jZSA9IGZhbHNlO1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIlNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiXCIuY29uY2F0KChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIFwiXFxcIiB0byBcIikuY29uY2F0KHRvcEZyYW1lcmF0ZSkpO1xuICAgICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSB0b3BGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHMpIHtcbiAgaWYgKCFwcmVzZXRzKSByZXR1cm47XG4gIHJldHVybiBwcmVzZXRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYUVuY1xuICAgIH0gPSBhO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nOiBiRW5jXG4gICAgfSA9IGI7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA+IGJFbmMubWF4Qml0cmF0ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPCBiRW5jLm1heEJpdHJhdGUpIHJldHVybiAtMTtcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID09PSBiRW5jLm1heEJpdHJhdGUgJiYgYUVuYy5tYXhGcmFtZXJhdGUgJiYgYkVuYy5tYXhGcmFtZXJhdGUpIHtcbiAgICAgIHJldHVybiBhRW5jLm1heEZyYW1lcmF0ZSA+IGJFbmMubWF4RnJhbWVyYXRlID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5jbGFzcyBTY2FsYWJpbGl0eU1vZGUge1xuICBjb25zdHJ1Y3RvcihzY2FsYWJpbGl0eU1vZGUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG4gICAgdGhpcy5zcGF0aWFsID0gcGFyc2VJbnQocmVzdWx0c1sxXSk7XG4gICAgdGhpcy50ZW1wb3JhbCA9IHBhcnNlSW50KHJlc3VsdHNbMl0pO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIHN3aXRjaCAocmVzdWx0c1szXSkge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgY2FzZSAnX0tFWSc6XG4gICAgICAgIGNhc2UgJ19LRVlfU0hJRlQnOlxuICAgICAgICAgIHRoaXMuc3VmZml4ID0gcmVzdWx0c1szXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBcIkxcIi5jb25jYXQodGhpcy5zcGF0aWFsLCBcIlRcIikuY29uY2F0KHRoaXMudGVtcG9yYWwpLmNvbmNhdCgoX2EgPSB0aGlzLnN1ZmZpeCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICB9XG59XG5cbmNvbnN0IHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjID0gNTAwMDtcbmNsYXNzIExvY2FsVmlkZW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2spO1xuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzTWFwID0gbmV3IE1hcChzdGF0cy5tYXAocyA9PiBbcy5yaWQsIHNdKSk7XG4gICAgICBpZiAodGhpcy5wcmV2U3RhdHMpIHtcbiAgICAgICAgbGV0IHRvdGFsQml0cmF0ZSA9IDA7XG4gICAgICAgIHN0YXRzTWFwLmZvckVhY2goKHMsIGtleSkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gKF9hID0gdGhpcy5wcmV2U3RhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbiAgICAgICAgICB0b3RhbEJpdHJhdGUgKz0gY29tcHV0ZUJpdHJhdGUocywgcHJldik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHNNYXA7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kZXJMb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cbiAgZ2V0IGlzU2ltdWxjYXN0KCkge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhcmFtZXRlcnMoKTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2godHJhY2tJbmZvID0+IHtcbiAgICAgIHRyYWNrSW5mby5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHBhdXNlVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5wYXVzZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5wYXVzZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3VtZVVwc3RyZWFtOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucmVzdW1lVXBzdHJlYW1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgIHZhciBfZDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLnJlc3VtZVVwc3RyZWFtLmNhbGwodGhpcyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2cudmFsdWU7XG4gICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgICAgZV8yID0ge1xuICAgICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgbXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdzdG9wcGluZyBjYW1lcmEgdHJhY2snKTtcbiAgICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IGNhbWVyYSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxuICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdW5tdXRlKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgdW5tdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIudW5tdXRlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVhY3F1aXJpbmcgY2FtZXJhIHRyYWNrJyk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICAgIGNvbnN0IHZzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIGZyYW1lc1NlbnQ6IHYuZnJhbWVzU2VudCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICByaWQ6IChfYSA9IHYucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2LmlkLFxuICAgICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogdi5xdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL8KgbG9jYXRlIHRoZSBhcHByb3ByaWF0ZSByZW1vdGUtaW5ib3VuZC1ydHAgaXRlbVxuICAgICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHZzLmppdHRlciA9IHIuaml0dGVyO1xuICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXMucHVzaCh2cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0pO1xuICB9XG4gIHNldFB1Ymxpc2hpbmdRdWFsaXR5KG1heFF1YWxpdHkpIHtcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBxID0gVmlkZW9RdWFsaXR5LkxPVzsgcSA8PSBWaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XG4gICAgICBxdWFsaXRpZXMucHVzaChuZXcgU3Vic2NyaWJlZFF1YWxpdHkoe1xuICAgICAgICBxdWFsaXR5OiBxLFxuICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHlcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSBcIi5jb25jYXQobWF4UXVhbGl0eSkpO1xuICAgIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhxdWFsaXRpZXMpO1xuICB9XG4gIHNldERldmljZUlkKGRldmljZUlkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAvLyB3aGVuIHZpZGVvIGlzIG11dGVkLCB1bmRlcmx5aW5nIG1lZGlhIHN0cmVhbSB0cmFjayBpcyBzdG9wcGVkIGFuZFxuICAgICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pc011dGVkIHx8IHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgY29uc3RyYWludHM7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XG4gICAgICAgICAgdmlkZW86IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMudmlkZW8gIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9mOyBfZiA9IHlpZWxkIF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xuICAgICAgICAgIGlmIChzYy5zZW5kZXIpIHtcbiAgICAgICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHlpZWxkIHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICBlXzMgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICBsZXQgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBzZXRQcm9jZXNzb3I6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5zZXRQcm9jZXNzb3JcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgIHZhciBfZCwgX2U7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5zZXRQcm9jZXNzb3IuY2FsbCh0aGlzLCBwcm9jZXNzb3IsIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KTtcbiAgICAgIGlmICgoX2QgPSB0aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfaDsgX2ggPSB5aWVsZCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICAgIHlpZWxkIChfZSA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgICAgIGVfNCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IF9nLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2cpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWMsIGVuY29kaW5ncykge1xuICAgIGlmICh0aGlzLnNpbXVsY2FzdENvZGVjcy5oYXMoY29kZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoY29kZWMsIFwiIGFscmVhZHkgYWRkZWRcIikpO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB7XG4gICAgICBjb2RlYyxcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxuICAgICAgc2VuZGVyOiB1bmRlZmluZWQsXG4gICAgICBlbmNvZGluZ3NcbiAgICB9O1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnNldChjb2RlYywgc2ltdWxjYXN0Q29kZWNJbmZvKTtcbiAgICByZXR1cm4gc2ltdWxjYXN0Q29kZWNJbmZvO1xuICB9XG4gIHNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKGNvZGVjLCBzZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG4gICAgLy8gYnJvd3NlciB3aWxsIHJlZW5hYmxlIGRpc2FibGVkIGNvZGVjL2xheWVycyBhZnRlciBuZXcgY29kZWMgaGFzIGJlZW4gcHVibGlzaGVkLFxuICAgIC8vIHNvIHJlZnJlc2ggc3Vic2NyaWJlZENvZGVjcyBhZnRlciBwdWJsaXNoIGEgbmV3IGNvZGVjXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVkQ29kZWNzKSB7XG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGluZ0NvZGVjcyh0aGlzLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgfVxuICAgIH0sIHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxuICAgKiBiZWVuIHB1Ymxpc2hlZFxuICAgKi9cbiAgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3MpIHtcbiAgICB2YXIgX2EsIGNvZGVjc18xLCBjb2RlY3NfMV8xO1xuICAgIHZhciBfYiwgZV81LCBfYywgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBjb2RlY3MnLCB7XG4gICAgICAgIGNvZGVjcyxcbiAgICAgICAgY3VycmVudENvZGVjOiB0aGlzLmNvZGVjXG4gICAgICB9KTtcbiAgICAgIC8vIG9ubHkgZW5hYmxlIHNpbXVsY2FzdCBjb2RlYyBmb3IgcHJlZmVyZW5jZSBjb2RlYyBzZXR0ZWRcbiAgICAgIGlmICghdGhpcy5jb2RlYyAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWNzWzBdLnF1YWxpdGllcyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfYSA9IHRydWUsIGNvZGVjc18xID0gX19hc3luY1ZhbHVlcyhjb2RlY3MpOyBjb2RlY3NfMV8xID0geWllbGQgY29kZWNzXzEubmV4dCgpLCBfYiA9IGNvZGVjc18xXzEuZG9uZSwgIV9iOyBfYSA9IHRydWUpIHtcbiAgICAgICAgICBfZCA9IGNvZGVjc18xXzEudmFsdWU7XG4gICAgICAgICAgX2EgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IF9kO1xuICAgICAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGNvZGVjLnF1YWxpdGllcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYy5jb2RlYyk7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgc2ltdWxjYXN0Q29kZWNJbmZvKTtcbiAgICAgICAgICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvIHx8ICFzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcSBvZiBjb2RlYy5xdWFsaXRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICBuZXdDb2RlY3MucHVzaChjb2RlYy5jb2RlYyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSk7XG4gICAgICAgICAgICAgIHlpZWxkIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciwgc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncywgY29kZWMucXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV81XzEpIHtcbiAgICAgICAgZV81ID0ge1xuICAgICAgICAgIGVycm9yOiBlXzVfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9hICYmICFfYiAmJiAoX2MgPSBjb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYy5jYWxsKGNvZGVjc18xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdDb2RlY3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBTZXRzIGxheWVycyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nXG4gICAqL1xuICBzZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgcXVhbGl0aWVzKTtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIgfHwgIXRoaXMuZW5jb2RpbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIodGhpcy5zZW5kZXIsIHRoaXMuZW5jb2RpbmdzLCBxdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jayk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzZW5kZXIsIHNlbmRlckVuY29kaW5ncywgcXVhbGl0aWVzLCBzZW5kZXJMb2NrKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgdW5sb2NrID0geWllbGQgc2VuZGVyTG9jay5sb2NrKCk7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIHtcbiAgICAgIHNlbmRlcixcbiAgICAgIHF1YWxpdGllcyxcbiAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmNvZGluZ3NcbiAgICAgIH0gPSBwYXJhbXM7XG4gICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZW5jb2RpbmdzLmxlbmd0aCAhPT0gc2VuZGVyRW5jb2RpbmdzLmxlbmd0aCkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgLyogZGlzYWJsZSBjbG9zYWJsZSBzcGF0aWFsIGxheWVyIGFzIGl0IGhhcyB2aWRlbyBibHVyIC8gZnJvemVuIGlzc3VlIHdpdGggY3VycmVudCBzZXJ2ZXIgLyBjbGllbnRcbiAgICAgIDEuIGNocm9tZSAxMTM6IHdoZW4gc3dpdGNoaW5nIHRvIHVwIGxheWVyIHdpdGggc2NhbGFiaWxpdHkgTW9kZSBjaGFuZ2UsIGl0IHdpbGwgZ2VuZXJhdGUgYVxuICAgICAgICAgICAgbG93IHJlc29sdXRpb24gZnJhbWUgYW5kIHJlY292ZXIgdmVyeSBxdWlja2x5LCBidXQgbm90aWNhYmxlXG4gICAgICAyLiBsaXZla2l0IHNmdTogYWRkaXRpb25hbCBwbGkgcmVxdWVzdCBjYXVzZSB2aWRlbyBmcm96ZW4gZm9yIGEgZmV3IGZyYW1lcywgYWxzbyBub3RpY2FibGUgKi9cbiAgICAgIGNvbnN0IGNsb3NhYmxlU3BhdGlhbCA9IGZhbHNlO1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgaWYgKGNsb3NhYmxlU3BhdGlhbCAmJiBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKSA7IGVsc2Uge1xuICAgICAgICAvLyBzaW11bGNhc3QgZHluYWNhc3QgZW5jb2RpbmdzXG4gICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGxldCByaWQgPSAoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgIGlmIChyaWQgPT09ICcnKSB7XG4gICAgICAgICAgICByaWQgPSAncSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKTtcbiAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVhbGl0eSA9IHF1YWxpdGllcy5maW5kKHEgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcbiAgICAgICAgICBpZiAoIXN1YnNjcmliZWRRdWFsaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgIT09IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJzZXR0aW5nIGxheWVyIFwiLmNvbmNhdChzdWJzY3JpYmVkUXVhbGl0eS5xdWFsaXR5LCBcIiB0byBcIikuY29uY2F0KGVuY29kaW5nLmFjdGl2ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcpKTtcbiAgICAgICAgICAgIC8vIEZpcmVGb3ggZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIGVuY29kaW5nLmFjdGl2ZSB0byBmYWxzZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGhhdmUgYSB3b3JrYXJvdW5kIG9mIGxvd2VyaW5nIGl0cyBiaXRyYXRlIGFuZCByZXNvbHV0aW9uIHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAoaXNGaXJlRm94KCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5zY2FsZVJlc29sdXRpb25Eb3duQnk7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEJpdHJhdGU7XG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEZyYW1lUmF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSA0O1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSAxMDtcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0dGluZyBlbmNvZGluZ3NcIiwgcGFyYW1zLmVuY29kaW5ncyk7XG4gICAgICAgIHlpZWxkIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKSB7XG4gIHN3aXRjaCAocmlkKSB7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcbiAgICBjYXNlICdxJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkhJR0g7XG4gIH1cbn1cbmZ1bmN0aW9uIHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyh3aWR0aCwgaGVpZ2h0LCBlbmNvZGluZ3MsIHN2Yykge1xuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxuICBpZiAoIWVuY29kaW5ncykge1xuICAgIHJldHVybiBbbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0gsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJpdHJhdGU6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSldO1xuICB9XG4gIGlmIChzdmMpIHtcbiAgICAvLyBzdmMgbGF5ZXJzXG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlO1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZ1NNKTtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtLnNwYXRpYWw7IGkgKz0gMSkge1xuICAgICAgbGF5ZXJzLnB1c2gobmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICBxdWFsaXR5OiBWaWRlb1F1YWxpdHkuSElHSCAtIGksXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBNYXRoLnBvdygyLCBpKSksXG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIE1hdGgucG93KDIsIGkpKSxcbiAgICAgICAgYml0cmF0ZTogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgPyBNYXRoLmNlaWwoZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyBNYXRoLnBvdygzLCBpKSkgOiAwLFxuICAgICAgICBzc3JjOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBsYXllcnM7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoZW5jb2RpbmcgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHNjYWxlID0gKF9hID0gZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xuICAgIGxldCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKChfYiA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IChfYyA9IGVuY29kaW5nLm1heEJpdHJhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDAsXG4gICAgICBzc3JjOiAwXG4gICAgfSk7XG4gIH0pO1xufVxuXG5jbGFzcyBSZW1vdGVUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCBraW5kLCByZWNlaXZlcikge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQpO1xuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TWVkaWFTdHJlYW0oc3RyZWFtKSB7XG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuc3RhcnRNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXG4gICAgc3VwZXIuZGlzYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghKChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubW9uaXRvclJlY2VpdmVyKCksIG1vbml0b3JGcmVxdWVuY3kpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZW1vdGVBdWRpb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhdWRpb0NvbnRleHQsIGF1ZGlvT3V0cHV0KSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlcik7XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBbXTtcbiAgICBpZiAoYXVkaW9PdXRwdXQpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvZiBhdHRhY2hlZCBhdWRpbyBlbGVtZW50cyAobG91ZGVzdClcbiAgICovXG4gIGdldFZvbHVtZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50Vm9sdW1lO1xuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBSTiB2b2x1bWUgdmFsdWUgZGVmYXVsdHMgdG8gMS4wIGlmIGhhc24ndCBiZWVuIGNoYW5nZWQuXG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cbiAgICBsZXQgaGlnaGVzdFZvbHVtZSA9IDA7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuICAvKipcbiAgICogY2FsbHMgc2V0U2lua0lkIG9uIGFsbCBhdHRhY2hlZCBlbGVtZW50cywgaWYgc3VwcG9ydGVkXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBhdWRpbyBvdXRwdXQgZGV2aWNlXG4gICAqL1xuICBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoZWxtID0+IHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZChlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIGVsbS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgY29uc3QgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24gPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpbmtJZCAmJiBzdXBwb3J0c1NldFNpbmtJZChlbGVtZW50KSkge1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgZWxlbWVudC5zZXRTaW5rSWQodGhpcy5zaW5rSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24pIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VzaW5nIGF1ZGlvIGNvbnRleHQgbWFwcGluZycpO1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC52b2x1bWUgPSAwO1xuICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIGlmIChhdWRpb0NvbnRleHQgJiYgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKGF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzKSB7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gbm9kZXM7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwICYmIHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdFdlYkF1ZGlvKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIC8vIEB0cy1pZ25vcmUgYXR0YWNoZWQgZWxlbWVudHMgYWx3YXlzIGhhdmUgYSBzcmNPYmplY3Qgc2V0XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShlbGVtZW50LnNyY09iamVjdCk7XG4gICAgbGV0IGxhc3ROb2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGFzdE5vZGUuY29ubmVjdChub2RlKTtcbiAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgbGFzdE5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgdGhpcy5nYWluTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSh0aGlzLmVsZW1lbnRWb2x1bWUsIDAsIDAuMSk7XG4gICAgfVxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dC5yZXN1bWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIG5ldyBFcnJvcihcIkF1ZGlvIENvbnRleHQgY291bGRuJ3QgYmUgc3RhcnRlZCBhdXRvbWF0aWNhbGx5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RXZWJBdWRpbygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgKF9iID0gdGhpcy5zb3VyY2VOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBjb25jZWFsZWRTYW1wbGVzOiB2LmNvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgICBjb25jZWFsbWVudEV2ZW50czogdi5jb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxlZFNhbXBsZXM6IHYuc2lsZW50Q29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxtZW50RXZlbnRzOiB2LnNpbGVudENvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgICAgdG90YWxBdWRpb0VuZXJneTogdi50b3RhbEF1ZGlvRW5lcmd5LFxuICAgICAgICAgICAgdG90YWxTYW1wbGVzRHVyYXRpb246IHYudG90YWxTYW1wbGVzRHVyYXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xuY2xhc3MgUmVtb3RlVmlkZW9UcmFjayBleHRlbmRzIFJlbW90ZVRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5WaWRlbywgcmVjZWl2ZXIpO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gW107XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSA9IHIoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gIH1cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIGFkYXB0aXZlU3RyZWFtLCB5b3UgbmVlZCB0byB1c2UgcmVtb3RlVmlkZW9UcmFjay5hdHRhY2goKSB0byBhZGQgdGhlIHRyYWNrIHRvIGEgSFRNTFZpZGVvRWxlbWVudCwgb3RoZXJ3aXNlIHlvdXIgdmlkZW8gdHJhY2tzIG1pZ2h0IG5ldmVyIHN0YXJ0XG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE11dGVkKG11dGVkKSB7XG4gICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gSXQncyBwb3NzaWJsZSBhdHRhY2ggaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGFuIGVsZW1lbnQuIFdoZW4gdGhhdCdzXG4gICAgLy8gdGhlIGNhc2UsIHdlJ2Qgd2FudCB0byBhdm9pZCBhZGRpbmcgZHVwbGljYXRlIGVsZW1lbnRJbmZvc1xuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XG4gICAgICBlbGVtZW50SW5mby5vYnNlcnZlKCk7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybigndmlzaWJpbGl0eSByZXNpemUgb2JzZXJ2ZXIgbm90IHRyaWdnZXJlZCcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RvcCBvYnNlcnZpbmcgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbyk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIGluZm8uc3RvcE9ic2VydmluZygpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gIT09IGVsZW1lbnRJbmZvKTtcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICB9XG4gIGRldGFjaChlbGVtZW50KSB7XG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGRldGFjaGVkRWxlbWVudHMgPSBzdXBlci5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXREZWNvZGVySW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29kZXJJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBnZXRSZWNlaXZlclN0YXRzKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgcmVjZWl2ZXJTdGF0cztcbiAgICAgIGxldCBjb2RlY0lEID0gJyc7XG4gICAgICBsZXQgY29kZWNzID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBmcmFtZXNEZWNvZGVkOiB2LmZyYW1lc0RlY29kZWQsXG4gICAgICAgICAgICBmcmFtZXNEcm9wcGVkOiB2LmZyYW1lc0Ryb3BwZWQsXG4gICAgICAgICAgICBmcmFtZXNSZWNlaXZlZDogdi5mcmFtZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogdi5wYWNrZXRzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgICAgcGxpQ291bnQ6IHYucGxpQ291bnQsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGRlY29kZXJJbXBsZW1lbnRhdGlvbjogdi5kZWNvZGVySW1wbGVtZW50YXRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gJ2NvZGVjJykge1xuICAgICAgICAgIGNvZGVjcy5zZXQodi5pZCwgdik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY2VpdmVyU3RhdHMgJiYgY29kZWNJRCAhPT0gJycgJiYgY29kZWNzLmdldChjb2RlY0lEKSkge1xuICAgICAgICByZWNlaXZlclN0YXRzLm1pbWVUeXBlID0gY29kZWNzLmdldChjb2RlY0lEKS5taW1lVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICAgIH0pO1xuICB9XG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzdG9wRWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mby5lbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oaW5mbyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoKHByZXYsIGluZm8pID0+IE1hdGgubWF4KHByZXYsIGluZm8udmlzaWJpbGl0eUNoYW5nZWRBdCB8fCAwKSwgMCk7XG4gICAgY29uc3QgYmFja2dyb3VuZFBhdXNlID0gKChfYiA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlVmlkZW9JbkJhY2tncm91bmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlXG4gICAgKSA/IHRoaXMuaXNJbkJhY2tncm91bmQgOiBmYWxzZTtcbiAgICBjb25zdCBpc1BpUE1vZGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby5waWN0dXJlSW5QaWN0dXJlKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby52aXNpYmxlKSAmJiAhYmFja2dyb3VuZFBhdXNlIHx8IGlzUGlQTW9kZTtcbiAgICBpZiAodGhpcy5sYXN0VmlzaWJsZSA9PT0gaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNWaXNpYmxlICYmIERhdGUubm93KCkgLSBsYXN0VmlzaWJpbGl0eUNoYW5nZSA8IFJFQUNUSU9OX0RFTEFZKSB7XG4gICAgICAvLyBkZWxheSBoaWRkZW4gZXZlbnRzXG4gICAgICBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdFZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIGlzVmlzaWJsZSwgdGhpcyk7XG4gIH1cbiAgdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2YgdGhpcy5lbGVtZW50SW5mb3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XG4gICAgICBpZiAoY3VycmVudEVsZW1lbnRXaWR0aCArIGN1cnJlbnRFbGVtZW50SGVpZ2h0ID4gbWF4V2lkdGggKyBtYXhIZWlnaHQpIHtcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgoX2EgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBtYXhXaWR0aCAmJiAoKF9iID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IG1heEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3REaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICB9O1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMubGFzdERpbWVuc2lvbnMsIHRoaXMpO1xuICB9XG4gIGdldFBpeGVsRGVuc2l0eSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGl4ZWxEZW5zaXR5O1xuICAgIGlmIChwaXhlbERlbnNpdHkgPT09ICdzY3JlZW4nKSB7XG4gICAgICByZXR1cm4gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIH0gZWxzZSBpZiAoIXBpeGVsRGVuc2l0eSkge1xuICAgICAgLy8gd2hlbiB1bnNldCwgd2UnbGwgcGljayBhIHNhbmUgZGVmYXVsdCBoZXJlLlxuICAgICAgLy8gZm9yIGhpZ2hlciBwaXhlbCBkZW5zaXR5IGRldmljZXMgKG1vYmlsZSBwaG9uZXMsIGV0YyksIHdlJ2xsIHVzZSAyXG4gICAgICAvLyBvdGhlcndpc2UgaXQgZGVmYXVsdHMgdG8gMVxuICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvID4gMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxEZW5zaXR5O1xuICB9XG59XG5jbGFzcyBIVE1MRWxlbWVudEluZm8ge1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUCB8fCB0aGlzLmlzSW50ZXJzZWN0aW5nO1xuICB9XG4gIGdldCBwaWN0dXJlSW5QaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGlQO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpc2libGUpIHtcbiAgICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQgPSBlbnRyeSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgaXNJbnRlcnNlY3RpbmdcbiAgICAgIH0gPSBlbnRyeTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbkVudGVyUGlQID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5pc1BpUCA9IHRydWU7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25MZWF2ZVBpUCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuaXNQaVAgPSBmYWxzZTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gdmlzaWJsZSAhPT0gbnVsbCAmJiB2aXNpYmxlICE9PSB2b2lkIDAgPyB2aXNpYmxlIDogaXNFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50KTtcbiAgICB0aGlzLmlzUGlQID0gaXNXZWIoKSAmJiBkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSAwO1xuICB9XG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cbiAgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG4gIG9ic2VydmUoKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgY3VycmVudCB2aXNpYmxlIHN0YXRlIG9uY2Ugd2Ugc3RhcnQgdG8gb2JzZXJ2ZVxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0VsZW1lbnRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50LmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlUmVzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcbiAgICBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBnZXRSZXNpemVPYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIChfYiA9IGdldFJlc2l6ZU9ic2VydmVyKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxufVxuLy8gZG9lcyBub3QgYWNjb3VudCBmb3Igb2NjbHVzaW9uIGJ5IG90aGVyIGVsZW1lbnRzXG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsKSB7XG4gIGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICBjb25zdCB7XG4gICAgaGlkZGVuXG4gIH0gPSBlbDtcbiAgY29uc3Qge1xuICAgIG9wYWNpdHksXG4gICAgZGlzcGxheVxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHdoaWxlIChlbC5vZmZzZXRQYXJlbnQpIHtcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgIGxlZnQgKz0gZWwub2Zmc2V0TGVmdDtcbiAgfVxuICByZXR1cm4gdG9wIDwgd2luZG93LnBhZ2VZT2Zmc2V0ICsgd2luZG93LmlubmVySGVpZ2h0ICYmIGxlZnQgPCB3aW5kb3cucGFnZVhPZmZzZXQgKyB3aW5kb3cuaW5uZXJXaWR0aCAmJiB0b3AgKyBoZWlnaHQgPiB3aW5kb3cucGFnZVlPZmZzZXQgJiYgbGVmdCArIHdpZHRoID4gd2luZG93LnBhZ2VYT2Zmc2V0ICYmICFoaWRkZW4gJiYgKG9wYWNpdHkgIT09ICcnID8gcGFyc2VGbG9hdChvcGFjaXR5KSA+IDAgOiB0cnVlKSAmJiBkaXNwbGF5ICE9PSAnbm9uZSc7XG59XG5cbmNsYXNzIFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGtpbmQsIGlkLCBuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICB0aGlzLmhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuTXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5tdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgfVxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIC8vIGZvcndhcmQgZXZlbnRzXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzTXV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgLyoqXG4gICAqIGFuIFtBdWRpb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGFuIGF1ZGlvIHRyYWNrXG4gICAqL1xuICBnZXQgYXVkaW9UcmFjaygpIHtcbiAgICBpZiAodGhpcy50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBhbiBbVmlkZW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhIHZpZGVvIHRyYWNrXG4gICAqL1xuICBnZXQgdmlkZW9UcmFjaygpIHtcbiAgICBpZiAodGhpcy50cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjayB8fCB0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlVmlkZW9UcmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgdGhpcy50cmFja1NpZCA9IGluZm8uc2lkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gaW5mby5uYW1lO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suc291cmNlRnJvbVByb3RvKGluZm8uc291cmNlKTtcbiAgICB0aGlzLm1pbWVUeXBlID0gaW5mby5taW1lVHlwZTtcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIGluZm8ud2lkdGggPiAwKSB7XG4gICAgICB0aGlzLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGluZm8uaGVpZ2h0XG4gICAgICB9O1xuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBpbmZvLmVuY3J5cHRpb247XG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VwZGF0ZSBwdWJsaWNhdGlvbiBpbmZvJywge1xuICAgICAgaW5mb1xuICAgIH0pO1xuICB9XG59XG4oZnVuY3Rpb24gKFRyYWNrUHVibGljYXRpb24pIHtcbiAgKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25TdGF0dXMpIHtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJEZXNpcmVkXCJdID0gXCJkZXNpcmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG4gIChmdW5jdGlvbiAoUGVybWlzc2lvblN0YXR1cykge1xuICAgIFBlcm1pc3Npb25TdGF0dXNbXCJBbGxvd2VkXCJdID0gXCJhbGxvd2VkXCI7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdF9hbGxvd2VkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyB8fCAoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzID0ge30pKTtcbn0pKFRyYWNrUHVibGljYXRpb24gfHwgKFRyYWNrUHVibGljYXRpb24gPSB7fSkpO1xuXG5jbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZDtcbiAgfVxuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgdHJhY2spIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUpO1xuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgICB0aGlzLnNldFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNNdXRlZCgpIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLmF1ZGlvVHJhY2s7XG4gIH1cbiAgZ2V0IHZpZGVvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIE11dGUgdGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBtdXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tdXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxuICAgKi9cbiAgdW5tdXRlKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm11dGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF1c2VzIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gZnJvbSBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHNpZ25hbHMgXCJtdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGF1c2UgdGhlIHN0cmVhbSB3aXRob3V0IHBhdXNpbmcgdGhlIGxvY2FsIG1lZGlhIHN0cmVhbSB0cmFja1xuICAgKi9cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cbiAgICogYW5kIHNpZ25hbHMgXCJ1bm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzICh1bmxlc3MgdGhlIHRyYWNrIGlzIGV4cGxpY2l0bHkgbXV0ZWQpXG4gICAqL1xuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVVcHN0cmVhbSgpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkdvb2RcIl0gPSBcImdvb2RcIjtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJQb29yXCJdID0gXCJwb29yXCI7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHBhcnRpY2lwYW50IGhhcyB0ZW1wb3JhcmlseSAob3IgcGVybWFuZW50bHkpIGxvc3QgY29ubmVjdGlvbiB0byBMaXZlS2l0LlxuICAgKiBGb3IgcGVybWFuZW50IGRpc2Nvbm5lY3Rpb24gYSBgUGFydGljaXBhbnREaXNjb25uZWN0ZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBhZnRlciBhIHRpbWVvdXRcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiTG9zdFwiXSA9IFwibG9zdFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbn0pKENvbm5lY3Rpb25RdWFsaXR5IHx8IChDb25uZWN0aW9uUXVhbGl0eSA9IHt9KSk7XG5mdW5jdGlvbiBxdWFsaXR5RnJvbVByb3RvKHEpIHtcbiAgc3dpdGNoIChxKSB7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkVYQ0VMTEVOVDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5FeGNlbGxlbnQ7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkdPT0Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuR29vZDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuUE9PUjpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5MT1NUOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkxvc3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICB9XG59XG5jbGFzcyBQYXJ0aWNpcGFudCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcy5zaXplID4gMCAmJiBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5ldmVyeSh0ciA9PiB0ci5pc0VuY3J5cHRlZCk7XG4gIH1cbiAgZ2V0IGlzQWdlbnQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFnZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogYXVkaW8gbGV2ZWwgYmV0d2VlbiAwLTEuMCwgMSBiZWluZyBsb3VkZXN0LCAwIGJlaW5nIHNvZnRlc3QgKi9cbiAgICB0aGlzLmF1ZGlvTGV2ZWwgPSAwO1xuICAgIC8qKiBpZiBwYXJ0aWNpcGFudCBpcyBjdXJyZW50bHkgc3BlYWtpbmcgKi9cbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldFRyYWNrcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHNvdXJjZSBmaWx0ZXIsIGZvciBleGFtcGxlLCBnZXR0aW5nXG4gICAqIHRoZSB1c2VyJ3MgY2FtZXJhIHRyYWNrIHdpdGggZ2V0VHJhY2tCeVNvdXJjZShUcmFjay5Tb3VyY2UuQ2FtZXJhKS5cbiAgICogQHBhcmFtIHNvdXJjZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VHJhY2soc291cmNlKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tzKSB7XG4gICAgICBpZiAocHViLnNvdXJjZSA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSB0cmFjaydzIG5hbWUuXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tzKSB7XG4gICAgICBpZiAocHViLnRyYWNrTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICB9XG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICByZXR1cm4gISgoX2EgPSB0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2suaXNNdXRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XG4gIH1cbiAgZ2V0IGlzTWljcm9waG9uZUVuYWJsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFjayhUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICB9XG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLlNjcmVlblNoYXJlKTtcbiAgICByZXR1cm4gISF0cmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gIGdldCBqb2luZWRBdCgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy5wYXJ0aWNpcGFudEluZm8uam9pbmVkQXQudG9TdHJpbmcoKSkgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoZSB1cGRhdGUgY291bGQgYmUgYXBwbGllZCBvdXQgb2Ygb3JkZXIgZHVlIHRvIGF3YWl0XG4gICAgLy8gZHVyaW5nIHJlY29ubmVjdCBzZXF1ZW5jZXMuIHdoZW4gdGhhdCBoYXBwZW5zLCBpdCdzIHBvc3NpYmxlIGZvciBzZXJ2ZXJcbiAgICAvLyB0byBoYXZlIHNlbnQgbW9yZSByZWNlbnQgdmVyc2lvbiBvZiBwYXJ0aWNpcGFudCBpbmZvIHdoaWxlIEpTIGlzIHdhaXRpbmdcbiAgICAvLyB0byBwcm9jZXNzIHRoZSBleGlzdGluZyBwYXlsb2FkLlxuICAgIC8vIHdoZW4gdGhlIHBhcnRpY2lwYW50IHNpZCByZW1haW5zIHRoZSBzYW1lLCBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgbGF0ZXIgdmVyc2lvblxuICAgIC8vIG9mIHRoZSBwYXlsb2FkLCB0aGV5IGNhbiBiZSBzYWZlbHkgc2tpcHBlZFxuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SW5mbyAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby5zaWQgPT09IGluZm8uc2lkICYmIHRoaXMucGFydGljaXBhbnRJbmZvLnZlcnNpb24gPiBpbmZvLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pZGVudGl0eSA9IGluZm8uaWRlbnRpdHk7XG4gICAgdGhpcy5zaWQgPSBpbmZvLnNpZDtcbiAgICB0aGlzLl9zZXROYW1lKGluZm8ubmFtZSk7XG4gICAgdGhpcy5fc2V0TWV0YWRhdGEoaW5mby5tZXRhZGF0YSk7XG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9ucyhpbmZvLnBlcm1pc3Npb24pO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKCd1cGRhdGUgcGFydGljaXBhbnQgaW5mbycsIHtcbiAgICAgIGluZm9cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBtZXRhZGF0YSBmcm9tIHNlcnZlclxuICAgKiovXG4gIF9zZXRNZXRhZGF0YShtZCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZDtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHByZXZNZXRhZGF0YSk7XG4gICAgfVxuICB9XG4gIF9zZXROYW1lKG5hbWUpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5uYW1lICE9PSBuYW1lO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2gpIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZSAhPT0gKChfYiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5TdWJzY3JpYmUpIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSAoKF9jID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhblB1Ymxpc2hEYXRhKSB8fCBwZXJtaXNzaW9ucy5oaWRkZW4gIT09ICgoX2QgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGlkZGVuKSB8fCBwZXJtaXNzaW9ucy5yZWNvcmRlciAhPT0gKChfZSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWNvcmRlcikgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5QdWJsaXNoU291cmNlc1tpbmRleF0pO1xuICAgIH0pO1xuICAgIHRoaXMucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucztcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0SXNTcGVha2luZyhzcGVha2luZykge1xuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgIGlmIChzcGVha2luZykge1xuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRDb25uZWN0aW9uUXVhbGl0eShxKSB7XG4gICAgY29uc3QgcHJldlF1YWxpdHkgPSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IHF1YWxpdHlGcm9tUHJvdG8ocSk7XG4gICAgaWYgKHByZXZRdWFsaXR5ICE9PSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChjdHgpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGN0eDtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzLmZvckVhY2godHJhY2sgPT4gKHRyYWNrLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjayB8fCB0cmFjay50cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykgJiYgdHJhY2sudHJhY2suc2V0QXVkaW9Db250ZXh0KGN0eCkpO1xuICB9XG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcbiAgICAvLyBmb3J3YXJkIHB1YmxpY2F0aW9uIGRyaXZlbiBldmVudHNcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50Lk11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBjb25zdCBwdWIgPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICBwdWIudHJhY2suc2lkID0gcHVibGljYXRpb24udHJhY2tTaWQ7XG4gICAgfVxuICAgIHRoaXMudHJhY2tzLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tzLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrcy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXMpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICghcGVybXMucGFydGljaXBhbnRTaWQgJiYgIXBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhY2sgcGVybWlzc2lvbiwgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBvZiBwYXJ0aWNpcGFudElkZW50aXR5IGFuZCBwYXJ0aWNpcGFudFNpZCcpO1xuICB9XG4gIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKHtcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiAoX2EgPSBwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcbiAgICBwYXJ0aWNpcGFudFNpZDogKF9iID0gcGVybXMucGFydGljaXBhbnRTaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgIGFsbFRyYWNrczogKF9jID0gcGVybXMuYWxsb3dBbGwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxuICAgIHRyYWNrU2lkczogcGVybXMuYWxsb3dlZFRyYWNrU2lkcyB8fCBbXVxuICB9KTtcbn1cblxuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgYXV0b1N1YnNjcmliZSkge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB2aXNpYmxlID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5IFwiLmNvbmNhdCh0aGlzLnRyYWNrU2lkLCBcIiwgdmlzaWJsZT1cIikuY29uY2F0KHZpc2libGUpLCB7XG4gICAgICAgIHRyYWNrU2lkOiB0aGlzLnRyYWNrU2lkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSA9IGRpbWVuc2lvbnMgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcImFkYXB0aXZlc3RyZWFtIHZpZGVvIGRpbWVuc2lvbnMgXCIuY29uY2F0KGRpbWVuc2lvbnMud2lkdGgsIFwieFwiKS5jb25jYXQoZGltZW5zaW9ucy5oZWlnaHQpLCB7XG4gICAgICAgIHRyYWNrU2lkOiB0aGlzLnRyYWNrU2lkXG4gICAgICB9KTtcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB0byB0aGlzIHJlbW90ZSB0cmFja1xuICAgKiBAcGFyYW0gc3Vic2NyaWJlZCB0cnVlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBmYWxzZSB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgc2V0U3Vic2NyaWJlZChzdWJzY3JpYmVkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgLy8gcmVzZXQgYWxsb3dlZCBzdGF0dXMgd2hlbiBkZXNpcmVkIHN1YnNjcmlwdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAgLy8gc2VydmVyIHdpbGwgbm90aWZ5IGNsaWVudCB2aWEgc2lnbmFsIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxsb3dlZFxuICAgIGlmIChzdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWIgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrczogW25ldyBQYXJ0aWNpcGFudFRyYWNrcyh7XG4gICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgIHBhcnRpY2lwYW50U2lkOiAnJyxcbiAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF1cbiAgICAgIH0pXVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gIH1cbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlVuc3Vic2NyaWJlZDtcbiAgICB9XG4gICAgaWYgKCFzdXBlci5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5EZXNpcmVkO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuU3Vic2NyaWJlZDtcbiAgfVxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkID8gVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLkFsbG93ZWQgOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuTm90QWxsb3dlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICovXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzU3Vic2NyaWJlZDtcbiAgfVxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xuICB9XG4gIC8qKlxuICAgKiBkaXNhYmxlIHNlcnZlciBmcm9tIHNlbmRpbmcgZG93biBkYXRhIGZvciB0aGlzIHRyYWNrLiB0aGlzIGlzIHVzZWZ1bCB3aGVuXG4gICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cbiAgICogdG8gcmVkdWNlIGJhbmR3aWR0aCByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIGVuYWJsZWRcbiAgICovXG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmRpc2FibGVkID09PSAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVkID0gIWVuYWJsZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogZm9yIHRyYWNrcyB0aGF0IHN1cHBvcnQgc2ltdWxjYXN0aW5nLCBhZGp1c3Qgc3Vic2NyaWJlZCBxdWFsaXR5XG4gICAqXG4gICAqIFRoaXMgaW5kaWNhdGVzIHRoZSBoaWdoZXN0IHF1YWxpdHkgdGhlIGNsaWVudCBjYW4gYWNjZXB0LiBpZiBuZXR3b3JrXG4gICAqIGJhbmR3aWR0aCBkb2VzIG5vdCBhbGxvdywgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgcXVhbGl0eSB0b1xuICAgKiBvcHRpbWl6ZSBmb3IgdW5pbnRlcnJ1cHRlZCB2aWRlb1xuICAgKi9cbiAgc2V0VmlkZW9RdWFsaXR5KHF1YWxpdHkpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID09PSBxdWFsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBzZXRWaWRlb0RpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IGRpbWVuc2lvbnMud2lkdGggJiYgKChfYiA9IHRoaXMudmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gZGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2sgaW5zdGFuY2VvZiBSZW1vdGVWaWRlb1RyYWNrKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG4gIHNldFZpZGVvRlBTKGZwcykge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh0aGlzLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlVmlkZW9UcmFjaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnBzID09PSBmcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfVxuICBnZXQgdmlkZW9RdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBjb25zdCBwcmV2VHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIGlmIChwcmV2VHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmV2VHJhY2spIHtcbiAgICAgIC8vIHVucmVnaXN0ZXIgbGlzdGVuZXJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgcHJldlRyYWNrLmRldGFjaCgpO1xuICAgICAgcHJldlRyYWNrLnN0b3BNb25pdG9yKCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZUcmFjayk7XG4gICAgfVxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnNpZCA9IHRoaXMudHJhY2tTaWQ7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0QWxsb3dlZChhbGxvd2VkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIHN1cGVyLnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhTXV0ZWQgPSB0aGlzLm1ldGFkYXRhTXV0ZWQ7XG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gaW5mby5tdXRlZDtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5zZXRNdXRlZChpbmZvLm11dGVkKTtcbiAgICB9IGVsc2UgaWYgKHByZXZNZXRhZGF0YU11dGVkICE9PSBpbmZvLm11dGVkKSB7XG4gICAgICB0aGlzLmVtaXQoaW5mby5tdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQpO1xuICAgIH1cbiAgfVxuICBlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gY3VycmVudFN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBjdXJyZW50U3RhdHVzLCBwcmV2aW91c1N0YXR1cyk7XG4gIH1cbiAgZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzICE9PSBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpIHtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCB0aGlzLnBlcm1pc3Npb25TdGF0dXMsIHByZXZpb3VzUGVybWlzc2lvblN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIHRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB2aWRlbyB0cmFjayBzZXR0aW5ncycsIHtcbiAgICAgICAgdHJhY2tTaWQ6IHRoaXMudHJhY2tTaWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXNpcmVkKSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Nhbm5vdCB1cGRhdGUgdHJhY2sgc2V0dGluZ3Mgd2hlbiBub3Qgc3Vic2NyaWJlZCcsIHtcbiAgICAgICAgdHJhY2tTaWQ6IHRoaXMudHJhY2tTaWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayBpbnN0YW5jZW9mIFJlbW90ZVZpZGVvVHJhY2sgJiYgdGhpcy50cmFjay5pc0FkYXB0aXZlU3RyZWFtO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBlbWl0VHJhY2tVcGRhdGUoKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncyh7XG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcbiAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgZnBzOiB0aGlzLmZwc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGZyb21QYXJ0aWNpcGFudEluZm8oc2lnbmFsQ2xpZW50LCBwaSkge1xuICAgIHJldHVybiBuZXcgUmVtb3RlUGFydGljaXBhbnQoc2lnbmFsQ2xpZW50LCBwaS5zaWQsIHBpLmlkZW50aXR5LCBwaS5uYW1lLCBwaS5tZXRhZGF0YSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhKSB7XG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSB8fCAnJywgbmFtZSwgbWV0YWRhdGEpO1xuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKSB7XG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgLy8gcmVnaXN0ZXIgYWN0aW9uIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3NlbmQgdXBkYXRlIHNldHRpbmdzJywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIgPT4ge1xuICAgICAgc3ViLnBhcnRpY2lwYW50VHJhY2tzLmZvckVhY2gocHQgPT4ge1xuICAgICAgICBwdC5wYXJ0aWNpcGFudFNpZCA9IHRoaXMuc2lkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2sgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhY2soc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja0J5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHNldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBhdWRpbyB0cmFja1xuICAgKiBieSBkZWZhdWx0LCB0aGlzIGFmZmVjdHMgdGhlIG1pY3JvcGhvbmUgcHVibGljYXRpb25cbiAgICogYSBkaWZmZXJlbnQgc291cmNlIGNhbiBiZSBwYXNzZWQgaW4gYXMgYSBzZWNvbmQgYXJndW1lbnRcbiAgICogaWYgbm8gdHJhY2sgZXhpc3RzIHRoZSB2b2x1bWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIG1pY3JvcGhvbmUgdHJhY2sgaXMgYWRkZWRcbiAgICovXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrKHNvdXJjZSk7XG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgYXVkaW9QdWJsaWNhdGlvbi50cmFjay5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXG4gICAqL1xuICBnZXRWb2x1bWUoKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2soc291cmNlKTtcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICByZXR1cm4gYXVkaW9QdWJsaWNhdGlvbi50cmFjay5nZXRWb2x1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudm9sdW1lTWFwLmdldChzb3VyY2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCkge1xuICAgIC8vIGZpbmQgdGhlIHRyYWNrIHB1YmxpY2F0aW9uXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIG1lZGlhIHRyYWNrIHRvIGFycml2ZSBiZWZvcmUgcGFydGljaXBhbnQgaW5mb1xuICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzaWQpO1xuICAgIC8vIGl0J3MgYWxzbyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGRpZG4ndCBob25vciBvdXIgb3JpZ2luYWwgdHJhY2sgaWRcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAoIXNpZC5zdGFydHNXaXRoKCdUUicpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXG4gICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxuICAgIC8vIHlldCBhcnJpdmVkLiBXYWl0IGEgYml0IGxvbmdlciBmb3IgaXQgdG8gYXJyaXZlLCBvciBmaXJlIGFuIGVycm9yXG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCdjb3VsZCBub3QgZmluZCBwdWJsaXNoZWQgdHJhY2snLCB7XG4gICAgICAgICAgcGFydGljaXBhbnQ6IHRoaXMuc2lkLFxuICAgICAgICAgIHRyYWNrU2lkOiBzaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCAtIDEpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcigndW5hYmxlIHRvIHN1YnNjcmliZSBiZWNhdXNlIE1lZGlhU3RyZWFtVHJhY2sgaXMgZW5kZWQuIERvIG5vdCBjYWxsIE1lZGlhU3RyZWFtVHJhY2suc3RvcCgpJywge1xuICAgICAgICBwYXJ0aWNpcGFudDogdGhpcy5zaWQsXG4gICAgICAgIHRyYWNrU2lkOiBzaWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzVmlkZW8gPSBtZWRpYVRyYWNrLmtpbmQgPT09ICd2aWRlbyc7XG4gICAgbGV0IHRyYWNrO1xuICAgIGlmIChpc1ZpZGVvKSB7XG4gICAgICB0cmFjayA9IG5ldyBSZW1vdGVWaWRlb1RyYWNrKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjayA9IG5ldyBSZW1vdGVBdWRpb1RyYWNrKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF1ZGlvT3V0cHV0KTtcbiAgICB9XG4gICAgLy8gc2V0IHRyYWNrIGluZm9cbiAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XG4gICAgLy8ga2VlcCBwdWJsaWNhdGlvbidzIG11dGVkIHN0YXR1c1xuICAgIHRyYWNrLmlzTXV0ZWQgPSBwdWJsaWNhdGlvbi5pc011dGVkO1xuICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcbiAgICB0cmFjay5zdGFydCgpO1xuICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHRyYWNrKTtcbiAgICAvLyBzZXQgcGFydGljaXBhbnQgdm9sdW1lcyBvbiBuZXcgYXVkaW8gdHJhY2tzXG4gICAgaWYgKHRoaXMudm9sdW1lTWFwLmhhcyhwdWJsaWNhdGlvbi5zb3VyY2UpICYmIHRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjaykge1xuICAgICAgdHJhY2suc2V0Vm9sdW1lKHRoaXMudm9sdW1lTWFwLmdldChwdWJsaWNhdGlvbi5zb3VyY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGhhc01ldGFkYXRhKCkge1xuICAgIHJldHVybiAhIXRoaXMucGFydGljaXBhbnRJbmZvO1xuICB9XG4gIGdldFRyYWNrUHVibGljYXRpb24oc2lkKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzLmdldChzaWQpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvKSB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHdlIGFyZSBnZXR0aW5nIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIHRyYWNrcywgcmVjb25jaWxlIGluIGhlcmVcbiAgICAvLyBhbmQgc2VuZCBvdXQgZXZlbnRzIGZvciBjaGFuZ2VzXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIHB1YmxpY2F0aW9ucywgcHVibGlzaCBldmVudHMgb25seSBpZiBtZXRhZGF0YSBpcyBhbHJlYWR5IHRoZXJlXG4gICAgLy8gaS5lLiBjaGFuZ2VzIHNpbmNlIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCBoYXMgam9pbmVkXG4gICAgY29uc3QgdmFsaWRUcmFja3MgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGluZm8udHJhY2tzLmZvckVhY2godGkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHRpLnNpZCk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcbiAgICAgICAgaWYgKCFraW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHB1YmxpY2F0aW9uID0gbmV3IFJlbW90ZVRyYWNrUHVibGljYXRpb24oa2luZCwgdGksIChfYSA9IHRoaXMuc2lnbmFsQ2xpZW50LmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b1N1YnNjcmliZSk7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgICBuZXdUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tzLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5zb3VyY2UpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiBwdWJsaWNhdGlvbi5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciBcIi5jb25jYXQodGhpcy5pZGVudGl0eSwgXCIgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiKS5jb25jYXQocHVibGljYXRpb24uc291cmNlKSwge1xuICAgICAgICAgICAgb2xkVHJhY2s6IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSxcbiAgICAgICAgICAgIG5ld1RyYWNrOiBwdWJsaWNhdGlvbixcbiAgICAgICAgICAgIHBhcnRpY2lwYW50OiB0aGlzLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJbmZvOiBpbmZvXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgfVxuICAgICAgdmFsaWRUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIC8vIGRldGVjdCByZW1vdmVkIHRyYWNrc1xuICAgIHRoaXMudHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIudHJhY2UoJ2RldGVjdGVkIHJlbW92ZWQgdHJhY2sgb24gcmVtb3RlIHBhcnRpY2lwYW50LCB1bnB1Ymxpc2hpbmcnLCB7XG4gICAgICAgICAgcHVibGljYXRpb24sXG4gICAgICAgICAgcGFydGljaXBhbnRTaWQ6IHRoaXMuc2lkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhbHdheXMgZW1pdCBldmVudHMgZm9yIG5ldyBwdWJsaWNhdGlvbnMsIFJvb20gd2lsbCBub3QgZm9yd2FyZCB0aGVtIHVubGVzcyBpdCdzIHJlYWR5XG4gICAgbmV3VHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVucHVibGlzaFRyYWNrKHNpZCwgc2VuZFVucHVibGlzaCkge1xuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy50cmFja3MuZ2V0KHNpZCk7XG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhbHNvIHNlbmQgdW5zdWJzY3JpYmUsIGlmIHRyYWNrIGlzIGFjdGl2ZWx5IHN1YnNjcmliZWRcbiAgICBjb25zdCB7XG4gICAgICB0cmFja1xuICAgIH0gPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB0cmFjayBmcm9tIG1hcHMgb25seSBhZnRlciB1bnN1YnNjcmliZWQgaGFzIGJlZW4gZmlyZWRcbiAgICB0aGlzLnRyYWNrcy5kZWxldGUoc2lkKTtcbiAgICAvLyByZW1vdmUgZnJvbSB0aGUgcmlnaHQgdHlwZSBtYXBcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrcy5kZWxldGUoc2lkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XG4gICAgICAgIHRoaXMudmlkZW9UcmFja3MuZGVsZXRlKHNpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc2VuZFVucHVibGlzaCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBdWRpb091dHB1dChvdXRwdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5hdWRpb091dHB1dCA9IG91dHB1dDtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tzLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocHViLnRyYWNrIGluc3RhbmNlb2YgUmVtb3RlQXVkaW9UcmFjaykge1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZCgoX2EgPSBvdXRwdXQuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdkZWZhdWx0JykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZSgncGFydGljaXBhbnQgZXZlbnQnLCB7XG4gICAgICBwYXJ0aWNpcGFudDogdGhpcy5zaWQsXG4gICAgICBldmVudCxcbiAgICAgIGFyZ3NcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cblxuY2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBlbmdpbmUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5KTtcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldCgpO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gdHJ1ZTtcbiAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVjb25uZWN0RnV0dXJlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaChlID0+IGxpdmVraXRMb2dnZXIud2FybihlKSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ0dvdCBkaXNjb25uZWN0ZWQgZHVyaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zID0gKCkgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywge1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkOiB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcbiAgICAgICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLCB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucy5tYXAocCA9PiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHApKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5vblRyYWNrVW5tdXRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc1Vwc3RyZWFtUGF1c2VkKTtcbiAgICB9O1xuICAgIC8vIHdoZW4gdGhlIGxvY2FsIHRyYWNrIGNoYW5nZXMgaW4gbXV0ZSBzdGF0dXMsIHdlJ2xsIG5vdGlmeSBzZXJ2ZXIgYXMgc3VjaFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcbiAgICAgIGlmIChtdXRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suc2lkKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoJ2NvdWxkIG5vdCB1cGRhdGUgbXV0ZSBzdGF0dXMgZm9yIHVucHVibGlzaGVkIHRyYWNrJywgdHJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVuZ2luZS51cGRhdGVNdXRlU3RhdHVzKHRyYWNrLnNpZCwgbXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQgPSB0cmFjayA9PiB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1cHN0cmVhbSBwYXVzZWQnKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9IHRyYWNrID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3Vwc3RyZWFtIHJlc3VtZWQnKTtcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc011dGVkKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgIHZhciBfZCwgX2U7XG4gICAgICBpZiAoISgoX2QgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHluYWNhc3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja3MuZ2V0KHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCB7XG4gICAgICAgICAgbWV0aG9kOiAnaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnLFxuICAgICAgICAgIHNpZDogdXBkYXRlLnRyYWNrU2lkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlLnN1YnNjcmliZWRDb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IHlpZWxkIHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgbmV3Q29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKG5ld0NvZGVjcyksIG5ld0NvZGVjc18xXzE7IG5ld0NvZGVjc18xXzEgPSB5aWVsZCBuZXdDb2RlY3NfMS5uZXh0KCksIF9hID0gbmV3Q29kZWNzXzFfMS5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2MgPSBuZXdDb2RlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2M7XG4gICAgICAgICAgICBpZiAoaXNCYWNrdXBDb2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInB1Ymxpc2ggXCIuY29uY2F0KGNvZGVjLCBcIiBmb3IgXCIpLmNvbmNhdChwdWIudmlkZW9UcmFjay5zaWQpKTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2socHViLnZpZGVvVHJhY2ssIGNvZGVjLCBwdWIub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgIGVfMSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IG5ld0NvZGVjc18xLnJldHVybikpIHlpZWxkIF9iLmNhbGwobmV3Q29kZWNzXzEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpYmVkUXVhbGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgKF9lID0gcHViLnZpZGVvVHJhY2spID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zZXRQdWJsaXNoaW5nTGF5ZXJzKHVwZGF0ZS5zdWJzY3JpYmVkUXVhbGl0aWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVucHVibGlzaGVkID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3MuZ2V0KHVucHVibGlzaGVkLnRyYWNrU2lkKTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdyZWNlaXZlZCB1bnB1Ymxpc2hlZCBldmVudCBmb3IgdW5rbm93biB0cmFjaycsIHtcbiAgICAgICAgICBtZXRob2Q6ICdoYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxuICAgICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSB0cmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbykge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCB7XG4gICAgICAgICAgdHJhY2s6IHRyYWNrLnNpZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2sgfHwgdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zID0geWllbGQgbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGVybWlzc2lvbiBxdWVyeSBmb3IgY2FtZXJhIGFuZCBtaWNyb3Bob25lIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBuYW1lOiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgPyAnY2FtZXJhJyA6ICdtaWNyb3Bob25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwidXNlciBoYXMgcmV2b2tlZCBhY2Nlc3MgdG8gXCIuY29uY2F0KHRyYWNrLnNvdXJjZSkpO1xuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBncmFudGVkIGNoYW5nZSBhZnRlciBwZXJtaXNzaW9ucyB3ZXJlIGRlbmllZCB0byB0cnkgYW5kIHJlc3VtZSB0aGVuXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSAhPT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0VXNlck1lZGlhIFBlcm1pc3Npb24gZGVuaWVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMgcXVlcnkgZmFpbHMgZm9yIGZpcmVmb3gsIHdlIGNvbnRpbnVlIGFuZCB0cnkgdG8gcmVzdGFydCB0aGUgdHJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd0cmFjayBlbmRlZCwgYXR0ZW1wdGluZyB0byB1c2UgYSBkaWZmZXJlbnQgZGV2aWNlJyk7XG4gICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJjb3VsZCBub3QgcmVzdGFydCB0cmFjaywgbXV0aW5nIGluc3RlYWRcIik7XG4gICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgIHRoaXMucm9vbU9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2V0dXBFbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLmFjdGl2ZURldmljZU1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgbGFzdENhbWVyYUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xuICB9XG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLm1pY3JvcGhvbmVFcnJvcjtcbiAgfVxuICBnZXQgaXNFMkVFRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgZ2V0VHJhY2soc291cmNlKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFjayhzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICBnZXRUcmFja0J5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja0J5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUmVtb3RlTXV0ZSwgKHRyYWNrU2lkLCBtdXRlZCkgPT4ge1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja3MuZ2V0KHRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIHB1Yi5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWIudW5tdXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKS5vbihFbmdpbmVFdmVudC5SZXN1bWluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKS5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBUaGUgY2hhbmdlIGRvZXMgbm90IHRha2UgaW1tZWRpYXRlIGVmZmVjdC5cbiAgICogSWYgc3VjY2Vzc2Z1bCwgYSBgUGFydGljaXBhbnRFdmVudC5NZXRhZGF0YUNoYW5nZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YSwgKF9hID0gdGhpcy5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBUaGUgY2hhbmdlIGRvZXMgbm90IHRha2UgaW1tZWRpYXRlIGVmZmVjdC5cbiAgICogSWYgc3VjY2Vzc2Z1bCwgYSBgUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAqL1xuICBzZXROYW1lKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKChfYSA9IHRoaXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0Q2FtZXJhRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRNaWNyb3Bob25lRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHN1cGVyLnNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICBpZiAoY2hhbmdlZCAmJiBwcmV2UGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEUyRUVFbmFibGVkKGVuYWJsZWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBzZXRUcmFja0VuYWJsZWQoc291cmNlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9KTtcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuZ2V0VHJhY2soc291cmNlKTtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnVubXV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsb2NhbFRyYWNrcztcbiAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdza2lwcGluZyBkdXBsaWNhdGUgcHVibGlzaGVkIHNvdXJjZScsIHtcbiAgICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG5vLW9wIGl0J3MgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChzb3VyY2UpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgICB2aWRlbzogKF9hID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgICAgICAgICAgYXVkaW86IChfYiA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU6XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVNjcmVlblRyYWNrcyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9jYWxUcmFjayBvZiBsb2NhbFRyYWNrcykge1xuICAgICAgICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ3B1Ymxpc2hpbmcgdHJhY2snLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcHVibGlzaFByb21pc2VzLnB1c2godGhpcy5wdWJsaXNoVHJhY2sobG9jYWxUcmFjaywgcHVibGlzaE9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrcyA9IHlpZWxkIFByb21pc2UuYWxsKHB1Ymxpc2hQcm9taXNlcyk7XG4gICAgICAgICAgICAvLyBmb3Igc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9ucyBpbmNsdWRpbmcgYXVkaW8sIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9uLCBub3QgdGhlIHNjcmVlbiBzaGFyZSBhdWRpbyBvbmVcbiAgICAgICAgICAgIC8vIHJldmlzaXQgaWYgd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgdHJhY2tzIGluc3RlYWQgZm9yIHYyXG4gICAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICAgICAgdHIuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmICEoZSBpbnN0YW5jZW9mIFRyYWNrSW52YWxpZEVycm9yKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayAmJiB0cmFjay50cmFjaykge1xuICAgICAgICAvLyBzY3JlZW5zaGFyZSBjYW5ub3QgYmUgbXV0ZWQsIHVucHVibGlzaCBpbnN0ZWFkXG4gICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xuICAgICAgICAgIHRyYWNrID0geWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XG4gICAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW9UcmFjayA9IHRoaXMuZ2V0VHJhY2soVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pO1xuICAgICAgICAgIGlmIChzY3JlZW5BdWRpb1RyYWNrICYmIHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGJvdGggY2FtZXJhIGFuZCBtaWNyb3Bob25lIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiBkaXNwbGF5aW5nIGEgc2luZ2xlIFBlcm1pc3Npb24gRGlhbG9nIGJveCB0byB0aGUgZW5kIHVzZXIuXG4gICAqL1xuICBlbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHwgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpKSB7XG4gICAgICAgIC8vIG5vLW9wIGl0J3MgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0cmFjayA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjcmVhdGVUcmFja3Mob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdWRpb0NhcHR1cmVEZWZhdWx0cywgKF9iID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZpZGVvQ2FwdHVyZURlZmF1bHRzKTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuICAgICAgbGV0IHN0cmVhbTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJlYW0uZ2V0VHJhY2tzKCkubWFwKG1lZGlhU3RyZWFtVHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBpc0F1ZGlvID0gbWVkaWFTdHJlYW1UcmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgICBpc0F1ZGlvID8gb3B0aW9ucy5hdWRpbyA6IG9wdGlvbnMudmlkZW87XG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25PckJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMpO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxuICAgKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZVNjcmVlblRyYWNrcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xuICAgICAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgdHJhY2sgdG8gdGhlIHJvb21cbiAgICogQHBhcmFtIHRyYWNrXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2sgJiYgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmhhcyh0cmFjaykpIHtcbiAgICAgICAgeWllbGQgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XG4gICAgICB9XG4gICAgICBsZXQgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBhY2Nlc3MgY29uc3RyYWludHMgZGlyZWN0bHkgYXMgYHRyYWNrLm1lZGlhU3RyZWFtVHJhY2tgXG4gICAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suY29uc3RyYWludHM7XG4gICAgICAgIGxldCBkZXZpY2VLaW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLnNvdXJjZSkge1xuICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLk1pY3JvcGhvbmU6XG4gICAgICAgICAgICBkZXZpY2VLaW5kID0gJ2F1ZGlvaW5wdXQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgZGV2aWNlS2luZCA9ICd2aWRlb2lucHV0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV2aWNlS2luZCAmJiB0aGlzLmFjdGl2ZURldmljZU1hcC5oYXMoZGV2aWNlS2luZCkpIHtcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25zdHJhaW50cyksIHtcbiAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCByYXcgbWVkaWEgdHJhY2sgaW50byBhdWRpbyBvciB2aWRlbyB0cmFja1xuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzd2l0Y2ggKHRyYWNrLmtpbmQpIHtcbiAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgdGhpcy5hdWRpb0NvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIE1lZGlhU3RyZWFtVHJhY2sga2luZCBcIi5jb25jYXQodHJhY2sua2luZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgICAgdHJhY2suc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICAgIH1cbiAgICAgIC8vIGlzIGl0IGFscmVhZHkgcHVibGlzaGVkPyBpZiBzbyBza2lwXG4gICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgIHRoaXMudHJhY2tzLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gcHVibGljYXRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCd0cmFjayBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmcnKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHVibGljYXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N0ZXJlb0lucHV0ID0gJ2NoYW5uZWxDb3VudCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpICYmXG4gICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCA9PT0gMiB8fCB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCkuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgY29uc3QgaXNTdGVyZW8gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2VTdGVyZW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzU3RlcmVvSW5wdXQ7XG4gICAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcbiAgICAgIGlmIChpc1N0ZXJlbykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZHR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIk9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuXCIpO1xuICAgICAgICB9XG4gICAgICAgIChfYyA9IG9wdGlvbnMuZHR4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBvcHRpb25zLmR0eCA9IGZhbHNlO1xuICAgICAgICAoX2QgPSBvcHRpb25zLnJlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3B0aW9ucy5yZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XG4gICAgICAvLyBkaXNhYmxlIHNpbXVsY2FzdCBpZiBlMmVlIGlzIHNldCBvbiBzYWZhcmlcbiAgICAgIGlmIChpc1NhZmFyaSgpICYmIHRoaXMucm9vbU9wdGlvbnMuZTJlZSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJFbmQtdG8tZW5kIGVuY3J5cHRpb24gaXMgc2V0IHVwLCBzaW11bGNhc3QgcHVibGlzaGluZyB3aWxsIGJlIGRpc2FibGVkIG9uIFNhZmFyaVwiKTtcbiAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnNvdXJjZSkge1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlID0gdGhpcy5wdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbyk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuc2V0KHRyYWNrLCBwdWJsaXNoUHJvbWlzZSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZGVsZXRlKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrcy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiB0cmFjayBpbnN0YW5jZW9mIExvY2FsVHJhY2sgJiYgcHVibGlzaGVkVHJhY2suc291cmNlID09PSB0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcInB1Ymxpc2hpbmcgYSBzZWNvbmQgdHJhY2sgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiB0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjaykge1xuICAgICAgICB0cmFjay5zdG9wT25NdXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBpc0ZpcmVGb3goKSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxuICAgICAgICAvLyB3ZSBmcmVxdWVudGx5IGdldCBubyBkYXRhIG9uIGxheWVyIDAgd2hlbiBlbmFibGVkXG4gICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ2F2MScgJiYgIXN1cHBvcnRzQVYxKCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ3ZwOScgJiYgIXN1cHBvcnRzVlA5KCkpIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IGRlZmF1bHRWaWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICAgIC8vIGhhbmRsZSB0cmFjayBhY3Rpb25zXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICAvLyBnZXQgbG9jYWwgdHJhY2sgaWQgZm9yIHVzZSBkdXJpbmcgcHVibGlzaGluZ1xuICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgZGlzYWJsZUR0eDogISgoX2EgPSBvcHRzLmR0eCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSksXG4gICAgICAgIGVuY3J5cHRpb246IHRoaXMuZW5jcnlwdGlvblR5cGUsXG4gICAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICAgIGRpc2FibGVSZWQ6IHRoaXMuaXNFMkVFRW5hYmxlZCB8fCAhKChfYiA9IG9wdHMucmVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSxcbiAgICAgICAgc3RyZWFtOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc3RyZWFtXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbXB1dGUgZW5jb2RpbmdzIGFuZCBsYXllcnMgZm9yIHZpZGVvXG4gICAgICBsZXQgZW5jb2RpbmdzO1xuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgbGV0IGRpbXMgPSB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGltcyA9IHlpZWxkIHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyB1c2UgZGVmYXVsdHMsIGl0J3MgcXVpdGUgcGFpbmZ1bCBmb3IgY29uZ2VzdGlvbiBjb250cm9sIHdpdGhvdXQgc2ltdWxjYXN0XG4gICAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXG4gICAgICAgICAgY29uc3QgZGVmYXVsdFJlcyA9IChfZCA9IChfYyA9IHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNvbHV0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBWaWRlb1ByZXNldHMuaDcyMC5yZXNvbHV0aW9uO1xuICAgICAgICAgIGRpbXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZGVmYXVsdFJlcy5oZWlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZyBmYWlsdXJlXG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIGRpbXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgc2hvdWxkIGJlIGRlZmluZWQgZm9yIHZpZGVvXG4gICAgICAgIHJlcS53aWR0aCA9IGRpbXMud2lkdGg7XG4gICAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgICAgLy8gZm9yIHN2YyBjb2RlY3MsIGRpc2FibGUgc2ltdWxjYXN0IGFuZCB1c2UgdnA4IGZvciBiYWNrdXAgY29kZWNcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcbiAgICAgICAgICAgIC8vIHZwOSBzdmMgd2l0aCBzY3JlZW5zaGFyZSBoYXMgcHJvYmxlbSB0byBlbmNvZGUsIGFsd2F5cyB1c2UgTDFUMyBoZXJlXG4gICAgICAgICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdmlkZW9Db2RlYyA9PT0gJ3ZwOScpIHtcbiAgICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAoX2UgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ0wzVDNfS0VZJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtuZXcgU2ltdWxjYXN0Q29kZWMoe1xuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0ge1xuICAgICAgICAgICAgICBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjICYmIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCBjb2RlY3NcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcbiAgICAgICAgICAgIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCByZXF1aXJlcyBkeW5hY2FzdFxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcy5wdXNoKG5ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICAgIGNvZGVjOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxuICAgICAgICAgICAgICBjaWQ6ICcnXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncywgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICBlbmNvZGluZ3MgPSBbe1xuICAgICAgICAgIG1heEJpdHJhdGU6IChfZyA9IChfZiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBvcHRzLmF1ZGlvQml0cmF0ZSxcbiAgICAgICAgICBwcmlvcml0eTogKF9qID0gKF9oID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnByaW9yaXR5KSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAnaGlnaCcsXG4gICAgICAgICAgbmV0d29ya1ByaW9yaXR5OiAoX2wgPSAoX2sgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2sucHJpb3JpdHkpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6ICdoaWdoJ1xuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGkgPSB5aWVsZCB0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpO1xuICAgICAgLy8gc2VydmVyIG1pZ2h0IG5vdCBzdXBwb3J0IHRoZSBjb2RlYyB0aGUgY2xpZW50IGhhcyByZXF1ZXN0ZWQsIGluIHRoYXQgY2FzZSwgZmFsbGJhY2tcbiAgICAgIC8vIHRvIGEgc3VwcG9ydGVkIGNvZGVjXG4gICAgICBsZXQgcHJpbWFyeUNvZGVjTWltZTtcbiAgICAgIHRpLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByaW1hcnlDb2RlY01pbWUgPSBjb2RlYy5taW1lVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xuICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnZmFsbGluZyBiYWNrIHRvIHNlcnZlciBzZWxlY3RlZCBjb2RlYycsIHtcbiAgICAgICAgICAgIGNvZGVjOiB1cGRhdGVkQ29kZWNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdXBkYXRlZENvZGVjO1xuICAgICAgICAgIC8vIHJlY29tcHV0ZSBlbmNvZGluZ3Mgc2luY2UgYml0cmF0ZXMvZXRjIGNvdWxkIGhhdmUgY2hhbmdlZFxuICAgICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHVibGljYXRpb24gPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKHRyYWNrLmtpbmQsIHRpLCB0cmFjayk7XG4gICAgICAvLyBzYXZlIG9wdGlvbnMgZm9yIHdoZW4gaXQgbmVlZHMgdG8gYmUgcmVwdWJsaXNoZWQgYWdhaW5cbiAgICAgIHB1YmxpY2F0aW9uLm9wdGlvbnMgPSBvcHRzO1xuICAgICAgdHJhY2suc2lkID0gdGkuc2lkO1xuICAgICAgaWYgKCF0aGlzLmVuZ2luZS5wY01hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3BjTWFuYWdlciBpcyBub3QgcmVhZHknKTtcbiAgICAgIH1cbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJwdWJsaXNoaW5nIFwiLmNvbmNhdCh0cmFjay5raW5kLCBcIiB3aXRoIGVuY29kaW5nc1wiKSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pO1xuICAgICAgdHJhY2suc2VuZGVyID0geWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICBpZiAoaXNGaXJlRm94KCkgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgIC8qIFJlZmVyIHRvIFJGQyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc1ODcjc2VjdGlvbi02LjEsXG4gICAgICAgICAgICAgbGl2ZWtpdC1zZXJ2ZXIgdXNlcyBtYXhhdmVyYWdlYml0cmF0ZT01MTAwMDAgaW4gdGhlIGFuc3dlciBzZHAgdG8gcGVybWl0IGNsaWVudCB0b1xuICAgICAgICAgICAgIHB1Ymxpc2ggaGlnaCBxdWFsaXR5IGF1ZGlvIHRyYWNrLiBCdXQgZmlyZWZveCBhbHdheXMgdXNlcyB0aGlzIHZhbHVlIGFzIHRoZSBhY3R1YWxcbiAgICAgICAgICAgICBiaXRyYXRlcywgY2F1c2luZyB0aGUgYXVkaW8gYml0cmF0ZXMgdG8gcmlzZSB0byA1MTBLYnBzIGluIGFueSBzdGVyZW8gY2FzZSB1bmV4cGVjdGVkbHkuXG4gICAgICAgICAgICAgU28gdGhlIGNsaWVudCBuZWVkIHRvIG1vZGlmeSBtYXhhdmVycmFnZWJpdHJhdGVzIGluIGFuc3dlciBzZHAgdG8gdXNlciBwcm92aWRlZCB2YWx1ZSB0b1xuICAgICAgICAgICAgIGZpeCB0aGUgaXNzdWUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IHRyYWNrVHJhbnNjZWl2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFjay5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgdHJhY2tUcmFuc2NlaXZlciA9IHRyYW5zY2VpdmVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xuICAgICAgICAgICAgICB0cmFuc2NlaXZlcjogdHJhY2tUcmFuc2NlaXZlcixcbiAgICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcbiAgICAgICAgICAgICAgbWF4YnI6ICgoX20gPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5tYXhCaXRyYXRlKSA/IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMCA6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5jb2RlYyAmJiBpc1NWQ0NvZGVjKHRyYWNrLmNvZGVjKSAmJiAoKF9vID0gZW5jb2RpbmdzWzBdKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ubWF4Qml0cmF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICAgIGNpZDogcmVxLmNpZCxcbiAgICAgICAgICAgIGNvZGVjOiB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKHRoaXMuZW5naW5lLmNsaWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrKSB7XG4gICAgICAgIHRyYWNrLnN0YXJ0TW9uaXRvcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgIC8vIHNlbmQgZXZlbnQgZm9yIHB1YmxpY2F0aW9uXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgICByZXR1cm4gcHVibGljYXRpb247XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbFxuICAgKiBwdWJsaXNoIGFkZGl0aW9uYWwgY29kZWMgdG8gZXhpc3RpbmcgdHJhY2tcbiAgICovXG4gIHB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayh0cmFjaywgdmlkZW9Db2RlYywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gVE9ETyByZW1vdmUgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIHRyYWNrc1xuICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlzIGl0IG5vdCBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgcHVibGlzaGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoISh0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgYSB2aWRlbyB0cmFjaycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKTtcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcImJhY2t1cCBjb2RlYyBoYXMgYmVlbiBkaXNhYmxlZCwgaWdub3JpbmcgcmVxdWVzdCB0byBhZGQgYWRkaXRpb25hbCBjb2RlYyBmb3IgdHJhY2tcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICAgIHR5cGU6IFRyYWNrLmtpbmRUb1Byb3RvKHRyYWNrLmtpbmQpLFxuICAgICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICAgIHNpZDogdHJhY2suc2lkLFxuICAgICAgICBzaW11bGNhc3RDb2RlY3M6IFt7XG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncyk7XG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpID0geWllbGQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJwdWJsaXNoZWQgXCIuY29uY2F0KHZpZGVvQ29kZWMsIFwiIGZvciB0cmFjayBcIikuY29uY2F0KHRyYWNrLnNpZCksIHtcbiAgICAgICAgZW5jb2RpbmdzLFxuICAgICAgICB0cmFja0luZm86IHRpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFjayh0cmFjaywgc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gbG9vayB0aHJvdWdoIGFsbCBwdWJsaXNoZWQgdHJhY2tzIHRvIGZpbmQgdGhlIHJpZ2h0IG9uZXNcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKTtcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3VucHVibGlzaGluZyB0cmFjaycsIHtcbiAgICAgICAgdHJhY2ssXG4gICAgICAgIG1ldGhvZDogJ3VucHVibGlzaFRyYWNrJ1xuICAgICAgfSk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3RyYWNrIHdhcyBub3QgdW5wdWJsaXNoZWQgYmVjYXVzZSBubyBwdWJsaWNhdGlvbiB3YXMgZm91bmQnLCB7XG4gICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgbWV0aG9kOiAndW5wdWJsaXNoVHJhY2snXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdHJhY2sgPSBwdWJsaWNhdGlvbi50cmFjaztcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkKTtcbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdG9wT25VbnB1Ymxpc2ggPSAoX2IgPSAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2gpIHtcbiAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZ290aWF0aW9uTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB0cmFja1NlbmRlciA9IHRyYWNrLnNlbmRlcjtcbiAgICAgIHRyYWNrLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmVuZ2luZS5wY01hbmFnZXIgJiYgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSA8IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEICYmIHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXG4gICAgICAgICAgICAvLyByZW1vdmVUcmFjayB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBlbmQgdXAgc3VjY2Vzc2Z1bGx5IHJlbW92aW5nIHRoZSB0cmFjaywgbWFudWFsbHkgc2V0XG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrU2VuZGVyKSB7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBMb2NhbFZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgdHJhY2tJbmZvXSBvZiB0cmFjay5zaW11bGNhc3RDb2RlY3MpIHtcbiAgICAgICAgICAgICAgaWYgKHRyYWNrSW5mby5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdmYWlsZWQgdG8gdW5wdWJsaXNoIHRyYWNrJywge1xuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBtZXRob2Q6ICd1bnB1Ymxpc2hUcmFjaydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICAgIHRoaXMudHJhY2tzLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICAgIHRoaXMuYXVkaW9UcmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICAgIHRoaXMudmlkZW9UcmFja3MuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFja3ModHJhY2tzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spKSk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIodHJhY2sgPT4gdHJhY2sgaW5zdGFuY2VvZiBMb2NhbFRyYWNrUHVibGljYXRpb24pO1xuICAgIH0pO1xuICB9XG4gIHJlcHVibGlzaEFsbFRyYWNrcyhvcHRpb25zKSB7XG4gICAgbGV0IHJlc3RhcnRUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGxvY2FsUHVicyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHB1Yi5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWIub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbFB1YnMucHVzaChwdWIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxvY2FsUHVicy5tYXAocHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICAgIHlpZWxkIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgaWYgKHJlc3RhcnRUcmFja3MgJiYgIXRyYWNrLmlzTXV0ZWQgJiYgKHRyYWNrIGluc3RhbmNlb2YgTG9jYWxBdWRpb1RyYWNrIHx8IHRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSAmJiAhdHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICAvLyBnZW5lcmFsbHkgd2UgbmVlZCB0byByZXN0YXJ0IHRoZSB0cmFjayBiZWZvcmUgcHVibGlzaGluZywgb2Z0ZW4gYSBmdWxsIHJlY29ubmVjdFxuICAgICAgICAgIC8vIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbXB1dGVyIGhhZCBnb25lIHRvIHNsZWVwLlxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCB7XG4gICAgICAgICAgICB0cmFjazogcHViLnRyYWNrU2lkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zKTtcbiAgICAgIH0pKSk7XG4gICAgfSk7XG4gIH1cbiAgcHVibGlzaERhdGEoZGF0YSwga2luZCkge1xuICAgIGxldCBwdWJsaXNoT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucykgPyBwdWJsaXNoT3B0aW9ucyA6IHB1Ymxpc2hPcHRpb25zID09PSBudWxsIHx8IHB1Ymxpc2hPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaXNoT3B0aW9ucy5kZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uU2lkcyA9IFtdO1xuICAgICAgY29uc3QgdG9waWMgPSAhQXJyYXkuaXNBcnJheShwdWJsaXNoT3B0aW9ucykgPyBwdWJsaXNoT3B0aW9ucy50b3BpYyA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uLmZvckVhY2godmFsID0+IHtcbiAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVtb3RlUGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uU2lkcy5wdXNoKHZhbC5zaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvblNpZHMucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3VzZXInLFxuICAgICAgICAgIHZhbHVlOiBuZXcgVXNlclBhY2tldCh7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogdGhpcy5zaWQsXG4gICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgZGVzdGluYXRpb25TaWRzOiBkZXN0aW5hdGlvblNpZHMsXG4gICAgICAgICAgICB0b3BpY1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBraW5kKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbCB3aG8gY2FuIHN1YnNjcmliZSB0byBMb2NhbFBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIHBhcnRpY2lwYW50cyBjYW4gc3Vic2NyaWJlLiBUaGlzIGFsbG93cyBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAqIHdobyBpcyBhYmxlIHRvIHN1YnNjcmliZSBhdCBhIHBhcnRpY2lwYW50IGFuZCB0cmFjayBsZXZlbC5cbiAgICpcbiAgICogTm90ZTogaWYgYWNjZXNzIGlzIGdpdmVuIGF0IGEgdHJhY2stbGV2ZWwgKGkuZS4gYm90aCBbYWxsUGFydGljaXBhbnRzQWxsb3dlZF0gYW5kXG4gICAqIFtQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5hbGxUcmFja3NBbGxvd2VkXSBhcmUgZmFsc2UpLCBhbnkgbmV3ZXIgcHVibGlzaGVkIHRyYWNrc1xuICAgKiB3aWxsIG5vdCBncmFudCBwZXJtaXNzaW9ucyB0byBhbnkgcGFydGljaXBhbnRzIGFuZCB3aWxsIHJlcXVpcmUgYSBzdWJzZXF1ZW50XG4gICAqIHBlcm1pc3Npb25zIHVwZGF0ZSB0byBhbGxvdyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIEFsbG93cyBhbGwgcGFydGljaXBhbnRzIHRvIHN1YnNjcmliZSBhbGwgdHJhY2tzLlxuICAgKiAgVGFrZXMgcHJlY2VkZW5jZSBvdmVyIFtbcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXV0gaWYgc2V0IHRvIHRydWUuXG4gICAqICBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHRydWUuXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgRnVsbCBsaXN0IG9mIGluZGl2aWR1YWwgcGVybWlzc2lvbnMgcGVyXG4gICAqICBwYXJ0aWNpcGFudC90cmFjay4gQW55IG9taXR0ZWQgcGFydGljaXBhbnRzIHdpbGwgbm90IHJlY2VpdmUgYW55IHBlcm1pc3Npb25zLlxuICAgKi9cbiAgc2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkKSB7XG4gICAgbGV0IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM7XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkO1xuICAgIGlmICghdGhpcy5lbmdpbmUuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoaW5mby5zaWQgIT09IHRoaXMuc2lkKSB7XG4gICAgICAvLyBkcm9wIHVwZGF0ZXMgdGhhdCBzcGVjaWZ5IGEgd3Jvbmcgc2lkLlxuICAgICAgLy8gdGhlIHNpZCBmb3IgbG9jYWwgcGFydGljaXBhbnQgaXMgb25seSBleHBsaWNpdGx5IHNldCBvbiBqb2luIGFuZCBmdWxsIHJlY29ubmVjdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxuICAgIC8vIHRoZSBzZXJ2ZXIncyBjb3B5XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja3MuZ2V0KHRpLnNpZCk7XG4gICAgICBpZiAocHViKSB7XG4gICAgICAgIGNvbnN0IG11dGVkT25TZXJ2ZXIgPSBwdWIuaXNNdXRlZCB8fCAoKF9iID0gKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UpO1xuICAgICAgICBpZiAobXV0ZWRPblNlcnZlciAhPT0gdGkubXV0ZWQpIHtcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCB7XG4gICAgICAgICAgICBzaWQ6IHRpLnNpZCxcbiAgICAgICAgICAgIG11dGVkOiBtdXRlZE9uU2VydmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRNdXRlVHJhY2sodGkuc2lkLCBtdXRlZE9uU2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spIHtcbiAgICBsZXQgcHVibGljYXRpb247XG4gICAgdGhpcy50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxvb2tzIG92ZXJseSBjb21wbGljYXRlZCBkdWUgdG8gdGhpcyBvYmplY3QgdHJlZVxuICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBpZiAobG9jYWxUcmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCBsb2NhbFRyYWNrIGluc3RhbmNlb2YgTG9jYWxWaWRlb1RyYWNrKSB7XG4gICAgICAgICAgaWYgKGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbn1cblxudmFyIENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0YXRlKSB7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmNvbnN0IGNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kgPSAyICogMTAwMDtcbi8qKiBAZGVwcmVjYXRlZCBSb29tU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBbW0Nvbm5lY3Rpb25TdGF0ZV1dICovXG5jb25zdCBSb29tU3RhdGUgPSBDb25uZWN0aW9uU3RhdGU7XG4vKipcbiAqIEluIExpdmVLaXQsIGEgcm9vbSBpcyB0aGUgbG9naWNhbCBncm91cGluZyBmb3IgYSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAqIFBhcnRpY2lwYW50cyBpbiBhIHJvb20gY2FuIHB1Ymxpc2ggdHJhY2tzLCBhbmQgc3Vic2NyaWJlIHRvIG90aGVycycgdHJhY2tzLlxuICpcbiAqIGEgUm9vbSBmaXJlcyBbW1Jvb21FdmVudCB8IFJvb21FdmVudHNdXS5cbiAqXG4gKiBAbm9Jbmhlcml0RG9jXG4gKi9cbmNsYXNzIFJvb20gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJvb20sIHRoZSBwcmltYXJ5IGNvbnN0cnVjdCBmb3IgYSBMaXZlS2l0IHNlc3Npb24uXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfYTtcbiAgICBzdXBlcigpO1xuICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhY3RpdmVseSBzcGVha2luZy4gd2hlbiB0aGlzIGNoYW5nZXNcbiAgICAgKiBhIFtbUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZF1dIGV2ZW50IGlzIGZpcmVkXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3QgPSAodXJsLCB0b2tlbiwgb3B0cykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9iO1xuICAgICAgLy8gSW4gY2FzZSBhIGRpc2Nvbm5lY3QgY2FsbGVkIGhhcHBlbmVkIHJpZ2h0IGJlZm9yZSB0aGUgY29ubmVjdCBjYWxsLCBtYWtlIHN1cmUgdGhlIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVkIGZpcnN0IGJ5IGF3YWl0aW5nIGl0cyBsb2NrXG4gICAgICBjb25zdCB1bmxvY2tEaXNjb25uZWN0ID0geWllbGQgdGhpcy5kaXNjb25uZWN0TG9jay5sb2NrKCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAvLyB3aGVuIHRoZSBzdGF0ZSBpcyByZWNvbm5lY3Rpbmcgb3IgY29ubmVjdGVkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHlcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSBcIi5jb25jYXQodGhpcy5uYW1lKSk7XG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29ubmVjdEZ1dHVyZSkge1xuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XG4gICAgICBpZiAoKChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRTZXJ2ZXJVcmwoKS50b1N0cmluZygpKSAhPT0gdXJsKSB7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSkge1xuICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih1cmwsIHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCBmZXRjaCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgcmVzcG9uc2VcbiAgICAgICAgLy8gaWYgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxzLCB0aGlzIHdpbGwgc3BlZWQgdXAgcGlja2luZyByZWdpb25hbCB1cmxcbiAgICAgICAgLy8gb24gc3Vic2VxdWVudCBydW5zXG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZmV0Y2hSZWdpb25TZXR0aW5ncygpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5ncycsIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdEZuID0gKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYztcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBsaWNpdCBjcmVhdGlvbiBhcyBsb2NhbCB2YXIgbmVlZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIgd2hlbiBwYXNzaW5nIGl0IHRvIGBhdHRlbXB0Q29ubmVjdGlvbmAgZnVydGhlciBkb3duXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QgPT09IG51bGwgfHwgdW5sb2NrRGlzY29ubmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24ocmVnaW9uVXJsICE9PSBudWxsICYmIHJlZ2lvblVybCAhPT0gdm9pZCAwID8gcmVnaW9uVXJsIDogdXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciAmJiBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uICE9PSAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8gJiYgZS5yZWFzb24gIT09IDAgLyogQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgKi8pIHtcbiAgICAgICAgICAgIGxldCBuZXh0VXJsID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5leHRVcmwgPSB5aWVsZCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKChfYyA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2lnbmFsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3IucmVhc29uID09PSAzIC8qIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgKi8pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRVcmwpIHtcbiAgICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogXCIuY29uY2F0KGUubWVzc2FnZSwgXCIuIFJldHJ5aW5nIHdpdGggYW5vdGhlciByZWdpb246IFwiKS5jb25jYXQobmV4dFVybCkpO1xuICAgICAgICAgICAgICB5aWVsZCBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCBuZXh0VXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCk7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVnaW9uVXJsID0gdGhpcy5yZWdpb25Vcmw7XG4gICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdFNpZ25hbCA9ICh1cmwsIHRva2VuLCBlbmdpbmUsIGNvbm5lY3RPcHRpb25zLCByb29tT3B0aW9ucywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCBlbmdpbmUuam9pbih1cmwsIHRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IGNvbm5lY3RPcHRpb25zLmF1dG9TdWJzY3JpYmUsXG4gICAgICAgIHB1Ymxpc2hPbmx5OiBjb25uZWN0T3B0aW9ucy5wdWJsaXNoT25seSxcbiAgICAgICAgYWRhcHRpdmVTdHJlYW06IHR5cGVvZiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9PT0gJ29iamVjdCcgPyB0cnVlIDogcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0sXG4gICAgICAgIG1heFJldHJpZXM6IGNvbm5lY3RPcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgIGUyZWVFbmFibGVkOiAhIXRoaXMuZTJlZU1hbmFnZXIsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IGNvbm5lY3RPcHRpb25zLndlYnNvY2tldFRpbWVvdXRcbiAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgbGV0IHNlcnZlckluZm8gPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbztcbiAgICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgICBzZXJ2ZXJJbmZvID0ge1xuICAgICAgICAgIHZlcnNpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uLFxuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcImNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciBcIi5jb25jYXQoT2JqZWN0LmVudHJpZXMoc2VydmVySW5mbykubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgfSkuam9pbignLCAnKSkpO1xuICAgICAgaWYgKCFqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRTZXJ2ZXIoJ3Vua25vd24gc2VydmVyIHZlcnNpb24nKTtcbiAgICAgIH1cbiAgICAgIGlmIChqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbiA9PT0gJzAuMTUuMScgJiYgdGhpcy5vcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nKTtcbiAgICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICAgIHJvb21PcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0pO1xuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgcGkgPSBqb2luUmVzcG9uc2UucGFydGljaXBhbnQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkID0gcGkuc2lkO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG4gICAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3BpLCAuLi5qb2luUmVzcG9uc2Uub3RoZXJQYXJ0aWNpcGFudHNdKTtcbiAgICAgIGlmIChqb2luUmVzcG9uc2Uucm9vbSkge1xuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlICYmIHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRTaWZUcmFpbGVyKGpvaW5SZXNwb25zZS5zaWZUcmFpbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24gPSAodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2QsIF9lO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2QgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaXNDbG91ZCgpKSB7XG4gICAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCk7XG4gICAgICB0aGlzLmNvbm5PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzKSwgb3B0cyk7XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWcpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gdGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3RTaWduYWwodXJsLCB0b2tlbiwgdGhpcy5lbmdpbmUsIHRoaXMuY29ubk9wdGlvbnMsIHRoaXMub3B0aW9ucywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xuICAgICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIpO1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gXCJcIi5jb25jYXQocmVzdWx0aW5nRXJyb3IubWVzc2FnZSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5yZWFzb24gPSBlcnIucmVhc29uO1xuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcImVycm9yIHRyeWluZyB0byBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyBhbHNvIGhvb2sgdW5sb2FkIGV2ZW50XG4gICAgICBpZiAoaXNXZWIoKSAmJiB0aGlzLm9wdGlvbnMuZGlzY29ubmVjdE9uUGFnZUxlYXZlKSB7XG4gICAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgKF9lID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogZGlzY29ubmVjdHMgdGhlIHJvb20sIGVtaXRzIFtbUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZF1dXG4gICAgICovXG4gICAgdGhpcy5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IHN0b3BUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RMb2NrLmxvY2soKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIHtcbiAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgfHwgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgLy8gdHJ5IGFib3J0aW5nIHBlbmRpbmcgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgICAgICAgKF9mID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5hYm9ydCgpO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgYWJvcnQgY29udHJvbGxlciBkaWRuJ3QgbWFuYWdlIHRvIGNhbmNlbCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LCByZWplY3QgdGhlIGNvbm5lY3QgcHJvbWlzZSBleHBsaWNpdGx5XG4gICAgICAgICAgICAoX2ggPSAoX2cgPSB0aGlzLmNvbm5lY3RGdXR1cmUpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5yZWplY3QpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5jYWxsKF9nLCBuZXcgQ29ubmVjdGlvbkVycm9yKCdDbGllbnQgaW5pdGlhdGVkIGRpc2Nvbm5lY3QnKSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNlbmQgbGVhdmVcbiAgICAgICAgICBpZiAoISgoX2ogPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2xvc2UgZW5naW5lIChhbHNvIGNsb3NlcyBjbGllbnQpXG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcbiAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5vblBhZ2VMZWF2ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IHBvbGljaWVzIHJlZ2FyZGluZyBhdWRpbyBwbGF5YmFjay4gTW9zdCByZXF1aXJpbmdcbiAgICAgKiBzb21lIGZvcm0gb2YgdXNlciBpbnRlcmFjdGlvbiAoY2xpY2svdGFwL2V0YykuXG4gICAgICogSW4gdGhvc2UgY2FzZXMsIGF1ZGlvIHdpbGwgYmUgc2lsZW50IHVudGlsIGEgY2xpY2svdGFwIHRyaWdnZXJpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICAgKiAtIGBzdGFydEF1ZGlvYFxuICAgICAqIC0gYGdldFVzZXJNZWRpYWBcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0QXVkaW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgIGlmIChicm93c2VyICYmIGJyb3dzZXIub3MgPT09ICdpT1MnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpT1MgYmxvY2tzIGF1ZGlvIGVsZW1lbnQgcGxheWJhY2sgaWZcbiAgICAgICAgICogLSB1c2VyIGlzIG5vdCBwdWJsaXNoaW5nIGF1ZGlvIHRoZW1zZWx2ZXMgYW5kXG4gICAgICAgICAqIC0gbm8gb3RoZXIgYXVkaW8gc291cmNlIGlzIHBsYXlpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogYXMgYSB3b3JrYXJvdW5kLCB3ZSBjcmVhdGUgYW4gYXVkaW8gZWxlbWVudCB3aXRoIGFuIGVtcHR5IHRyYWNrLCBzbyB0aGF0XG4gICAgICAgICAqIHNpbGVudCBhdWRpbyBpcyBhbHdheXMgcGxheWluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXVkaW9JZCA9ICdsaXZla2l0LWR1bW15LWF1ZGlvLWVsJztcbiAgICAgICAgbGV0IGR1bW15QXVkaW9FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGF1ZGlvSWQpO1xuICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICAgIGR1bW15QXVkaW9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmlkID0gYXVkaW9JZDtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0aGUgc3JjT2JqZWN0IHRvIG51bGwgb24gcGFnZSBoaWRlIGluIG9yZGVyIHRvIHByZXZlbnQgbG9jayBzY3JlZW4gY29udHJvbHMgdG8gc2hvdyB1cCBmb3IgaXRcbiAgICAgICAgICAgIGR1bW15QXVkaW9FbC5zcmNPYmplY3QgPSBkb2N1bWVudC5oaWRkZW4gPyBudWxsIDogc3RyZWFtO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGR1bW15QXVkaW9FbCk7XG4gICAgICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgICAgIGR1bW15QXVkaW9FbCA9PT0gbnVsbCB8fCBkdW1teUF1ZGlvRWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGR1bW15QXVkaW9FbC5yZW1vdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGR1bW15QXVkaW9FbCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLmF1ZGlvVHJhY2tzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgaWYgKHQudHJhY2spIHtcbiAgICAgICAgICAgIHQudHJhY2suYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW3RoaXMuYWNxdWlyZUF1ZGlvQ29udGV4dCgpLCAuLi5lbGVtZW50cy5tYXAoZSA9PiB7XG4gICAgICAgICAgZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlLnBsYXkoKTtcbiAgICAgICAgfSldKTtcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZChlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGFydFZpZGVvID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgICBwLnZpZGVvVHJhY2tzLmZvckVhY2godHIgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0ci50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoZWwgPT4gZWwucGxheSgpKSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIud2FybignUmVzdW1pbmcgdmlkZW8gcGxheWJhY2sgZmFpbGVkLCBtYWtlIHN1cmUgeW91IGNhbGwgYHN0YXJ0VmlkZW9gIGRpcmVjdGx5IGluIGEgdXNlciBnZXN0dXJlIGhhbmRsZXInKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVSZXN0YXJ0aW5nID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIC8vIGFsc28gdW53aW5kIGV4aXN0aW5nIHBhcnRpY2lwYW50cyAmIGV4aXN0aW5nIHN1YnNjcmlwdGlvbnNcbiAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHAuc2lkLCBwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBqb2luUmVzcG9uc2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXJcIiwge1xuICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWNoZWRQYXJ0aWNpcGFudFNpZHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcbiAgICAgICAgY29uc3QgbG9jYWxQdWJzID0gW107XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwobG9jYWxQdWJzLm1hcChwdWIgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayh0cmFjaywgZmFsc2UpO1xuICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgaWYgKCh0cmFjayBpbnN0YW5jZW9mIExvY2FsQXVkaW9UcmFjayB8fCB0cmFjayBpbnN0YW5jZW9mIExvY2FsVmlkZW9UcmFjaykgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJiAhdHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXN0YXJ0IHRoZSB0cmFjayBiZWZvcmUgcHVibGlzaGluZywgb2Z0ZW4gYSBmdWxsIHJlY29ubmVjdFxuICAgICAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIHtcbiAgICAgICAgICAgICAgICB0cmFjazogcHViLnRyYWNrU2lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ3B1Ymxpc2hpbmcgbmV3IHRyYWNrJywge1xuICAgICAgICAgICAgICB0cmFjazogcHViLnRyYWNrU2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwiZnVsbHkgcmVjb25uZWN0ZWQgdG8gc2VydmVyXCIsIHtcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChfaykge1xuICAgICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICAvLyBlbWl0IHBhcnRpY2lwYW50IGNvbm5lY3RlZCBldmVudHMgYWZ0ZXIgY29ubmVjdGlvbiBoYXMgYmVlbiByZS1lc3RhYmxpc2hlZFxuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzID0gcGFydGljaXBhbnRJbmZvcyA9PiB7XG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byBwYXJ0aWNpcGFudCBzdGF0ZSwgYW5kIHNlbmQgZXZlbnRzXG4gICAgICBwYXJ0aWNpcGFudEluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGlkZW50aXR5IDw9PiBzaWQgbWFwcGluZ1xuICAgICAgICBjb25zdCBzaWQgPSB0aGlzLmlkZW50aXR5VG9TaWQuZ2V0KGluZm8uaWRlbnRpdHkpO1xuICAgICAgICBpZiAoc2lkICYmIHNpZCAhPT0gaW5mby5zaWQpIHtcbiAgICAgICAgICAvLyBzaWQgaGFkIGNoYW5nZWQsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIHBhcnRpY2lwYW50XG4gICAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChzaWQsIHRoaXMucGFydGljaXBhbnRzLmdldChzaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaW5mby5zaWQpO1xuICAgICAgICBjb25zdCBpc05ld1BhcnRpY2lwYW50ID0gIXJlbW90ZVBhcnRpY2lwYW50O1xuICAgICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgICAgaWYgKGluZm8uc3RhdGUgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGluZm8uc2lkLCByZW1vdGVQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMuZ2V0T3JDcmVhdGVQYXJ0aWNpcGFudChpbmZvLnNpZCwgaW5mbyk7XG4gICAgICAgICAgaWYgKCFpc05ld1BhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAvLyBqdXN0IHVwZGF0ZSwgbm8gZXZlbnRzXG4gICAgICAgICAgICByZW1vdGVQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xuICAgICAgICBzZWVuU2lkc1tzcGVha2VyLnNpZF0gPSB0cnVlO1xuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcnRpY2lwYW50cy5nZXQoc3BlYWtlci5zaWQpO1xuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICAgICAgcC5zZXRJc1NwZWFraW5nKHRydWUpO1xuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICAgIH07XG4gICAgLy8gcHJvY2VzcyBsaXN0IG9mIGNoYW5nZWQgc3BlYWtlcnNcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgbGFzdFNwZWFrZXJzLnNldChwLnNpZCwgcCk7XG4gICAgICB9KTtcbiAgICAgIHNwZWFrZXJVcGRhdGVzLmZvckVhY2goc3BlYWtlciA9PiB7XG4gICAgICAgIGxldCBwID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNwZWFrZXIuc2lkKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgcCA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgcC5zZXRJc1NwZWFraW5nKHNwZWFrZXIuYWN0aXZlKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuYWN0aXZlKSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLnNldChzcGVha2VyLnNpZCwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLmRlbGV0ZShzcGVha2VyLnNpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBBcnJheS5mcm9tKGxhc3RTcGVha2Vycy52YWx1ZXMoKSk7XG4gICAgICBhY3RpdmVTcGVha2Vycy5zb3J0KChhLCBiKSA9PiBiLmF1ZGlvTGV2ZWwgLSBhLmF1ZGlvTGV2ZWwpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlID0gc3RyZWFtU3RhdGVVcGRhdGUgPT4ge1xuICAgICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goc3RyZWFtU3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbihzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gVHJhY2suc3RyZWFtU3RhdGVGcm9tUHJvdG8oc3RyZWFtU3RhdGUuc3RhdGUpO1xuICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldCh1cGRhdGUucGFydGljaXBhbnRTaWQpO1xuICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0QWxsb3dlZCh1cGRhdGUuYWxsb3dlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAudHJhY2tzLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHViLnNldFN1YnNjcmlwdGlvbkVycm9yKHVwZGF0ZS5lcnIpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEYXRhUGFja2V0ID0gKHVzZXJQYWNrZXQsIGtpbmQpID0+IHtcbiAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmdldCh1c2VyUGFja2V0LnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIHBhcnRpY2lwYW50LCBraW5kLCB1c2VyUGFja2V0LnRvcGljKTtcbiAgICAgIC8vIGFsc28gZW1pdCBvbiB0aGUgcGFydGljaXBhbnRcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQgPSBlID0+IHtcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IHBsYXliYWNrIGF1ZGlvJywgZSk7XG4gICAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb20gPT4ge1xuICAgICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcbiAgICAgIGlmIChvbGRSb29tICYmIG9sZFJvb20ubWV0YWRhdGEgIT09IHJvb20ubWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKG9sZFJvb20gPT09IG51bGwgfHwgb2xkUm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkUm9vbS5hY3RpdmVSZWNvcmRpbmcpICE9PSByb29tLmFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KGluZm8ucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja011dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2w7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICAgIGlmIChwdWIudHJhY2sgaW5zdGFuY2VvZiBMb2NhbEF1ZGlvVHJhY2spIHtcbiAgICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIHB1Yi50cmFjay5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQsIHB1Yik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgKF9sID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuZ2V0RGV2aWNlSWQoKTtcbiAgICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQocHViLnNvdXJjZSk7XG4gICAgICBpZiAoZGV2aWNlS2luZCAmJiBkZXZpY2VJZCAmJiBkZXZpY2VJZCAhPT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZCkpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSBxdWFsaXR5ID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yID0gZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgdGhpcy5wYXJ0aWNpcGFudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYWNoZWRQYXJ0aWNpcGFudFNpZHMgPSBbXTtcbiAgICB0aGlzLmlkZW50aXR5VG9TaWQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tT3B0aW9uRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1ZGlvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyk7XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQgPSBuZXcgTG9jYWxQYXJ0aWNpcGFudCgnJywgJycsIHRoaXMuZW5naW5lLCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCd2aWRlb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xuICAgIH1cbiAgICBpZiAoKF9hID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkKSkuY2F0Y2goZSA9PiBsaXZla2l0TG9nZ2VyLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgIT09ICcnKSB7XG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdlMmVlIG5vdCBjb25maWd1cmVkLCBwbGVhc2Ugc2V0IGUyZWUgc2V0dGluZ3Mgd2l0aGluIHRoZSByb29tIG9wdGlvbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzZXR1cEUyRUUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCAoZW5hYmxlZCwgcGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50IGluc3RhbmNlb2YgTG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IgPT4gdGhpcy5lbWl0KFJvb21FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yKSk7XG4gICAgICAoX2EgPSB0aGlzLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0dXAodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICB9XG4gIC8qKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQgKi9cbiAgZ2V0IHNpZCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICAvKiogdXNlciBhc3NpZ25lZCBuYW1lLCBkZXJpdmVkIGZyb20gSldUIHRva2VuICovXG4gIGdldCBuYW1lKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICAvKiogcm9vbSBtZXRhZGF0YSAqL1xuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0YWRhdGE7XG4gIH1cbiAgZ2V0IG51bVBhcnRpY2lwYW50cygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIGdldCBudW1QdWJsaXNoZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1QdWJsaXNoZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIG1heWJlQ3JlYXRlRW5naW5lKCkge1xuICAgIGlmICh0aGlzLmVuZ2luZSAmJiAhdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgUlRDRW5naW5lKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB0aGlzLmhhbmRsZVJvb21VcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQpLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSkub24oRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpLm9uKEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZFBhcnRpY2lwYW50U2lkcyA9IEFycmF5LmZyb20odGhpcy5wYXJ0aWNpcGFudHMua2V5cygpKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIC8vIG9uY2UgcmVjb25uZWN0ZWQsIGZpZ3VyZSBvdXQgaWYgYW55IHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgZHVyaW5nIHJlY29ubmVjdCBhbmQgZW1pdCBldmVudHMgZm9yIGl0XG4gICAgICBjb25zdCBkaWZmUGFydGljaXBhbnRzID0gQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmlsdGVyKHAgPT4gIXRoaXMuY2FjaGVkUGFydGljaXBhbnRTaWRzLmluY2x1ZGVzKHAuc2lkKSk7XG4gICAgICBkaWZmUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhcnRpY2lwYW50U2lkcyA9IFtdO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMuc2VuZFN5bmNTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJlc3RhcnRpbmcsIHRoaXMuaGFuZGxlUmVzdGFydGluZykub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZCkub24oRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCAoc3RhdHVzLCBraW5kKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBnZXRMb2NhbERldmljZXMgYWJzdHJhY3RzIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcy5cbiAgICogSW4gcGFydGljdWxhciwgaXQgaGFuZGxlcyBDaHJvbWUncyB1bmlxdWUgYmVoYXZpb3Igb2YgY3JlYXRpbmcgYGRlZmF1bHRgXG4gICAqIGRldmljZXMuIFdoZW4gZW5jb3VudGVyZWQsIGl0J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBvZiBkZXZpY2VzLlxuICAgKiBUaGUgYWN0dWFsIGRlZmF1bHQgZGV2aWNlIHdpbGwgYmUgcGxhY2VkIGF0IHRvcC5cbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSBsb2NhbCBkZXZpY2VzXG4gICAqL1xuICBzdGF0aWMgZ2V0TG9jYWxEZXZpY2VzKGtpbmQpIHtcbiAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyhraW5kLCByZXF1ZXN0UGVybWlzc2lvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcbiAgICogLSBwZXJmb3JtIEROUyByZXNvbHV0aW9uIGFuZCBwcmUtd2FybSB0aGUgRE5TIGNhY2hlXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xuICAgKlxuICAgKiBXaXRoIExpdmVLaXQgQ2xvdWQsIGl0IHdpbGwgYWxzbyBkZXRlcm1pbmUgdGhlIGJlc3QgZWRnZSBkYXRhIGNlbnRlciBmb3JcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIHByZXBhcmVDb25uZWN0aW9uKHVybCwgdG9rZW4pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkgJiYgdG9rZW4pIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5vdCByZXBsYWNlIHRoZSByZWdpb25VcmwgaWYgYW4gYXR0ZW1wdCBoYWQgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgICAgLy8gdG8gYXZvaWQgb3ZlcnJpZGluZyByZWdpb25VcmwgYWZ0ZXIgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGhhZCBzdGFydGVkXG4gICAgICAgICAgaWYgKHJlZ2lvblVybCAmJiB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHJlZ2lvblVybDtcbiAgICAgICAgICAgIHlpZWxkIGZldGNoKHRvSHR0cFVybChyZWdpb25VcmwpLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHVybCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgcHJlcGFyZSBjb25uZWN0aW9uJywge1xuICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxuICAgKiBAcGFyYW0gaWRlbnRpdHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgIH1cbiAgICBjb25zdCBzaWQgPSB0aGlzLmlkZW50aXR5VG9TaWQuZ2V0KGlkZW50aXR5KTtcbiAgICBpZiAoc2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHNpZCk7XG4gICAgfVxuICB9XG4gIGNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgZm9yIHRlc3RpbmdcbiAgICovXG4gIHNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8sIGFyZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgcG9zdEFjdGlvbiA9ICgpID0+IHt9O1xuICAgICAgbGV0IHJlcTtcbiAgICAgIHN3aXRjaCAoc2NlbmFyaW8pIHtcbiAgICAgICAgY2FzZSAnc2lnbmFsLXJlY29ubmVjdCc6XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3BlYWtlcic6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3NwZWFrZXJVcGRhdGUnLFxuICAgICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdub2RlLWZhaWx1cmUnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdub2RlRmFpbHVyZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3NlcnZlckxlYXZlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlncmF0aW9uJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnbWlncmF0aW9uJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVzdW1lLXJlY29ubmVjdCc6XG4gICAgICAgICAgdGhpcy5lbmdpbmUuZmFpbE5leHQoKTtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVsbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBmdWxsLXJlY29ubmVjdCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3JjZS10Y3AnOlxuICAgICAgICBjYXNlICdmb3JjZS10bHMnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzd2l0Y2hDYW5kaWRhdGVQcm90b2NvbCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvbkxlYXZlID0gdGhpcy5lbmdpbmUuY2xpZW50Lm9uTGVhdmU7XG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgICBvbkxlYXZlKG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAgICAgICAgIGNhblJlY29ubmVjdDogdHJ1ZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZXItYmFuZHdpZHRoJzpcbiAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGFyZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3Vic2NyaWJlci1iYW5kd2lkdGggcmVxdWlyZXMgYSBudW1iZXIgYXMgYXJndW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3N1YnNjcmliZXJCYW5kd2lkdGgnLFxuICAgICAgICAgICAgICB2YWx1ZTogQmlnSW50KGFyZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XG4gICAgICAgIHBvc3RBY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja0F1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvRW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgYXVkaW8gb3V0cHV0IGRldmljZSB1c2VkIGluIHRoaXMgcm9vbS5cbiAgICogQHJldHVybiB0aGUgcHJldmlvdXNseSBzdWNjZXNzZnVsbHkgc2V0IGF1ZGlvIG91dHB1dCBkZXZpY2UgSUQgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBkZWZhdWx0IGRldmljZSBpcyB1c2VkLlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGdldEFjdGl2ZURldmljZSgnYXVkaW9vdXRwdXQnKWAgaW5zdGVhZFxuICAgKi9cbiAgZ2V0QWN0aXZlQXVkaW9PdXRwdXREZXZpY2UoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICB9XG4gIGdldEFjdGl2ZURldmljZShraW5kKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZXMgdXNlZCBpbiB0aGlzIHJvb20gdG8gdGhlIGdpdmVuIGRldmljZS5cbiAgICpcbiAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICAgKlxuICAgKiBAcGFyYW0ga2luZCB1c2UgYHZpZGVvaW5wdXRgIGZvciBjYW1lcmEgdHJhY2ssXG4gICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXG4gICAqICBgYXVkaW9vdXRwdXRgIHRvIHNldCBzcGVha2VyIGZvciBhbGwgaW5jb21pbmcgYXVkaW8gdHJhY2tzXG4gICAqIEBwYXJhbSBkZXZpY2VJZFxuICAgKi9cbiAgc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmQsIGRldmljZUlkKSB7XG4gICAgbGV0IGV4YWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGRldmljZUhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGRldmljZUNvbnN0cmFpbnQgPSBleGFjdCA/IHtcbiAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICB9IDogZGV2aWNlSWQ7XG4gICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgZGV2aWNlSGFzQ2hhbmdlZCA9IHByZXZEZXZpY2VJZCAhPT0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja3MudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdC5hdWRpb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgIGRldmljZUhhc0NoYW5nZWQgPSBwcmV2RGV2aWNlSWQgIT09IGRldmljZUNvbnN0cmFpbnQ7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20odGhpcy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tzLnZhbHVlcygpKS5maWx0ZXIodHJhY2sgPT4gdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdC52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZCgpICYmICF0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggfHwgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4ICYmIHRoaXMuYXVkaW9Db250ZXh0ICYmICEoJ3NldFNpbmtJZCcgaW4gdGhpcy5hdWRpb0NvbnRleHQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIGF1ZGlvIG91dHB1dCwgc2V0U2lua0lkIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSAoX2MgPSB0aGlzLm9wdGlvbnMpLmF1ZGlvT3V0cHV0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfYy5hdWRpb091dHB1dCA9IHt9O1xuICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgICBkZXZpY2VIYXNDaGFuZ2VkID0gcHJldkRldmljZUlkICE9PSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2V0U2lua0lkIGlzIG5vdCB5ZXQgaW4gdGhlIHR5cGVzY3JpcHQgdHlwZSBvZiBBdWRpb0NvbnRleHRcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0U2lua0lkKGRldmljZUlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbSh0aGlzLnBhcnRpY2lwYW50cy52YWx1ZXMoKSkubWFwKHAgPT4gcC5zZXRBdWRpb091dHB1dCh7XG4gICAgICAgICAgICAgIGRldmljZUlkXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGV2aWNlSGFzQ2hhbmdlZCAmJiBzdWNjZXNzKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9KTtcbiAgfVxuICBzZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKSB7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcikub24oUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkLCB0aGlzLnN0YXJ0QXVkaW8pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcbiAgfVxuICByZWNyZWF0ZUVuZ2luZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICB0aGlzLmVuZ2luZSA9IHVuZGVmaW5lZDtcbiAgICAvLyBjbGVhciBvdXQgZXhpc3RpbmcgcmVtb3RlIHBhcnRpY2lwYW50cywgc2luY2UgdGhleSBtYXkgaGF2ZSBhdHRhY2hlZFxuICAgIC8vIHRoZSBvbGQgZW5naW5lXG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuY2xlYXIoKTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gIH1cbiAgb25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpIHtcbiAgICAvLyBkb24ndCBmaXJlIG9uU3Vic2NyaWJlZCB3aGVuIGNvbm5lY3RpbmdcbiAgICAvLyBXZWJSVEMgZmlyZXMgb25UcmFjayBhcyBzb29uIGFzIHNldFJlbW90ZURlc2NyaXB0aW9uIGlzIGNhbGxlZCBvbiB0aGUgb2ZmZXJcbiAgICAvLyBhdCB0aGF0IHRpbWUsIElDRSBjb25uZWN0aXZpdHkgaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHNvIHRoZSB0cmFjayBpcyBub3RcbiAgICAvLyB0ZWNobmljYWxseSBzdWJzY3JpYmVkLlxuICAgIC8vIFdlJ2xsIGRlZmVyIHRoZXNlIGV2ZW50cyB1bnRpbCB3aGVuIHRoZSByb29tIGlzIGNvbm5lY3RlZCBvciBldmVudHVhbGx5IGRpc2Nvbm5lY3RlZC5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgfHwgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgY29uc3QgcmVjb25uZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhZnRlciBSb29tIGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IHVucGFja1N0cmVhbUlkKHN0cmVhbS5pZCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRJZCA9IHBhcnRzWzBdO1xuICAgIGxldCBzdHJlYW1JZCA9IHBhcnRzWzFdO1xuICAgIGxldCB0cmFja0lkID0gbWVkaWFUcmFjay5pZDtcbiAgICAvLyBmaXJlZm94IHdpbGwgZ2V0IHN0cmVhbUlkIChwSUR8dHJhY2tJZCkgaW5zdGVhZCBvZiAocElEfHN0cmVhbUlkKSBhcyBpdCBkb2Vzbid0IHN1cHBvcnQgc3luYyB0cmFja3MgYnkgc3RyZWFtXG4gICAgLy8gYW5kIGdlbmVyYXRlcyBpdHMgb3duIHRyYWNrIGlkIGluc3RlYWQgb2YgaW5mZXIgZnJvbSBzZHAgdHJhY2sgaWQuXG4gICAgaWYgKHN0cmVhbUlkICYmIHN0cmVhbUlkLnN0YXJ0c1dpdGgoJ1RSJykpIHRyYWNrSWQgPSBzdHJlYW1JZDtcbiAgICBpZiAocGFydGljaXBhbnRJZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCd0cmllZCB0byBjcmVhdGUgUmVtb3RlUGFydGljaXBhbnQgZm9yIGxvY2FsIHBhcnRpY2lwYW50Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5wYXJ0aWNpcGFudHMuZ2V0KHBhcnRpY2lwYW50SWQpO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoXCJUcmllZCB0byBhZGQgYSB0cmFjayBmb3IgYSBwYXJ0aWNpcGFudCwgdGhhdCdzIG5vdCBwcmVzZW50LiBTaWQ6IFwiLmNvbmNhdChwYXJ0aWNpcGFudElkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCB0cmFja0lkLCBzdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcbiAgfVxuICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgIGxldCBzaG91bGRTdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgIHAudW5wdWJsaXNoVHJhY2socHViLnRyYWNrU2lkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1Yi50cmFjaywgc2hvdWxkU3RvcFRyYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFN0b3BUcmFja3MpIHtcbiAgICAgICAgICAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXRhY2goKTtcbiAgICAgICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vZmYoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkLCB0aGlzLnN0YXJ0QXVkaW8pLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja3MuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrcy5jbGVhcigpO1xuICAgICAgdGhpcy5wYXJ0aWNpcGFudHMuY2xlYXIoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIChfYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCB0aGlzLmhhbmRsZURldmljZUNoYW5nZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChzaWQsIHBhcnRpY2lwYW50KSB7XG4gICAgLy8gcmVtb3ZlIGFuZCBzZW5kIGV2ZW50XG4gICAgdGhpcy5wYXJ0aWNpcGFudHMuZGVsZXRlKHNpZCk7XG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlkZW50aXR5VG9TaWQuZGVsZXRlKHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICBwYXJ0aWNpcGFudC50cmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XG4gICAgICBwYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWJsaWNhdGlvbi50cmFja1NpZCwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCwgcGFydGljaXBhbnQpO1xuICB9XG4gIGFjcXVpcmVBdWRpb0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXggIT09ICdib29sZWFuJyAmJiB0aGlzLm9wdGlvbnMuZXhwV2ViQXVkaW9NaXguYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIGF1ZGlvIGNvbnRleHQgd2l0aCBjdXN0b20gYXVkaW8gY29udGV4dCBpZiBzdXBwbGllZCBieSB1c2VyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdGhpcy5vcHRpb25zLmV4cFdlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dDtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYXVkaW9Db250ZXh0IHx8IHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAvLyBieSB1c2luZyBhbiBBdWRpb0NvbnRleHQsIGl0IHJlZHVjZXMgbGFnIG9uIGF1ZGlvIGVsZW1lbnRzXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4MTE0MjkvaHRtbDUtYXVkaW8tdGFnLW9uLXNhZmFyaS1oYXMtYS1kZWxheS81NDExOTg1NCM1NDExOTg1NFxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IChfYSA9IGdldE5ld0F1ZGlvQ29udGV4dCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIC8vIGZvciBpT1MgYSBuZXdseSBjcmVhdGVkIEF1ZGlvQ29udGV4dCBpcyBhbHdheXMgaW4gYHN1c3BlbmRlZGAgc3RhdGUuXG4gICAgICAgIC8vIHdlIHRyeSBvdXIgYmVzdCB0byByZXN1bWUgdGhlIGNvbnRleHQgaGVyZSwgaWYgdGhhdCBkb2Vzbid0IHdvcmssIHdlIGp1c3QgY29udGludWUgd2l0aCByZWd1bGFyIHByb2Nlc3NpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIud2FybihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICBjb25zdCBuZXdDb250ZXh0SXNSdW5uaW5nID0gKChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpID09PSAncnVubmluZyc7XG4gICAgICBpZiAobmV3Q29udGV4dElzUnVubmluZyAhPT0gdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgbmV3Q29udGV4dElzUnVubmluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCBpZCwgJycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5leHBXZWJBdWRpb01peCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICB9XG4gICAgaWYgKChfYSA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb091dHB1dCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpLmNhdGNoKGUgPT4gbGl2ZWtpdExvZ2dlci53YXJuKFwiQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6IFwiLmNvbmNhdChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuICBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkLCBpbmZvKSB7XG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRzLmhhcyhpZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50cy5nZXQoaWQpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWQsIGluZm8pO1xuICAgIHRoaXMucGFydGljaXBhbnRzLnNldChpZCwgcGFydGljaXBhbnQpO1xuICAgIHRoaXMuaWRlbnRpdHlUb1NpZC5zZXQoaW5mby5pZGVudGl0eSwgaW5mby5zaWQpO1xuICAgIC8vIGlmIHdlIGhhdmUgdmFsaWQgaW5mbyBhbmQgdGhlIHBhcnRpY2lwYW50IHdhc24ndCBpbiB0aGUgbWFwIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGUgcGFydGljaXBhbnQgaXMgbmV3XG4gICAgLy8gZmlyaW5nIGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgYFBhcnRpY2lwYW50Q29ubmVjdGVkYCBmaXJlcyBiZWZvcmUgdGhlIGluaXRpYWwgdHJhY2sgZXZlbnRzXG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXG4gICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxuICAgIHBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHkgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgKHRyYWNrU2lkLCBlcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgdHJhY2tTaWQsIHBhcnRpY2lwYW50LCBlcnJvcik7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIGluZm8gYXQgdGhlIGVuZCBhZnRlciBjYWxsYmFja3MgaGF2ZSBiZWVuIHNldCB1cFxuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZSgpIHtcbiAgICBjb25zdCByZW1vdGVUcmFja3MgPSBBcnJheS5mcm9tKHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIGFjYy5wdXNoKC4uLnBhcnRpY2lwYW50LmdldFRyYWNrcygpKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tzKCk7IC8vIEZJWE1FIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSB0aGlzIHJldHVybiBMb2NhbFRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxuICAgIHRoaXMuZW5naW5lLnNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcyk7XG4gIH1cbiAgLyoqXG4gICAqIEFmdGVyIHJlc3VtaW5nLCB3ZSdsbCBuZWVkIHRvIG5vdGlmeSB0aGUgc2VydmVyIG9mIHRoZSBjdXJyZW50XG4gICAqIHN1YnNjcmlwdGlvbiBzZXR0aW5ncy5cbiAgICovXG4gIHVwZGF0ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IHB1YiBvZiBwLnZpZGVvVHJhY2tzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChwdWIuaXNTdWJzY3JpYmVkICYmIHB1YiBpbnN0YW5jZW9mIFJlbW90ZVRyYWNrUHVibGljYXRpb24pIHtcbiAgICAgICAgICBwdWIuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gZW5zdXJlIHdlIGRpZG4ndCB0ZWFyIGl0IGRvd25cbiAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcbiAgICAgIHRoaXMuZW5naW5lLmlzQ2xvc2VkIHx8XG4gICAgICAvLyB0cmFuc3BvcnRzIGZhaWxlZCB3aXRob3V0IG5vdGlmeWluZyBlbmdpbmVcbiAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSkge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzKys7XG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignZGV0ZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZSBtaXNtYXRjaCcsIHtcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgIH1cbiAgICB9LCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgLy8gdW5jaGFuZ2VkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVtaXRXaGVuQ29ubmVjdGVkKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gcG9wdWxhdGUgYSByb29tIHdpdGggc2ltdWxhdGVkIHBhcnRpY2lwYW50cy5cbiAgICogTm8gYWN0dWFsIGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIgd2lsbCBiZSBlc3RhYmxpc2hlZCwgYWxsIHN0YXRlIGlzXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHNpbXVsYXRlUGFydGljaXBhbnRzKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zLnB1Ymxpc2gpO1xuICAgICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNvdW50OiA5LFxuICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhc3BlY3RSYXRpb3M6IFsxLjY2LCAxLjcsIDEuM11cbiAgICAgIH0sIG9wdGlvbnMucGFydGljaXBhbnRzKTtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tJDEoe1xuICAgICAgICBzaWQ6ICdSTV9TSU1VTEFURUQnLFxuICAgICAgICBuYW1lOiAnc2ltdWxhdGVkLXJvb20nLFxuICAgICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICAgIG1heFBhcnRpY2lwYW50czogMCxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBwcm90b0ludDY0LnBhcnNlKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSxcbiAgICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgICBudW1QYXJ0aWNpcGFudHM6IDEsXG4gICAgICAgIG51bVB1Ymxpc2hlcnM6IDEsXG4gICAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICAgIGVuYWJsZWRDb2RlY3M6IFtdLFxuICAgICAgICBhY3RpdmVSZWNvcmRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51cGRhdGVJbmZvKG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJ1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy52aWRlbykge1xuICAgICAgICBjb25zdCBjYW1QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuVmlkZW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgIG5hbWU6ICd2aWRlby1kdW1teSdcbiAgICAgICAgfSksIG5ldyBMb2NhbFZpZGVvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pKS5nZXRWaWRlb1RyYWNrcygpWzBdIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKChfYSA9IDE2MCAqIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEsIDE2MCwgdHJ1ZSwgdHJ1ZSkpKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihjYW1QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGNhbVB1Yik7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgY29uc3QgYXVkaW9QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuQXVkaW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xuICAgICAgICB9KSwgbmV3IExvY2FsQXVkaW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICBhdWRpbzogdHJ1ZVxuICAgICAgICB9KSkuZ2V0QXVkaW9UcmFja3MoKVswXSA6IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpKSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIGF1ZGlvUHViKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRPcHRpb25zLmNvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGxldCBpbmZvID0gbmV3IFBhcnRpY2lwYW50SW5mbyh7XG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICBpZGVudGl0eTogXCJzaW11bGF0ZWQtXCIuY29uY2F0KGkpLFxuICAgICAgICAgIHN0YXRlOiBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFLFxuICAgICAgICAgIHRyYWNrczogW10sXG4gICAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMudmlkZW8pIHtcbiAgICAgICAgICBjb25zdCBkdW1teVZpZGVvID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKChfYiA9IDE2MCAqIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgMTYwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVZpZGVvLCB2aWRlb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVZpZGVvXSkpO1xuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCB2aWRlb1RyYWNrXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlUcmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VHJhY2ssIGF1ZGlvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VHJhY2tdKSk7XG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIGF1ZGlvVHJhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQoZXZlbnQpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgLy8gYWN0aXZlIHNwZWFrZXIgdXBkYXRlcyBhcmUgdG9vIHNwYW1teVxuICAgIGlmIChldmVudCAhPT0gUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInJvb20gZXZlbnQgXCIuY29uY2F0KGV2ZW50KSwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG52YXIgQ2hlY2tTdGF0dXM7XG4oZnVuY3Rpb24gKENoZWNrU3RhdHVzKSB7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU0tJUFBFRFwiXSA9IDJdID0gXCJTS0lQUEVEXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiRkFJTEVEXCJdID0gNF0gPSBcIkZBSUxFRFwiO1xufSkoQ2hlY2tTdGF0dXMgfHwgKENoZWNrU3RhdHVzID0ge30pKTtcbmNsYXNzIENoZWNrZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXR1cyA9IENoZWNrU3RhdHVzLklETEU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgdGhpcy5lcnJvcnNBc1dhcm5pbmdzID0gZmFsc2U7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0aW9ucy5jb25uZWN0T3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5lcnJvcnNBc1dhcm5pbmdzKSB7XG4gICAgICB0aGlzLmVycm9yc0FzV2FybmluZ3MgPSBvcHRpb25zLmVycm9yc0FzV2FybmluZ3M7XG4gICAgfVxuICB9XG4gIHJ1bihvbkNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xuICAgICAgICB0aHJvdyBFcnJvcignY2hlY2sgaXMgcnVubmluZyBhbHJlYWR5Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLmVycm9yc0FzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAvLyBzbGVlcCBmb3IgYSBiaXQgdG8gZW5zdXJlIGRpc2Nvbm5lY3RcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuU0tJUFBFRCkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gICAgICB9XG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmZvKCk7XG4gICAgfSk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiAhdGhpcy5sb2dzLnNvbWUobCA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5yb29tLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnJvb20gJiYgdGhpcy5yb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGl0IHRvIGdvIHRocm91Z2hcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNraXAoKSB7XG4gICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuU0tJUFBFRCk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5sb2dzLnB1c2goe1xuICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBhcHBlbmRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGFwcGVuZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgZ2V0IGVuZ2luZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZ2luZTtcbiAgfVxuICBnZXRJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2dzOiB0aGlzLmxvZ3MsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb25cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXG4gKiB0aGUgdXNlciBpbnN0ZWFkIG9mIHR3byBzZXBhcmF0ZSBvbmVzLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMgdG8gdHJ1ZVxuICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcbiAgICAoX2EgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRpb25zLmF1ZGlvID0gdHJ1ZTtcbiAgICAoX2IgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBvcHRpb25zLnZpZGVvID0gdHJ1ZTtcbiAgICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRzKTtcbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9taXNlIG9uIERldmljZU1hbmFnZXIgYW5kIGF3YWl0IGl0IGluIGdldExvY2FsRGV2aWNlcygpXG4gICAgLy8gd29ya3MgYXJvdW5kIGlPUyBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcbiAgICBjb25zdCBtZWRpYVByb21pc2UgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ2F1ZGlvaW5wdXQnKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCd2aWRlb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCd2aWRlb2lucHV0JykpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBtZWRpYVByb21pc2U7XG4gICAgcmV0dXJuIHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiB7XG4gICAgICBjb25zdCBpc0F1ZGlvID0gbWVkaWFTdHJlYW1UcmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgaXNBdWRpbyA/IG9wdGlvbnMuYXVkaW8gOiBvcHRpb25zLnZpZGVvO1xuICAgICAgbGV0IHRyYWNrQ29uc3RyYWludHM7XG4gICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcbiAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0aGUgY29uc3RyYWludHMgd2l0aCB0aGUgZGV2aWNlIGlkIHRoZSB1c2VyIGdhdmUgcGVybWlzc2lvbnMgdG8gaW4gdGhlIHBlcm1pc3Npb24gcHJvbXB0XG4gICAgICAvLyBvdGhlcndpc2UgZWFjaCB0cmFjayByZXN0YXJ0IChlLmcuIG11dGUgLSB1bm11dGUpIHdpbGwgdHJ5IHRvIGluaXRpYWxpemUgdGhlIGRldmljZSBhZ2FpbiAtPiBjYXVzaW5nIGFkZGl0aW9uYWwgcGVybWlzc2lvbiBwcm9tcHRzXG4gICAgICBpZiAodHJhY2tDb25zdHJhaW50cykge1xuICAgICAgICB0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkID0gbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IHtcbiAgICAgICAgICBkZXZpY2VJZDogbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cyk7XG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgfVxuICAgICAgdHJhY2subWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgICByZXR1cm4gdHJhY2s7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgW1tMb2NhbFZpZGVvVHJhY2tdXSB3aXRoIGdldFVzZXJNZWRpYSgpXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2sob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgIHZpZGVvOiBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICAgIGF1ZGlvOiBvcHRpb25zLFxuICAgICAgdmlkZW86IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxTY3JlZW5UcmFja3Mob3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFRyYWNrcztcbiAgfSk7XG59XG5cbmNsYXNzIFB1Ymxpc2hBdWRpb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xuICAgICAgaWYgKCFzdGF0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIHN0YXQubWVkaWFUeXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgYXVkaW8gcGFja2V0c1wiKSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUHVibGlzaFZpZGVvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggdmlkZW8nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpO1xuICAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XG4gICAgICBpZiAoIXN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgICAgfVxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgc3RhdC5tZWRpYVR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBudW1QYWNrZXRzID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiB2aWRlbyBwYWNrZXRzXCIpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdSZXN1bWluZyBjb25uZWN0aW9uIGFmdGVyIGludGVycnVwdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGxldCByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGxldCByZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IHJlY29ubmVjdFJlc29sdmVyO1xuICAgICAgY29uc3QgcmVjb25uZWN0VGltZW91dCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApO1xuICAgICAgICByZWNvbm5lY3RSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIHJvb20ub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgKCkgPT4ge1xuICAgICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgfSkub24oUm9vbUV2ZW50LlJlY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIChfYSA9IHJvb20uZW5naW5lLmNsaWVudC53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICBjb25zdCBvbkNsb3NlID0gcm9vbS5lbmdpbmUuY2xpZW50Lm9uQ2xvc2U7XG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKCcnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICBpZiAoIXJlY29ubmVjdGluZ1RyaWdnZXJlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdyZWNvbm5lY3Rpb24gaXMgb25seSBwb3NzaWJsZSBpbiBSZWRpcy1iYXNlZCBjb25maWd1cmF0aW9ucycpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgICAgbWF4UmV0cmllczogMCxcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxuICAgICAgfSk7XG4gICAgICBsZXQgaGFzVExTID0gZmFsc2U7XG4gICAgICBsZXQgaGFzVFVSTiA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1NUVU4gPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGljZVNlcnZlciBvZiBqb2luUmVzLmljZVNlcnZlcnMpIHtcbiAgICAgICAgZm9yIChsZXQgdXJsIG9mIGljZVNlcnZlci51cmxzKSB7XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzVExTID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdzdHVuOicpKSB7XG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzU1RVTikge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFNUVU4gc2VydmVycyBjb25maWd1cmVkIG9uIHNlcnZlciBzaWRlLicpO1xuICAgICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdUVVJOIGlzIGNvbmZpZ3VyZWQgc2VydmVyIHNpZGUsIGJ1dCBUVVJOL1RMUyBpcyB1bmF2YWlsYWJsZS4nKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnRjQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWNlU2VydmVycykgfHwgaGFzVFVSTikge1xuICAgICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICAgIHJ0Y0NvbmZpZzoge1xuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAncmVsYXknXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gVFVSTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGhhc1RjcCA9IGZhbHNlO1xuICAgICAgbGV0IGhhc0lwdjRVZHAgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZUcmlja2xlID0gdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlO1xuICAgICAgICB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGUgPSAoc2QsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoc2QpO1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiXCIuY29uY2F0KGNhbmRpZGF0ZS5wcm90b2NvbCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUuYWRkcmVzcywgXCI6XCIpLmNvbmNhdChjYW5kaWRhdGUucG9ydCwgXCIgXCIpLmNvbmNhdChjYW5kaWRhdGUudHlwZSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSAnIChwcml2YXRlKSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xuICAgICAgICAgICAgICAgICAgaGFzVGNwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnIChwYXNzaXZlKSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJcHY0VWRwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRyaWNrbGUpIHtcbiAgICAgICAgICAgIHByZXZUcmlja2xlKHNkLCB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZUVycm9yID0gZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogXCIuY29uY2F0KGV2LmVycm9yQ29kZSwgXCIgXCIpLmNvbmNhdChldi5lcnJvclRleHQsIFwiIFwiKS5jb25jYXQoZXYudXJsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdub3cgdGhlIHJvb20gaXMgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNUY3ApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIElDRS9UQ1AnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSXB2NFVkcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzcykge1xuICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGlmIChwYXJ0c1swXSA9PT0gJzEwJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gJzE5MicgJiYgcGFydHNbMV0gPT09ICcxNjgnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTcyJykge1xuICAgICAgY29uc3Qgc2Vjb25kID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgIGlmIChzZWNvbmQgPj0gMTYgJiYgc2Vjb25kIDw9IDMxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIFdlYlNvY2tldENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3RpbmcgdG8gc2lnbmFsIGNvbm5lY3Rpb24gdmlhIFdlYlNvY2tldCc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ3dzOicpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgaW5zZWN1cmUsIGNsaWVudHMgbWF5IGJsb2NrIGNvbm5lY3Rpb25zIHRvIGl0Jyk7XG4gICAgICB9XG4gICAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgICAgY29uc3Qgam9pblJlcyA9IHlpZWxkIHNpZ25hbENsaWVudC5qb2luKHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gICAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICAgIGUyZWVFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiQ29ubmVjdGVkIHRvIHNlcnZlciwgdmVyc2lvbiBcIi5jb25jYXQoam9pblJlcy5zZXJ2ZXJWZXJzaW9uLCBcIi5cIikpO1xuICAgICAgaWYgKCgoX2EgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lZGl0aW9uKSA9PT0gU2VydmVySW5mb19FZGl0aW9uLkNsb3VkICYmICgoX2IgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpb24pKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkxpdmVLaXQgQ2xvdWQ6IFwiLmNvbmNhdCgoX2MgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWdpb24pKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIENvbm5lY3Rpb25DaGVjayBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJ1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0SWQ7XG4gIH1cbiAgdXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKS5ldmVyeShyID0+IHIuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICB9XG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG4gIGNyZWF0ZUFuZFJ1bkNoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgICBjb25zdCB0ZXN0ID0gbmV3IGNoZWNrKHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IGluZm8gPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrKGNoZWNrSWQsIGluZm8pO1xuICAgICAgfTtcbiAgICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0ZXN0LnJ1bigpO1xuICAgICAgdGVzdC5vZmYoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNoZWNrV2Vic29ja2V0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJTb2NrZXRDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tXZWJSVEMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFdlYlJUQ0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1RVUk4oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFJlY29ubmVjdENoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1B1Ymxpc2hBdWRpbygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUHVibGlzaEF1ZGlvQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUHVibGlzaFZpZGVvKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZSB0aGUgYGZhY2luZ01vZGVgIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLCBidXQgd2lsbCBmYWxsIGJhY2sgb24gYSBzdHJpbmctYmFzZWQgYW5hbHlzaXMgb2YgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2sobG9jYWxUcmFjaykge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfYTtcbiAgY29uc3QgdHJhY2sgPSBsb2NhbFRyYWNrIGluc3RhbmNlb2YgTG9jYWxUcmFjayA/IGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA6IGxvY2FsVHJhY2s7XG4gIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGZhY2luZ01vZGU6IChfYSA9IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1c2VyJyxcbiAgICBjb25maWRlbmNlOiAnbG93J1xuICB9O1xuICAvLyAxLiBUcnkgdG8gZ2V0IGZhY2luZ01vZGUgZnJvbSB0cmFjayBzZXR0aW5ncy5cbiAgaWYgKCdmYWNpbmdNb2RlJyBpbiB0cmFja1NldHRpbmdzKSB7XG4gICAgY29uc3QgcmF3RmFjaW5nTW9kZSA9IHRyYWNrU2V0dGluZ3MuZmFjaW5nTW9kZTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdyYXdGYWNpbmdNb2RlJywge1xuICAgICAgcmF3RmFjaW5nTW9kZVxuICAgIH0pO1xuICAgIGlmIChyYXdGYWNpbmdNb2RlICYmIHR5cGVvZiByYXdGYWNpbmdNb2RlID09PSAnc3RyaW5nJyAmJiBpc0ZhY2luZ01vZGVWYWx1ZShyYXdGYWNpbmdNb2RlKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBmYWNpbmdNb2RlOiByYXdGYWNpbmdNb2RlLFxuICAgICAgICBjb25maWRlbmNlOiAnaGlnaCdcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8vIDIuIElmIHdlIGRvbid0IGhhdmUgYSBoaWdoIGNvbmZpZGVuY2Ugd2UgdHJ5IHRvIGdldCB0aGUgZmFjaW5nIG1vZGUgZnJvbSB0aGUgZGV2aWNlIGxhYmVsLlxuICBpZiAoWydsb3cnLCAnbWVkaXVtJ10uaW5jbHVkZXMocmVzdWx0LmNvbmZpZGVuY2UpKSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6IChcIi5jb25jYXQodHJhY2subGFiZWwsIFwiKVwiKSk7XG4gICAgY29uc3QgbGFiZWxBbmFseXNpc1Jlc3VsdCA9IGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwodHJhY2subGFiZWwpO1xuICAgIGlmIChsYWJlbEFuYWx5c2lzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IGxhYmVsQW5hbHlzaXNSZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXAoW1snb2JzIHZpcnR1YWwgY2FtZXJhJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV1dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXAoW1snaXBob25lJywge1xuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xufV0sIFsnaXBhZCcsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dXSk7XG4vKipcbiAqIEF0dGVtcHQgdG8gYW5hbHl6ZSB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKGRldmljZUxhYmVsKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFiZWwgPSBkZXZpY2VMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgLy8gRW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgZGV2aWNlIGxhYmVsIGJ1dCB3ZSBjYW4ndCBpbmZlciBhbnl0aGluZyBmcm9tIGl0LlxuICBpZiAobGFiZWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCB3aWRlbHkga25vd24gZGV2aWNlIGxhYmVscy5cbiAgaWYgKGtub3duRGV2aWNlTGFiZWxzLmhhcyhsYWJlbCkpIHtcbiAgICByZXR1cm4ga25vd25EZXZpY2VMYWJlbHMuZ2V0KGxhYmVsKTtcbiAgfVxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gKF9hID0gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKF9yZWYgPT4ge1xuICAgIGxldCBbc2VjdGlvbl0gPSBfcmVmO1xuICAgIHJldHVybiBsYWJlbC5pbmNsdWRlcyhzZWN0aW9uKTtcbiAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcbn1cbmZ1bmN0aW9uIGlzRmFjaW5nTW9kZVZhbHVlKGl0ZW0pIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndXNlcicsICdlbnZpcm9ubWVudCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgfHwgYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyhpdGVtKTtcbn1cblxuZXhwb3J0IHsgQXVkaW9QcmVzZXRzLCBCYXNlS2V5UHJvdmlkZXIsIENvbm5lY3Rpb25DaGVjaywgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uUXVhbGl0eSwgQ29ubmVjdGlvblN0YXRlLCBDcml0aWNhbFRpbWVycywgQ3J5cHRvckV2ZW50LCBEYXRhUGFja2V0X0tpbmQsIERlZmF1bHRSZWNvbm5lY3RQb2xpY3ksIERldmljZVVuc3VwcG9ydGVkRXJyb3IsIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25FdmVudCwgRW5naW5lRXZlbnQsIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyLCBLZXlIYW5kbGVyRXZlbnQsIEtleVByb3ZpZGVyRXZlbnQsIExpdmVraXRFcnJvciwgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFBhcnRpY2lwYW50LCBMb2NhbFRyYWNrLCBMb2NhbFRyYWNrUHVibGljYXRpb24sIExvY2FsVmlkZW9UcmFjaywgTG9nTGV2ZWwsIE1lZGlhRGV2aWNlRmFpbHVyZSwgTmVnb3RpYXRpb25FcnJvciwgUGFydGljaXBhbnQsIFBhcnRpY2lwYW50RXZlbnQsIFB1Ymxpc2hEYXRhRXJyb3IsIFJlbW90ZUF1ZGlvVHJhY2ssIFJlbW90ZVBhcnRpY2lwYW50LCBSZW1vdGVUcmFjaywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgUmVtb3RlVmlkZW9UcmFjaywgUm9vbSwgUm9vbUV2ZW50LCBSb29tU3RhdGUsIFNjcmVlblNoYXJlUHJlc2V0cywgVHJhY2ssIFRyYWNrRXZlbnQsIFRyYWNrSW52YWxpZEVycm9yLCBUcmFja1B1YmxpY2F0aW9uLCBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlLCBVbnN1cHBvcnRlZFNlcnZlciwgVmlkZW9QcmVzZXQsIFZpZGVvUHJlc2V0cywgVmlkZW9QcmVzZXRzNDMsIFZpZGVvUXVhbGl0eSwgYXR0YWNoVG9FbGVtZW50LCBjcmVhdGVBdWRpb0FuYWx5c2VyLCBjcmVhdGVFMkVFS2V5LCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZywgY3JlYXRlTG9jYWxBdWRpb1RyYWNrLCBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcywgY3JlYXRlTG9jYWxUcmFja3MsIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaywgZGVyaXZlS2V5cywgZGV0YWNoVHJhY2ssIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjaywgZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrLCBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2ssIGltcG9ydEtleSwgaXNCYWNrdXBDb2RlYywgaXNCcm93c2VyU3VwcG9ydGVkLCBpc0UyRUVTdXBwb3J0ZWQsIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQsIGlzVmlkZW9GcmFtZSwgbmVlZHNSYnNwVW5lc2NhcGluZywgcGFyc2VSYnNwLCBwcm90b2NvbFZlcnNpb24sIHJhdGNoZXQsIHNldExvZ0V4dGVuc2lvbiwgc2V0TG9nTGV2ZWwsIHN1cHBvcnRzQVYxLCBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtLCBzdXBwb3J0c0R5bmFjYXN0LCBzdXBwb3J0c1ZQOSwgdmVyc2lvbiwgdmlkZW9Db2RlY3MsIHdyaXRlUmJzcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl2ZWtpdC1jbGllbnQuZXNtLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfbWVyZ2VOYW1lc3BhY2VzIiwibiIsIm0iLCJmb3JFYWNoIiwiZSIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleXMiLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibG9nbGV2ZWwiLCJleHBvcnRzIiwibW9kdWxlIiwicm9vdCIsImRlZmluaXRpb24iLCJsb2ciLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImlzSUUiLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ0cmFjZUZvcklFIiwiY29uc29sZSIsInRyYWNlIiwicmVhbE1ldGhvZCIsInVuZGVmaW5lZCIsInJlcGxhY2VMb2dnaW5nTWV0aG9kcyIsImxldmVsIiwibG9nZ2VyTmFtZSIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwiZGVidWciLCJlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzIiwiZGVmYXVsdE1ldGhvZEZhY3RvcnkiLCJMb2dnZXIiLCJuYW1lIiwiZGVmYXVsdExldmVsIiwiZmFjdG9yeSIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImNsZWFyUGVyc2lzdGVkTGV2ZWwiLCJyZW1vdmVJdGVtIiwiZ2V0TGV2ZWwiLCJzZXRMZXZlbCIsInBlcnNpc3QiLCJTSUxFTlQiLCJzZXREZWZhdWx0TGV2ZWwiLCJyZXNldExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwibG9nbGV2ZWxFeHBvcnRzIiwiTG9nTGV2ZWwiLCJsaXZla2l0TG9nZ2VyIiwiaW5mbyIsInNldExvZ0xldmVsIiwidmFsdWVzIiwic2V0TG9nRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uIiwib3JpZ2luYWxGYWN0b3J5IiwiY29uZmlnTGV2ZWwiLCJyYXdNZXRob2QiLCJsb2dMZXZlbCIsIm5lZWRMb2ciLCJzaWxlbnQiLCJtc2ciLCJjb250ZXh0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJ0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsIm1hcCIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUVudW1WYWx1ZSIsInB1c2giLCJmaW5kTmFtZSIsImZpbmROdW1iZXIiLCJtYWtlRW51bSIsImFzc2lnbiIsIk1lc3NhZ2UiLCJlcXVhbHMiLCJvdGhlciIsImdldFR5cGUiLCJydW50aW1lIiwidXRpbCIsImNsb25lIiwiZnJvbUJpbmFyeSIsImJ5dGVzIiwib3B0aW9ucyIsInR5cGUiLCJmb3JtYXQiLCJiaW4iLCJtYWtlUmVhZE9wdGlvbnMiLCJyZWFkTWVzc2FnZSIsInJlYWRlckZhY3RvcnkiLCJieXRlTGVuZ3RoIiwiZnJvbUpzb24iLCJqc29uVmFsdWUiLCJqc29uIiwiZnJvbUpzb25TdHJpbmciLCJqc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiY29uY2F0IiwibWVzc2FnZSIsIlN0cmluZyIsInRvQmluYXJ5IiwibWFrZVdyaXRlT3B0aW9ucyIsIndyaXRlciIsIndyaXRlckZhY3RvcnkiLCJ3cml0ZU1lc3NhZ2UiLCJmaW5pc2giLCJ0b0pzb24iLCJ0b0pzb25TdHJpbmciLCJfYSIsInN0cmluZ2lmeSIsInByZXR0eVNwYWNlcyIsInRvSlNPTiIsImVtaXREZWZhdWx0VmFsdWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIm1ha2VNZXNzYWdlVHlwZSIsImZpZWxkcyIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZGF0YSIsImluaXRGaWVsZHMiLCJpbml0UGFydGlhbCIsInNldFByb3RvdHlwZU9mIiwibmV3RmllbGRMaXN0IiwiYSIsImIiLCJtYWtlUHJvdG9SdW50aW1lIiwic3ludGF4IiwiU2NhbGFyVHlwZSIsIkxvbmdUeXBlIiwidmFyaW50NjRyZWFkIiwibG93Qml0cyIsImhpZ2hCaXRzIiwic2hpZnQiLCJidWYiLCJwb3MiLCJhc3NlcnRCb3VuZHMiLCJtaWRkbGVCeXRlIiwidmFyaW50NjR3cml0ZSIsImxvIiwiaGkiLCJoYXNOZXh0IiwiYnl0ZSIsInNwbGl0Qml0cyIsImhhc01vcmVCaXRzIiwiVFdPX1BXUl8zMl9EQkwiLCJpbnQ2NEZyb21TdHJpbmciLCJkZWMiLCJtaW51cyIsImJhc2UiLCJhZGQxZTZkaWdpdCIsImJlZ2luIiwiZW5kIiwiZGlnaXQxZTYiLCJuZWdhdGUiLCJuZXdCaXRzIiwiaW50NjRUb1N0cmluZyIsImJpdHMiLCJuZWdhdGl2ZSIsInJlc3VsdCIsInVJbnQ2NFRvU3RyaW5nIiwidG9VbnNpZ25lZCIsImxvdyIsIm1pZCIsImhpZ2giLCJkaWdpdEEiLCJkaWdpdEIiLCJkaWdpdEMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyIsImRpZ2l0MWU3IiwicGFydGlhbCIsInZhcmludDMyd3JpdGUiLCJ2YXJpbnQzMnJlYWQiLCJyZWFkQnl0ZXMiLCJtYWtlSW50NjRTdXBwb3J0IiwiZHYiLCJEYXRhVmlldyIsIkFycmF5QnVmZmVyIiwib2siLCJCaWdJbnQiLCJnZXRCaWdJbnQ2NCIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwicHJvY2VzcyIsImVudiIsIkJVRl9CSUdJTlRfRElTQUJMRSIsIk1JTiIsIk1BWCIsIlVNSU4iLCJVTUFYIiwiemVybyIsInN1cHBvcnRlZCIsImJpIiwidVBhcnNlIiwiZW5jIiwiZ2V0SW50MzIiLCJ1RW5jIiwic2V0SW50MzIiLCJ1RGVjIiwiYXNzZXJ0SW50NjRTdHJpbmciLCJhc3NlcnRVSW50NjRTdHJpbmciLCJwcm90b0ludDY0IiwiV2lyZVR5cGUiLCJCaW5hcnlXcml0ZXIiLCJ0ZXh0RW5jb2RlciIsInN0YWNrIiwiVGV4dEVuY29kZXIiLCJjaHVua3MiLCJVaW50OEFycmF5IiwibGVuIiwib2Zmc2V0Iiwic2V0IiwiZm9yayIsImpvaW4iLCJjaHVuayIsInByZXYiLCJwb3AiLCJ1aW50MzIiLCJyYXciLCJ0YWciLCJmaWVsZE5vIiwiaW50MzIiLCJib29sIiwic3RyaW5nIiwiZW5jb2RlIiwiZmxvYXQiLCJidWZmZXIiLCJzZXRGbG9hdDMyIiwiZG91YmxlIiwic2V0RmxvYXQ2NCIsImZpeGVkMzIiLCJzZXRVaW50MzIiLCJzZml4ZWQzMiIsInNpbnQzMiIsInNmaXhlZDY0IiwidmlldyIsInRjIiwiZml4ZWQ2NCIsImludDY0Iiwic2ludDY0Iiwic2lnbiIsInVpbnQ2NCIsIkJpbmFyeVJlYWRlciIsInRleHREZWNvZGVyIiwidmFyaW50NjQiLCJieXRlT2Zmc2V0IiwiVGV4dERlY29kZXIiLCJ3aXJlVHlwZSIsInNraXAiLCJzdGFydCIsIlZhcmludCIsIkJpdDY0IiwiQml0MzIiLCJMZW5ndGhEZWxpbWl0ZWQiLCJTdGFydEdyb3VwIiwiRW5kR3JvdXAiLCJzdWJhcnJheSIsIlJhbmdlRXJyb3IiLCJ6emUiLCJzIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJkZWNvZGUiLCJ3cmFwRmllbGQiLCJmaWVsZFdyYXBwZXIiLCJET1VCTEUiLCJGTE9BVCIsIklOVDY0IiwiVUlOVDY0IiwiSU5UMzIiLCJVSU5UMzIiLCJCT09MIiwiU1RSSU5HIiwiQllURVMiLCJzY2FsYXJFcXVhbHMiLCJGSVhFRDY0IiwiU0ZJWEVENjQiLCJTSU5UNjQiLCJzY2FsYXJEZWZhdWx0VmFsdWUiLCJsb25nVHlwZSIsInNjYWxhclR5cGVJbmZvIiwiaXNVbmRlZmluZWQiLCJpc0ludHJpbnNpY0RlZmF1bHQiLCJGSVhFRDMyIiwiU0ZJWEVEMzIiLCJ0b0xvd2VyQ2FzZSIsInVua25vd25GaWVsZHNTeW1ib2wiLCJyZWFkRGVmYXVsdHMiLCJyZWFkVW5rbm93bkZpZWxkcyIsIndyaXRlRGVmYXVsdHMiLCJ3cml0ZVVua25vd25GaWVsZHMiLCJtYWtlUmVhZE9wdGlvbnMkMSIsIm1ha2VXcml0ZU9wdGlvbnMkMSIsIm1ha2VCaW5hcnlGb3JtYXRDb21tb24iLCJsaXN0VW5rbm93bkZpZWxkcyIsImRpc2NhcmRVbmtub3duRmllbGRzIiwiYyIsImYiLCJvblVua25vd25GaWVsZCIsInJlYWRlciIsImZpZWxkIiwiZmluZCIsInRhcmdldCIsInJlcGVhdGVkIiwib25lb2YiLCJjYXNlIiwia2luZCIsInNjYWxhclR5cGUiLCJUIiwicmVhZCIsInJlYWRTY2FsYXIkMSIsIkwiLCJyZWFkU2NhbGFyTFRTdHJpbmciLCJhcnIiLCJtZXNzYWdlVHlwZSIsInJlYWRNZXNzYWdlRmllbGQiLCJ1bndyYXBGaWVsZCIsIm1hcEtleSIsIm1hcFZhbCIsInJlYWRNYXBFbnRyeSIsImtleSIsInZhbCIsIksiLCJWIiwia2V5UmF3IiwiQklHSU5UIiwiU0lOVDMyIiwid3JpdGVNYXBFbnRyeSIsImtleVZhbHVlIiwicGFyc2VJbnQiLCJ3cml0ZVNjYWxhciQxIiwid3JpdGVNZXNzYWdlRmllbGQiLCJlbWl0SW50cmluc2ljRGVmYXVsdCIsIndyaXRlUGFja2VkIiwibWFrZUJpbmFyeUZvcm1hdFByb3RvMyIsImJ5TnVtYmVyIiwicGFja2VkIiwiaXRlbSIsImVudHJpZXMiLCJlbmNUYWJsZSIsInNwbGl0IiwiZGVjVGFibGUiLCJjaGFyQ29kZUF0IiwicHJvdG9CYXNlNjQiLCJiYXNlNjRTdHIiLCJlcyIsImJ5dGVQb3MiLCJncm91cFBvcyIsInAiLCJiYXNlNjQiLCJqc29uUmVhZERlZmF1bHRzIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsImpzb25Xcml0ZURlZmF1bHRzIiwiZW51bUFzSW50ZWdlciIsInVzZVByb3RvRmllbGROYW1lIiwibWFrZUpzb25Gb3JtYXRDb21tb24iLCJtYWtlV3JpdGVGaWVsZCIsIndyaXRlRmllbGQiLCJ3cml0ZUVudW0iLCJ3cml0ZVNjYWxhciIsIm9uZW9mU2VlbiIsImpzb25LZXkiLCJmaW5kSnNvbk5hbWUiLCJzZWVuIiwidGFyZ2V0QXJyYXkiLCJqc29uSXRlbSIsInJlYWRFbnVtIiwicmVhZFNjYWxhciIsInRhcmdldE1hcCIsImpzb25NYXBLZXkiLCJqc29uTWFwVmFsdWUiLCJlbnVtVmFsdWUiLCJtZW1iZXIiLCJieU1lbWJlciIsImZpbmRGaWVsZCIsImpzb25OYW1lIiwiciIsImRlYnVnSnNvblZhbHVlIiwiTmFOIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsInRyaW0iLCJpc05hTiIsImxvbmciLCJ1TG9uZyIsIm1ha2VKc29uRm9ybWF0UHJvdG8zIiwianNvbk9iaiIsImVudHJ5S2V5IiwiZW50cnlWYWx1ZSIsImVudW1UeXBlIiwianNvbkFyciIsIm1ha2VVdGlsQ29tbW9uIiwic291cmNlIiwic2siLCJzb3VyY2VGaWVsZCIsInRvVThBcnIiLCJjb3B5IiwibXQiLCJldmVyeSIsInZhIiwidmIiLCJhbnkiLCJjbG9uZVNpbmd1bGFyRmllbGQiLCJpbnB1dCIsIkludGVybmFsRmllbGRMaXN0Iiwibm9ybWFsaXplciIsIl9maWVsZHMiLCJfbm9ybWFsaXplciIsImpzb25OYW1lcyIsImxpc3QiLCJhbGwiLCJudW1iZXJzQXNjIiwic29ydCIsIm1lbWJlcnMiLCJvIiwibG9jYWxGaWVsZE5hbWUiLCJwcm90b05hbWUiLCJpbk9uZW9mIiwicHJvdG9DYW1lbENhc2UiLCJzYWZlT2JqZWN0UHJvcGVydHkiLCJzYWZlTWVzc2FnZVByb3BlcnR5IiwibG9jYWxPbmVvZk5hbWUiLCJmaWVsZEpzb25OYW1lIiwic25ha2VDYXNlIiwiY2FwTmV4dCIsImNoYXJBdCIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiZGVmYXVsdCIsImFkZEZpZWxkIiwiX2xvb2t1cCIsInByb3RvMyIsIm5vcm1hbGl6ZUZpZWxkSW5mb3NQcm90bzMiLCJmaWVsZEluZm9zIiwiX2IiLCJfYyIsIl9kIiwib29uYW1lIiwiVGltZXN0YW1wIiwic2Vjb25kcyIsIm5hbm9zIiwibWF0Y2hlcyIsIm1hdGNoIiwibXMiLCJEYXRlIiwicmVwZWF0IiwieiIsIm5hbm9zU3RyIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwidG9EYXRlIiwiY2VpbCIsIm5vdyIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJBdWRpb0NvZGVjIiwiVmlkZW9Db2RlYyIsIkltYWdlQ29kZWMiLCJUcmFja1R5cGUiLCJUcmFja1NvdXJjZSIsIlZpZGVvUXVhbGl0eSIsIkNvbm5lY3Rpb25RdWFsaXR5JDEiLCJDb25uZWN0aW9uUXVhbGl0eSIsIkNsaWVudENvbmZpZ1NldHRpbmciLCJEaXNjb25uZWN0UmVhc29uIiwiUmVjb25uZWN0UmVhc29uIiwiU3Vic2NyaXB0aW9uRXJyb3IiLCJSb29tJDEiLCJSb29tIiwic2lkIiwiZW1wdHlUaW1lb3V0IiwibWF4UGFydGljaXBhbnRzIiwiY3JlYXRpb25UaW1lIiwidHVyblBhc3N3b3JkIiwiZW5hYmxlZENvZGVjcyIsIm1ldGFkYXRhIiwibnVtUGFydGljaXBhbnRzIiwibnVtUHVibGlzaGVycyIsImFjdGl2ZVJlY29yZGluZyIsIkNvZGVjIiwibWltZSIsImZtdHBMaW5lIiwiUGxheW91dERlbGF5IiwiZW5hYmxlZCIsIm1pbiIsIm1heCIsIlBhcnRpY2lwYW50UGVybWlzc2lvbiIsImNhblN1YnNjcmliZSIsImNhblB1Ymxpc2giLCJjYW5QdWJsaXNoRGF0YSIsImNhblB1Ymxpc2hTb3VyY2VzIiwiaGlkZGVuIiwicmVjb3JkZXIiLCJjYW5VcGRhdGVNZXRhZGF0YSIsImFnZW50IiwiUGFydGljaXBhbnRJbmZvIiwiaWRlbnRpdHkiLCJzdGF0ZSIsIlBhcnRpY2lwYW50SW5mb19TdGF0ZSIsIkpPSU5JTkciLCJ0cmFja3MiLCJqb2luZWRBdCIsInZlcnNpb24iLCJyZWdpb24iLCJpc1B1Ymxpc2hlciIsIlRyYWNrSW5mbyIsIkVuY3J5cHRpb24iLCJFbmNyeXB0aW9uX1R5cGUiLCJTaW11bGNhc3RDb2RlY0luZm8iLCJtaW1lVHlwZSIsImNpZCIsImxheWVycyIsIlZpZGVvTGF5ZXIiLCJBVURJTyIsIm11dGVkIiwid2lkdGgiLCJoZWlnaHQiLCJzaW11bGNhc3QiLCJkaXNhYmxlRHR4IiwiVU5LTk9XTiIsImNvZGVjcyIsInN0ZXJlbyIsImRpc2FibGVSZWQiLCJlbmNyeXB0aW9uIiwiTk9ORSIsInN0cmVhbSIsInF1YWxpdHkiLCJMT1ciLCJiaXRyYXRlIiwic3NyYyIsIkRhdGFQYWNrZXQiLCJEYXRhUGFja2V0X0tpbmQiLCJSRUxJQUJMRSIsIlVzZXJQYWNrZXQiLCJBY3RpdmVTcGVha2VyVXBkYXRlIiwic3BlYWtlcnMiLCJTcGVha2VySW5mbyIsImFjdGl2ZSIsInBhcnRpY2lwYW50U2lkIiwicGFydGljaXBhbnRJZGVudGl0eSIsInBheWxvYWQiLCJkZXN0aW5hdGlvblNpZHMiLCJkZXN0aW5hdGlvbklkZW50aXRpZXMiLCJQYXJ0aWNpcGFudFRyYWNrcyIsInRyYWNrU2lkcyIsIlNlcnZlckluZm8iLCJlZGl0aW9uIiwiU2VydmVySW5mb19FZGl0aW9uIiwiU3RhbmRhcmQiLCJwcm90b2NvbCIsIm5vZGVJZCIsImRlYnVnSW5mbyIsIkNsaWVudEluZm8iLCJzZGsiLCJDbGllbnRJbmZvX1NESyIsIm9zIiwib3NWZXJzaW9uIiwiZGV2aWNlTW9kZWwiLCJicm93c2VyIiwiYnJvd3NlclZlcnNpb24iLCJhZGRyZXNzIiwibmV0d29yayIsIkNsaWVudENvbmZpZ3VyYXRpb24iLCJyZXN1bWVDb25uZWN0aW9uIiwiVU5TRVQiLCJmb3JjZVJlbGF5IiwiVmlkZW9Db25maWd1cmF0aW9uIiwiRGlzYWJsZWRDb2RlY3MiLCJoYXJkd2FyZUVuY29kZXIiLCJwdWJsaXNoIiwiUlRQRHJpZnQiLCJkdXJhdGlvbiIsInN0YXJ0VGltZXN0YW1wIiwiZW5kVGltZXN0YW1wIiwicnRwQ2xvY2tUaWNrcyIsImRyaWZ0U2FtcGxlcyIsImRyaWZ0TXMiLCJjbG9ja1JhdGUiLCJSVFBTdGF0cyIsInBhY2tldHMiLCJwYWNrZXRSYXRlIiwiaGVhZGVyQnl0ZXMiLCJwYWNrZXRzTG9zdCIsInBhY2tldExvc3NSYXRlIiwicGFja2V0TG9zc1BlcmNlbnRhZ2UiLCJwYWNrZXRzRHVwbGljYXRlIiwicGFja2V0RHVwbGljYXRlUmF0ZSIsImJ5dGVzRHVwbGljYXRlIiwiaGVhZGVyQnl0ZXNEdXBsaWNhdGUiLCJiaXRyYXRlRHVwbGljYXRlIiwicGFja2V0c1BhZGRpbmciLCJwYWNrZXRQYWRkaW5nUmF0ZSIsImJ5dGVzUGFkZGluZyIsImhlYWRlckJ5dGVzUGFkZGluZyIsImJpdHJhdGVQYWRkaW5nIiwicGFja2V0c091dE9mT3JkZXIiLCJmcmFtZXMiLCJmcmFtZVJhdGUiLCJqaXR0ZXJDdXJyZW50Iiwiaml0dGVyTWF4IiwiZ2FwSGlzdG9ncmFtIiwibmFja3MiLCJuYWNrQWNrcyIsIm5hY2tNaXNzZXMiLCJuYWNrUmVwZWF0ZWQiLCJwbGlzIiwiZmlycyIsInJ0dEN1cnJlbnQiLCJydHRNYXgiLCJrZXlGcmFtZXMiLCJsYXllckxvY2tQbGlzIiwiVGltZWRWZXJzaW9uIiwidW5peE1pY3JvIiwidGlja3MiLCJtYXhSZXRyeURlbGF5IiwiREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMiLCJEZWZhdWx0UmVjb25uZWN0UG9saWN5IiwicmV0cnlEZWxheXMiLCJfcmV0cnlEZWxheXMiLCJuZXh0UmV0cnlEZWxheUluTXMiLCJyZXRyeUNvdW50IiwicmV0cnlEZWxheSIsInJhbmRvbSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwiZG9uZSIsInRoZW4iLCJfX3ZhbHVlcyIsIml0ZXJhdG9yIiwiX19hc3luY1ZhbHVlcyIsImFzeW5jSXRlcmF0b3IiLCJ2ZXJiIiwic2V0dGxlIiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwiZXZlbnRzIiwiUiIsIlJlZmxlY3QiLCJSZWZsZWN0QXBwbHkiLCJyZWNlaXZlciIsImFyZ3MiLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImVyIiwiZXJyIiwiaGFuZGxlciIsImxpc3RlbmVycyIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsInVuc2hpZnQiLCJ3YXJuZWQiLCJ3IiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsIndyYXBwZWQiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9zaXRpb24iLCJvcmlnaW5hbExpc3RlbmVyIiwic3BsaWNlT25lIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImluZGV4IiwicmV0IiwiZXJyb3JMaXN0ZW5lciIsInJlc29sdmVyIiwiZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyIiwiYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIiLCJmbGFncyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3cmFwTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnRzRXhwb3J0cyIsImxvZ0Rpc2FibGVkXyIsImRlcHJlY2F0aW9uV2FybmluZ3NfIiwiZXh0cmFjdFZlcnNpb24iLCJ1YXN0cmluZyIsImV4cHIiLCJ3cmFwUGVlckNvbm5lY3Rpb25FdmVudCIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJSVENQZWVyQ29ubmVjdGlvbiIsInByb3RvIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsImNiIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiX2V2ZW50TWFwIiwiTWFwIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVud3JhcHBlZENiIiwiZGVsZXRlIiwic2l6ZSIsImNvbmZpZ3VyYWJsZSIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGVkIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwiZGV0ZWN0QnJvd3NlciIsIm1vekdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsImlzU2VjdXJlQ29udGV4dCIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwic3VwcG9ydHNVbmlmaWVkUGxhbiIsIlJUQ1J0cFRyYW5zY2VpdmVyIiwiaXNPYmplY3QiLCJjb21wYWN0T2JqZWN0IiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpc09iaiIsImlzRW1wdHlPYmplY3QiLCJ3YWxrU3RhdHMiLCJzdGF0cyIsInJlc3VsdFNldCIsImlkIiwiZW5kc1dpdGgiLCJmaWx0ZXJTdGF0cyIsInRyYWNrIiwib3V0Ym91bmQiLCJzdHJlYW1TdGF0c1R5cGUiLCJmaWx0ZXJlZFJlc3VsdCIsInRyYWNrU3RhdHMiLCJ0cmFja0lkZW50aWZpZXIiLCJ0cmFja1N0YXQiLCJ0cmFja0lkIiwibG9nZ2luZyIsInNoaW1HZXRVc2VyTWVkaWEkMiIsImJyb3dzZXJEZXRhaWxzIiwibWVkaWFEZXZpY2VzIiwiY29uc3RyYWludHNUb0Nocm9tZV8iLCJtYW5kYXRvcnkiLCJvcHRpb25hbCIsImNjIiwiaWRlYWwiLCJleGFjdCIsIm9sZG5hbWVfIiwicHJlZml4Iiwib2MiLCJtaXgiLCJhZHZhbmNlZCIsInNoaW1Db25zdHJhaW50c18iLCJjb25zdHJhaW50cyIsImZ1bmMiLCJhdWRpbyIsInJlbWFwIiwidmlkZW8iLCJmYWNlIiwiZmFjaW5nTW9kZSIsImdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzIiwiZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMiLCJlbnVtZXJhdGVEZXZpY2VzIiwiZGV2aWNlcyIsImZpbHRlciIsImRldiIsInNvbWUiLCJsYWJlbCIsImluY2x1ZGVzIiwiZGV2aWNlSWQiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJnZXRVc2VyTWVkaWEiLCJvcmlnR2V0VXNlck1lZGlhIiwiY3MiLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0VHJhY2tzIiwic3RvcCIsIkRPTUV4Y2VwdGlvbiIsInNoaW1HZXREaXNwbGF5TWVkaWEkMSIsImdldFNvdXJjZUlkIiwiZ2V0RGlzcGxheU1lZGlhIiwic291cmNlSWQiLCJ3aWR0aFNwZWNpZmllZCIsImhlaWdodFNwZWNpZmllZCIsImZyYW1lUmF0ZVNwZWNpZmllZCIsImNocm9tZU1lZGlhU291cmNlIiwiY2hyb21lTWVkaWFTb3VyY2VJZCIsIm1heEZyYW1lUmF0ZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0Iiwic2hpbU1lZGlhU3RyZWFtIiwiTWVkaWFTdHJlYW0iLCJ3ZWJraXRNZWRpYVN0cmVhbSIsInNoaW1PblRyYWNrJDEiLCJfb250cmFjayIsIm9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiX29udHJhY2twb2x5IiwidGUiLCJnZXRSZWNlaXZlcnMiLCJldmVudCIsIkV2ZW50IiwidHJhbnNjZWl2ZXIiLCJzdHJlYW1zIiwiZGlzcGF0Y2hFdmVudCIsInNoaW1HZXRTZW5kZXJzV2l0aER0bWYiLCJzaGltU2VuZGVyV2l0aER0bWYiLCJwYyIsImR0bWYiLCJfZHRtZiIsImNyZWF0ZURUTUZTZW5kZXIiLCJfcGMiLCJnZXRTZW5kZXJzIiwiX3NlbmRlcnMiLCJvcmlnQWRkVHJhY2siLCJhZGRUcmFjayIsInNlbmRlciIsIm9yaWdSZW1vdmVUcmFjayIsInJlbW92ZVRyYWNrIiwiaWR4Iiwic3BsaWNlIiwib3JpZ0FkZFN0cmVhbSIsImFkZFN0cmVhbSIsIm9yaWdSZW1vdmVTdHJlYW0iLCJyZW1vdmVTdHJlYW0iLCJSVENSdHBTZW5kZXIiLCJvcmlnR2V0U2VuZGVycyIsInNlbmRlcnMiLCJzaGltR2V0U3RhdHMiLCJvcmlnR2V0U3RhdHMiLCJnZXRTdGF0cyIsInNlbGVjdG9yIiwib25TdWNjIiwib25FcnIiLCJmaXhDaHJvbWVTdGF0c18iLCJyZXNwb25zZSIsInN0YW5kYXJkUmVwb3J0IiwicmVwb3J0cyIsInJlcG9ydCIsInN0YW5kYXJkU3RhdHMiLCJ0aW1lc3RhbXAiLCJsb2NhbGNhbmRpZGF0ZSIsInJlbW90ZWNhbmRpZGF0ZSIsInN0YXQiLCJtYWtlTWFwU3RhdHMiLCJzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyIsInNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzIiwiUlRDUnRwUmVjZWl2ZXIiLCJvcmlnR2V0UmVjZWl2ZXJzIiwicmVjZWl2ZXJzIiwic3JjRWxlbWVudCIsIk1lZGlhU3RyZWFtVHJhY2siLCJzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUiLCJnZXRMb2NhbFN0cmVhbXMiLCJfc2hpbW1lZExvY2FsU3RyZWFtcyIsInN0cmVhbUlkIiwiYWxyZWFkeUV4aXN0cyIsImV4aXN0aW5nU2VuZGVycyIsIm5ld1NlbmRlcnMiLCJuZXdTZW5kZXIiLCJzaGltQWRkVHJhY2tSZW1vdmVUcmFjayIsIm9yaWdHZXRMb2NhbFN0cmVhbXMiLCJuYXRpdmVTdHJlYW1zIiwiX3JldmVyc2VTdHJlYW1zIiwiX3N0cmVhbXMiLCJuZXdTdHJlYW0iLCJzaWduYWxpbmdTdGF0ZSIsIm9sZFN0cmVhbSIsInJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkIiwiZGVzY3JpcHRpb24iLCJzZHAiLCJpbnRlcm5hbElkIiwiZXh0ZXJuYWxTdHJlYW0iLCJpbnRlcm5hbFN0cmVhbSIsIlJlZ0V4cCIsIlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiIsInJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkIiwibmF0aXZlTWV0aG9kIiwibWV0aG9kT2JqIiwiaXNMZWdhY3lDYWxsIiwiZGVzYyIsIm9yaWdTZXRMb2NhbERlc2NyaXB0aW9uIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsIm9yaWdMb2NhbERlc2NyaXB0aW9uIiwiaXNMb2NhbCIsInN0cmVhbWlkIiwiaGFzVHJhY2siLCJzaGltUGVlckNvbm5lY3Rpb24kMSIsIlJUQ0ljZUNhbmRpZGF0ZSIsImZpeE5lZ290aWF0aW9uTmVlZGVkIiwiZ2V0Q29uZmlndXJhdGlvbiIsInNkcFNlbWFudGljcyIsImNocm9tZVNoaW0iLCJfX3Byb3RvX18iLCJzaGltR2V0RGlzcGxheU1lZGlhIiwic2hpbUdldFVzZXJNZWRpYSIsInNoaW1PblRyYWNrIiwic2hpbVBlZXJDb25uZWN0aW9uIiwic2hpbUdldFVzZXJNZWRpYSQxIiwibmF0aXZlR2V0VXNlck1lZGlhIiwiZ2V0U2V0dGluZ3MiLCJuYXRpdmVHZXRTZXR0aW5ncyIsImFwcGx5Q29uc3RyYWludHMiLCJuYXRpdmVBcHBseUNvbnN0cmFpbnRzIiwicHJlZmVycmVkTWVkaWFTb3VyY2UiLCJjb2RlIiwibWVkaWFTb3VyY2UiLCJSVENUcmFja0V2ZW50IiwibW96UlRDUGVlckNvbm5lY3Rpb24iLCJtb2Rlcm5TdGF0c1R5cGVzIiwiaW5ib3VuZHJ0cCIsIm91dGJvdW5kcnRwIiwiY2FuZGlkYXRlcGFpciIsIm5hdGl2ZUdldFN0YXRzIiwic2hpbVNlbmRlckdldFN0YXRzIiwic2hpbVJlY2VpdmVyR2V0U3RhdHMiLCJzaGltUmVtb3ZlU3RyZWFtIiwic2hpbVJUQ0RhdGFDaGFubmVsIiwiRGF0YUNoYW5uZWwiLCJSVENEYXRhQ2hhbm5lbCIsInNoaW1BZGRUcmFuc2NlaXZlciIsIm9yaWdBZGRUcmFuc2NlaXZlciIsImFkZFRyYW5zY2VpdmVyIiwic2V0UGFyYW1ldGVyc1Byb21pc2VzIiwic2VuZEVuY29kaW5ncyIsInNob3VsZFBlcmZvcm1DaGVjayIsImVuY29kaW5nUGFyYW0iLCJyaWRSZWdleCIsInJpZCIsInBhcnNlRmxvYXQiLCJzY2FsZVJlc29sdXRpb25Eb3duQnkiLCJtYXhGcmFtZXJhdGUiLCJwYXJhbXMiLCJnZXRQYXJhbWV0ZXJzIiwiZW5jb2RpbmdzIiwic2V0UGFyYW1ldGVycyIsImNhdGNoIiwic2hpbUdldFBhcmFtZXRlcnMiLCJvcmlnR2V0UGFyYW1ldGVycyIsInNoaW1DcmVhdGVPZmZlciIsIm9yaWdDcmVhdGVPZmZlciIsImNyZWF0ZU9mZmVyIiwiZmluYWxseSIsInNoaW1DcmVhdGVBbnN3ZXIiLCJvcmlnQ3JlYXRlQW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiZmlyZWZveFNoaW0iLCJzaGltTG9jYWxTdHJlYW1zQVBJIiwiX2xvY2FsU3RyZWFtcyIsIl9hZGRUcmFjayIsIl9sZW4iLCJfa2V5Iiwic2hpbVJlbW90ZVN0cmVhbXNBUEkiLCJnZXRSZW1vdGVTdHJlYW1zIiwiX3JlbW90ZVN0cmVhbXMiLCJfb25hZGRzdHJlYW0iLCJfb25hZGRzdHJlYW1wb2x5Iiwic2hpbUNhbGxiYWNrc0FQSSIsImFkZEljZUNhbmRpZGF0ZSIsInN1Y2Nlc3NDYWxsYmFjayIsImZhaWx1cmVDYWxsYmFjayIsInByb21pc2UiLCJ3aXRoQ2FsbGJhY2siLCJjYW5kaWRhdGUiLCJfZ2V0VXNlck1lZGlhIiwic2hpbUNvbnN0cmFpbnRzIiwiZXJyY2IiLCJzaGltUlRDSWNlU2VydmVyVXJscyIsIk9yaWdQZWVyQ29ubmVjdGlvbiIsInBjQ29uZmlnIiwicGNDb25zdHJhaW50cyIsImljZVNlcnZlcnMiLCJuZXdJY2VTZXJ2ZXJzIiwic2VydmVyIiwidXJscyIsInVybCIsImdlbmVyYXRlQ2VydGlmaWNhdGUiLCJzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyIiwic2hpbUNyZWF0ZU9mZmVyTGVnYWN5Iiwib2ZmZXJPcHRpb25zIiwib2ZmZXJUb1JlY2VpdmVBdWRpbyIsImF1ZGlvVHJhbnNjZWl2ZXIiLCJnZXRUcmFuc2NlaXZlcnMiLCJkaXJlY3Rpb24iLCJzZXREaXJlY3Rpb24iLCJvZmZlclRvUmVjZWl2ZVZpZGVvIiwidmlkZW9UcmFuc2NlaXZlciIsInNoaW1BdWRpb0NvbnRleHQiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzYWZhcmlTaGltIiwic2RwJDEiLCJTRFBVdGlscyIsImdlbmVyYXRlSWRlbnRpZmllciIsImxvY2FsQ05hbWUiLCJzcGxpdExpbmVzIiwiYmxvYiIsImxpbmUiLCJzcGxpdFNlY3Rpb25zIiwicGFydHMiLCJwYXJ0IiwiZ2V0RGVzY3JpcHRpb24iLCJzZWN0aW9ucyIsImdldE1lZGlhU2VjdGlvbnMiLCJtYXRjaFByZWZpeCIsInBhcnNlQ2FuZGlkYXRlIiwiZm91bmRhdGlvbiIsImNvbXBvbmVudCIsInByaW9yaXR5IiwiaXAiLCJwb3J0IiwicmVsYXRlZEFkZHJlc3MiLCJyZWxhdGVkUG9ydCIsInRjcFR5cGUiLCJ1ZnJhZyIsInVzZXJuYW1lRnJhZ21lbnQiLCJ3cml0ZUNhbmRpZGF0ZSIsInBhcnNlSWNlT3B0aW9ucyIsInBhcnNlUnRwTWFwIiwicGFyc2VkIiwicGF5bG9hZFR5cGUiLCJjaGFubmVscyIsIm51bUNoYW5uZWxzIiwid3JpdGVSdHBNYXAiLCJjb2RlYyIsInB0IiwicHJlZmVycmVkUGF5bG9hZFR5cGUiLCJwYXJzZUV4dG1hcCIsInVyaSIsImF0dHJpYnV0ZXMiLCJ3cml0ZUV4dG1hcCIsImhlYWRlckV4dGVuc2lvbiIsInByZWZlcnJlZElkIiwicGFyc2VGbXRwIiwia3YiLCJqIiwid3JpdGVGbXRwIiwicGFyYW1ldGVycyIsInBhcmFtIiwicGFyc2VSdGNwRmIiLCJwYXJhbWV0ZXIiLCJ3cml0ZVJ0Y3BGYiIsImxpbmVzIiwicnRjcEZlZWRiYWNrIiwiZmIiLCJwYXJzZVNzcmNNZWRpYSIsInNwIiwiY29sb24iLCJhdHRyaWJ1dGUiLCJwYXJzZVNzcmNHcm91cCIsInNlbWFudGljcyIsInNzcmNzIiwiZ2V0TWlkIiwibWVkaWFTZWN0aW9uIiwicGFyc2VGaW5nZXJwcmludCIsImFsZ29yaXRobSIsImdldER0bHNQYXJhbWV0ZXJzIiwic2Vzc2lvbnBhcnQiLCJyb2xlIiwiZmluZ2VycHJpbnRzIiwid3JpdGVEdGxzUGFyYW1ldGVycyIsInNldHVwVHlwZSIsImZwIiwicGFyc2VDcnlwdG9MaW5lIiwiY3J5cHRvU3VpdGUiLCJrZXlQYXJhbXMiLCJzZXNzaW9uUGFyYW1zIiwid3JpdGVDcnlwdG9MaW5lIiwid3JpdGVDcnlwdG9LZXlQYXJhbXMiLCJwYXJzZUNyeXB0b0tleVBhcmFtcyIsImtleU1ldGhvZCIsImtleVNhbHQiLCJsaWZlVGltZSIsIm1raVZhbHVlIiwibWtpTGVuZ3RoIiwiZ2V0Q3J5cHRvUGFyYW1ldGVycyIsImdldEljZVBhcmFtZXRlcnMiLCJwd2QiLCJwYXNzd29yZCIsIndyaXRlSWNlUGFyYW1ldGVycyIsImljZUxpdGUiLCJwYXJzZVJ0cFBhcmFtZXRlcnMiLCJoZWFkZXJFeHRlbnNpb25zIiwiZmVjTWVjaGFuaXNtcyIsInJ0Y3AiLCJtbGluZSIsInByb2ZpbGUiLCJydHBtYXBsaW5lIiwiZm10cHMiLCJ3aWxkY2FyZFJ0Y3BGYiIsImR1cGxpY2F0ZSIsImV4aXN0aW5nRmVlZGJhY2siLCJ3cml0ZVJ0cERlc2NyaXB0aW9uIiwiY2FwcyIsIm1heHB0aW1lIiwicGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMiLCJlbmNvZGluZ1BhcmFtZXRlcnMiLCJoYXNSZWQiLCJoYXNVbHBmZWMiLCJwcmltYXJ5U3NyYyIsInNlY29uZGFyeVNzcmMiLCJmbG93cyIsImFwdCIsImVuY1BhcmFtIiwiY29kZWNQYXlsb2FkVHlwZSIsInJ0eCIsImZlYyIsIm1lY2hhbmlzbSIsImJhbmR3aWR0aCIsIm1heEJpdHJhdGUiLCJwYXJzZVJ0Y3BQYXJhbWV0ZXJzIiwicnRjcFBhcmFtZXRlcnMiLCJyZW1vdGVTc3JjIiwiY25hbWUiLCJyc2l6ZSIsInJlZHVjZWRTaXplIiwiY29tcG91bmQiLCJtdXgiLCJ3cml0ZVJ0Y3BQYXJhbWV0ZXJzIiwicGFyc2VNc2lkIiwic3BlYyIsInBsYW5CIiwibXNpZFBhcnRzIiwicGFyc2VTY3RwRGVzY3JpcHRpb24iLCJwYXJzZU1MaW5lIiwibWF4U2l6ZUxpbmUiLCJtYXhNZXNzYWdlU2l6ZSIsInNjdHBQb3J0IiwiZm10Iiwic2N0cE1hcExpbmVzIiwid3JpdGVTY3RwRGVzY3JpcHRpb24iLCJtZWRpYSIsInNjdHAiLCJvdXRwdXQiLCJnZW5lcmF0ZVNlc3Npb25JZCIsInN1YnN0ciIsIndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlIiwic2Vzc0lkIiwic2Vzc1ZlciIsInNlc3NVc2VyIiwic2Vzc2lvbklkIiwidXNlciIsImdldERpcmVjdGlvbiIsImdldEtpbmQiLCJpc1JlamVjdGVkIiwicGFyc2VPTGluZSIsInVzZXJuYW1lIiwic2Vzc2lvblZlcnNpb24iLCJuZXRUeXBlIiwiYWRkcmVzc1R5cGUiLCJpc1ZhbGlkU0RQIiwic2RwRXhwb3J0cyIsInNoaW1SVENJY2VDYW5kaWRhdGUiLCJOYXRpdmVSVENJY2VDYW5kaWRhdGUiLCJuYXRpdmVDYW5kaWRhdGUiLCJwYXJzZWRDYW5kaWRhdGUiLCJzZHBNaWQiLCJzZHBNTGluZUluZGV4Iiwid3JpdGFibGUiLCJzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCIsInJlbGF5UHJvdG9jb2wiLCJzaGltTWF4TWVzc2FnZVNpemUiLCJfc2N0cCIsInNjdHBJbkRlc2NyaXB0aW9uIiwibUxpbmUiLCJnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiIsImdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSIsInJlbW90ZUlzRmlyZWZveCIsImNhblNlbmRNYXhNZXNzYWdlU2l6ZSIsImdldE1heE1lc3NhZ2VTaXplIiwiaXNGaXJlZm94IiwiY2FuU2VuZE1NUyIsInJlbW90ZU1NUyIsInNoaW1TZW5kVGhyb3dUeXBlRXJyb3IiLCJ3cmFwRGNTZW5kIiwiZGMiLCJvcmlnRGF0YUNoYW5uZWxTZW5kIiwic2VuZCIsInJlYWR5U3RhdGUiLCJvcmlnQ3JlYXRlRGF0YUNoYW5uZWwiLCJjcmVhdGVEYXRhQ2hhbm5lbCIsImRhdGFDaGFubmVsIiwiY2hhbm5lbCIsInNoaW1Db25uZWN0aW9uU3RhdGUiLCJjb21wbGV0ZWQiLCJjaGVja2luZyIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9yaWdNZXRob2QiLCJfY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSIsIl9sYXN0Q29ubmVjdGlvblN0YXRlIiwiY29ubmVjdGlvblN0YXRlIiwibmV3RXZlbnQiLCJyZW1vdmVFeHRtYXBBbGxvd01peGVkIiwibmF0aXZlU1JEIiwic2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5IiwibmF0aXZlQWRkSWNlQ2FuZGlkYXRlIiwic2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uIiwibmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiIsImNvbW1vblNoaW0iLCJhZGFwdGVyRmFjdG9yeSIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1TYWZhcmkiLCJhZGFwdGVyIiwiYnJvd3NlclNoaW0iLCJFTkNSWVBUSU9OX0FMR09SSVRITSIsIkRFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UiLCJFMkVFX0ZMQUciLCJTQUxUIiwiS0VZX1BST1ZJREVSX0RFRkFVTFRTIiwic2hhcmVkS2V5IiwicmF0Y2hldFNhbHQiLCJyYXRjaGV0V2luZG93U2l6ZSIsImZhaWx1cmVUb2xlcmFuY2UiLCJLZXlQcm92aWRlckV2ZW50IiwiS2V5SGFuZGxlckV2ZW50IiwiRW5jcnlwdGlvbkV2ZW50IiwiQ3J5cHRvckV2ZW50IiwiaXNFMkVFU3VwcG9ydGVkIiwiaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkIiwiaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQiLCJSVENSdHBTY3JpcHRUcmFuc2Zvcm0iLCJjcmVhdGVFbmNvZGVkU3RyZWFtcyIsImlzVmlkZW9GcmFtZSIsImZyYW1lIiwiaW1wb3J0S2V5Iiwia2V5Qnl0ZXMiLCJ1c2FnZSIsImNyeXB0byIsInN1YnRsZSIsImNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyIsImtleU1hdGVyaWFsIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyIiwiY3J5cHRvQnVmZmVyIiwiZ2V0QWxnb09wdGlvbnMiLCJhbGdvcml0aG1OYW1lIiwic2FsdCIsImVuY29kZWRTYWx0IiwiaGFzaCIsIml0ZXJhdGlvbnMiLCJkZXJpdmVLZXlzIiwibWF0ZXJpYWwiLCJhbGdvcml0aG1PcHRpb25zIiwiZW5jcnlwdGlvbktleSIsImRlcml2ZUtleSIsImNyZWF0ZUUyRUVLZXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYXRjaGV0IiwiZGVyaXZlQml0cyIsIm5lZWRzUmJzcFVuZXNjYXBpbmciLCJmcmFtZURhdGEiLCJwYXJzZVJic3AiLCJkYXRhT3V0Iiwia1plcm9zSW5TdGFydFNlcXVlbmNlIiwia0VtdWxhdGlvbkJ5dGUiLCJ3cml0ZVJic3AiLCJkYXRhX2luIiwibnVtQ29uc2VjdXRpdmVaZXJvcyIsIkJhc2VLZXlQcm92aWRlciIsIm9uS2V5UmF0Y2hldGVkIiwia2V5SW5kZXgiLCJrZXlJbmZvTWFwIiwiS2V5UmF0Y2hldGVkIiwib25TZXRFbmNyeXB0aW9uS2V5Iiwia2V5SW5mbyIsIlNldEtleSIsImdldEtleXMiLCJmcm9tIiwiZ2V0T3B0aW9ucyIsInJhdGNoZXRLZXkiLCJSYXRjaGV0UmVxdWVzdCIsIkV4dGVybmFsRTJFRUtleVByb3ZpZGVyIiwib3B0cyIsInNldEtleSIsImRlcml2ZWRLZXkiLCJMaXZla2l0RXJyb3IiLCJDb25uZWN0aW9uRXJyb3IiLCJyZWFzb24iLCJzdGF0dXMiLCJEZXZpY2VVbnN1cHBvcnRlZEVycm9yIiwiVHJhY2tJbnZhbGlkRXJyb3IiLCJVbnN1cHBvcnRlZFNlcnZlciIsIlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUiLCJOZWdvdGlhdGlvbkVycm9yIiwiUHVibGlzaERhdGFFcnJvciIsIk1lZGlhRGV2aWNlRmFpbHVyZSIsImdldEZhaWx1cmUiLCJOb3RGb3VuZCIsIlBlcm1pc3Npb25EZW5pZWQiLCJEZXZpY2VJblVzZSIsIk90aGVyIiwiUm9vbUV2ZW50IiwiUGFydGljaXBhbnRFdmVudCIsIkVuZ2luZUV2ZW50IiwiVHJhY2tFdmVudCIsImlzSW1tZWRpYXRlIiwidSIsImNhbGxiYWNrIiwibWF4V2FpdCIsImwiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsIiwiY29tbW9uVmVyc2lvbklkZW50aWZpZXIiLCJnZXRCcm93c2VyIiwiZm9yY2UiLCJ1YSIsImJyb3dzZXJzTGlzdCIsIl9yZWYiLCJkZXNjcmliZSIsImdldE1hdGNoIiwiZXhwIiwidmVyc2lvbiQxIiwicHJvdG9jb2xWZXJzaW9uIiwiQ3JpdGljYWxUaW1lcnMiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJWaWRlb1ByZXNldCIsImVuY29kaW5nIiwicmVzb2x1dGlvbiIsImFzcGVjdFJhdGlvIiwiYmFja3VwQ29kZWNzIiwidmlkZW9Db2RlY3MiLCJpc0JhY2t1cENvZGVjIiwiYmFja3VwIiwiQXVkaW9QcmVzZXRzIiwidGVsZXBob25lIiwic3BlZWNoIiwibXVzaWMiLCJtdXNpY1N0ZXJlbyIsIm11c2ljSGlnaFF1YWxpdHkiLCJtdXNpY0hpZ2hRdWFsaXR5U3RlcmVvIiwiVmlkZW9QcmVzZXRzIiwiaDkwIiwiaDE4MCIsImgyMTYiLCJoMzYwIiwiaDU0MCIsImg3MjAiLCJoMTA4MCIsImgxNDQwIiwiaDIxNjAiLCJWaWRlb1ByZXNldHM0MyIsImgxMjAiLCJoMjQwIiwiaDQ4MCIsIlNjcmVlblNoYXJlUHJlc2V0cyIsImgzNjBmcHMzIiwiaDcyMGZwczUiLCJoNzIwZnBzMTUiLCJoNzIwZnBzMzAiLCJoMTA4MGZwczE1IiwiaDEwODBmcHMzMCIsIlNpZ25hbFRhcmdldCIsIlN0cmVhbVN0YXRlIiwiQ2FuZGlkYXRlUHJvdG9jb2wiLCJTaWduYWxSZXF1ZXN0IiwiU2Vzc2lvbkRlc2NyaXB0aW9uIiwiVHJpY2tsZVJlcXVlc3QiLCJBZGRUcmFja1JlcXVlc3QiLCJNdXRlVHJhY2tSZXF1ZXN0IiwiVXBkYXRlU3Vic2NyaXB0aW9uIiwiVXBkYXRlVHJhY2tTZXR0aW5ncyIsIkxlYXZlUmVxdWVzdCIsIlVwZGF0ZVZpZGVvTGF5ZXJzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbiIsIlN5bmNTdGF0ZSIsIlNpbXVsYXRlU2NlbmFyaW8iLCJVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIiwiUGluZyIsIlNpZ25hbFJlc3BvbnNlIiwiSm9pblJlc3BvbnNlIiwiUGFydGljaXBhbnRVcGRhdGUiLCJUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIiwiU3BlYWtlcnNDaGFuZ2VkIiwiUm9vbVVwZGF0ZSIsIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwiU3RyZWFtU3RhdGVVcGRhdGUiLCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJUcmFja1VucHVibGlzaGVkUmVzcG9uc2UiLCJSZWNvbm5lY3RSZXNwb25zZSIsIlBvbmciLCJTdWJzY3JpcHRpb25SZXNwb25zZSIsIlNpbXVsY2FzdENvZGVjIiwic2ltdWxjYXN0Q29kZWNzIiwiY2FuZGlkYXRlSW5pdCIsIlBVQkxJU0hFUiIsIm90aGVyUGFydGljaXBhbnRzIiwic2VydmVyVmVyc2lvbiIsInN1YnNjcmliZXJQcmltYXJ5IiwiYWx0ZXJuYXRpdmVVcmwiLCJzZXJ2ZXJSZWdpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInNpZlRyYWlsZXIiLCJJQ0VTZXJ2ZXIiLCJ0cmFja1NpZCIsInBhcnRpY2lwYW50cyIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwiZGlzYWJsZWQiLCJmcHMiLCJjYW5SZWNvbm5lY3QiLCJVTktOT1dOX1JFQVNPTiIsImNyZWRlbnRpYWwiLCJDb25uZWN0aW9uUXVhbGl0eUluZm8iLCJQT09SIiwic2NvcmUiLCJ1cGRhdGVzIiwiU3RyZWFtU3RhdGVJbmZvIiwiQUNUSVZFIiwic3RyZWFtU3RhdGVzIiwiU3Vic2NyaWJlZFF1YWxpdHkiLCJTdWJzY3JpYmVkQ29kZWMiLCJxdWFsaXRpZXMiLCJzdWJzY3JpYmVkUXVhbGl0aWVzIiwic3Vic2NyaWJlZENvZGVjcyIsIlRyYWNrUGVybWlzc2lvbiIsImFsbFRyYWNrcyIsImFsbFBhcnRpY2lwYW50cyIsInRyYWNrUGVybWlzc2lvbnMiLCJhbGxvd2VkIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsIkRhdGFDaGFubmVsSW5mbyIsInNjZW5hcmlvIiwicnR0IiwibGFzdFBpbmdUaW1lc3RhbXAiLCJSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnMiLCJSZWdpb25JbmZvIiwiZGlzdGFuY2UiLCJTRV9VTktOT1dOIiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJhdHRhY2hlZEVsZW1lbnRzIiwiaXNNdXRlZCIsInN0cmVhbVN0YXRlIiwiQWN0aXZlIiwiaXNJbkJhY2tncm91bmQiLCJfY3VycmVudEJpdHJhdGUiLCJhcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyIiwiYmFja2dyb3VuZFRpbWVvdXQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCIsIl9tZWRpYVN0cmVhbVRyYWNrIiwiX21lZGlhU3RyZWFtSUQiLCJTb3VyY2UiLCJVbmtub3duIiwiY3VycmVudEJpdHJhdGUiLCJtZWRpYVN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1JRCIsImF0dGFjaCIsImVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIktpbmQiLCJWaWRlbyIsImFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJoYXNBdWRpbyIsInRyIiwicGxheSIsIkF1ZGlvUGxheWJhY2tTdGFydGVkIiwiVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJBdWRpb1BsYXliYWNrRmFpbGVkIiwiVmlkZW9QbGF5YmFja0ZhaWxlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZGlzYWJsZSIsIm1vbml0b3JJbnRlcnZhbCIsIkhUTUxBdWRpb0VsZW1lbnQiLCJzaG91bGRDYWNoZSIsInBhdXNlIiwiaXNXZWIiLCJtZWRpYVN0cmVhbSIsImV4aXN0aW5nVHJhY2tzIiwiZXQiLCJpc1NhZmFyaSIsIkhUTUxWaWRlb0VsZW1lbnQiLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwiaXNGaXJlRm94IiwiU3RyZWFtU3RhdGUkMSIsImtpbmRUb1Byb3RvIiwiQXVkaW8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIkNBTUVSQSIsIk1pY3JvcGhvbmUiLCJNSUNST1BIT05FIiwiU2NyZWVuU2hhcmUiLCJTQ1JFRU5fU0hBUkUiLCJTY3JlZW5TaGFyZUF1ZGlvIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQQVVTRUQiLCJQYXVzZWQiLCJtZXJnZURlZmF1bHRPcHRpb25zIiwiYXVkaW9EZWZhdWx0cyIsInZpZGVvRGVmYXVsdHMiLCJtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyIsIm1haW5PYmplY3QiLCJvYmplY3RUb01lcmdlIiwiY29uc3RyYWludHNGb3JPcHRpb25zIiwidmlkZW9PcHRpb25zIiwiZGV0ZWN0U2lsZW5jZSIsInRpbWVPZmZzZXQiLCJjdHgiLCJnZXROZXdBdWRpb0NvbnRleHQiLCJhbmFseXNlciIsImNyZWF0ZUFuYWx5c2VyIiwiZmZ0U2l6ZSIsImJ1ZmZlckxlbmd0aCIsImZyZXF1ZW5jeUJpbkNvdW50IiwiZGF0YUFycmF5IiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJjb25uZWN0Iiwic2xlZXAiLCJnZXRCeXRlVGltZURvbWFpbkRhdGEiLCJzb21lTm9pc2UiLCJzYW1wbGUiLCJjbG9zZSIsImxhdGVuY3lIaW50Iiwic291cmNlVG9LaW5kIiwic2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyIsInZpZGVvQ29uc3RyYWludHMiLCJjb250cm9sbGVyIiwic2VsZkJyb3dzZXJTdXJmYWNlIiwic3VyZmFjZVN3aXRjaGluZyIsInN5c3RlbUF1ZGlvIiwibWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmciLCJnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyIsImluZm9zIiwidHJhY2tJbmZvIiwic2VwYXJhdG9yIiwiZGRFeHRlbnNpb25VUkkiLCJ1bnBhY2tTdHJlYW1JZCIsInN1cHBvcnRzVHJhbnNjZWl2ZXIiLCJzdXBwb3J0c0FkZFRyYWNrIiwic3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSIsIlJlc2l6ZU9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJzdXBwb3J0c0R5bmFjYXN0Iiwic3VwcG9ydHNBVjEiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJoYXNBVjEiLCJzdXBwb3J0c1ZQOSIsImNvbXBhcmVWZXJzaW9ucyIsImhhc1ZQOSIsImlzU1ZDQ29kZWMiLCJzdXBwb3J0c1NldFNpbmtJZCIsInNldENvZGVjUHJlZmVyZW5jZXNWZXJzaW9ucyIsIkNocm9tZSIsIlNhZmFyaSIsIkZpcmVmb3giLCJzdXBwb3J0c1NldENvZGVjUHJlZmVyZW5jZXMiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc0Nocm9taXVtQmFzZWQiLCJpc01vYmlsZSIsImlzUmVhY3ROYXRpdmUiLCJwcm9kdWN0IiwiaXNDbG91ZCIsInNlcnZlclVybCIsImhvc3RuYW1lIiwiZ2V0TEtSZWFjdE5hdGl2ZUluZm8iLCJMaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwiLCJnZXRSZWFjdE5hdGl2ZU9zIiwicGxhdGZvcm0iLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInYxIiwidjIiLCJwYXJ0czEiLCJwYXJ0czIiLCJwMSIsInAyIiwicm9EaXNwYXRjaENhbGxiYWNrIiwiZW50cnkiLCJoYW5kbGVSZXNpemUiLCJpb0Rpc3BhdGNoQ2FsbGJhY2siLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCIsInJlc2l6ZU9ic2VydmVyIiwiZ2V0UmVzaXplT2JzZXJ2ZXIiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsImdldEludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdE1hcmdpbiIsImdldENsaWVudEluZm8iLCJKUyIsImVtcHR5VmlkZW9TdHJlYW1UcmFjayIsImdldEVtcHR5VmlkZW9TdHJlYW1UcmFjayIsImNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjayIsInBhaW50Q29udGVudCIsImNhbnZhcyIsImdldENvbnRleHQiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiY2xvc2VQYXRoIiwiZmlsbFN0eWxlIiwiZmlsbCIsImR1bW15U3RyZWFtIiwiY2FwdHVyZVN0cmVhbSIsImR1bW15VHJhY2siLCJlbXB0eUF1ZGlvU3RyZWFtVHJhY2siLCJnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2siLCJvc2NpbGxhdG9yIiwiY3JlYXRlT3NjaWxsYXRvciIsImdhaW4iLCJjcmVhdGVHYWluIiwic2V0VmFsdWVBdFRpbWUiLCJkc3QiLCJjcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uIiwiRnV0dXJlIiwiZnV0dXJlQmFzZSIsIm9uRmluYWxseSIsImNyZWF0ZUF1ZGlvQW5hbHlzZXIiLCJjbG9uZVRyYWNrIiwic21vb3RoaW5nVGltZUNvbnN0YW50IiwibWluRGVjaWJlbHMiLCJtYXhEZWNpYmVscyIsImF1ZGlvQ29udGV4dCIsInN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1Tb3VyY2UiLCJjYWxjdWxhdGVWb2x1bWUiLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsInN1bSIsImFtcGxpdHVkZSIsInBvdyIsInZvbHVtZSIsInNxcnQiLCJjbGVhbnVwIiwiTXV0ZXgiLCJfbG9ja2luZyIsIl9sb2NrcyIsImlzTG9ja2VkIiwibG9jayIsInVubG9ja05leHQiLCJ3aWxsTG9jayIsIndpbGxVbmxvY2siLCJpc1ZpZGVvQ29kZWMiLCJtYXliZUNvZGVjIiwidW53cmFwQ29uc3RyYWludCIsInRvV2Vic29ja2V0VXJsIiwic3RhcnRzV2l0aCIsInRvSHR0cFVybCIsImRlZmF1bHRJZCIsIkRldmljZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0RGV2aWNlcyIsInJlcXVlc3RQZXJtaXNzaW9ucyIsInVzZXJNZWRpYVByb21pc2VNYXAiLCJoYXNEZXZpY2VJblVzZSIsImlzRHVtbXlEZXZpY2VPckVtcHR5IiwiZGV2aWNlIiwibm9MYWJlbCIsImlzUmVsZXZhbnQiLCJwZXJtaXNzaW9uc1RvQWNxdWlyZSIsIm5vcm1hbGl6ZURldmljZUlkIiwiZ3JvdXBJZCIsIm1lZGlhRGV2aWNlS2luZHMiLCJkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQiLCJMb2NhbFRyYWNrIiwiX2NvbnN0cmFpbnRzIiwidXNlclByb3ZpZGVkVHJhY2siLCJfaXNVcHN0cmVhbVBhdXNlZCIsImhhbmRsZVRyYWNrTXV0ZUV2ZW50IiwiZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciIsInBhdXNlVXBzdHJlYW0iLCJoYW5kbGVUcmFja1VubXV0ZUV2ZW50IiwicmVzdW1lVXBzdHJlYW0iLCJoYW5kbGVFbmRlZCIsInJlYWNxdWlyZVRyYWNrIiwiRW5kZWQiLCJwcm92aWRlZEJ5VXNlciIsIm11dGVMb2NrIiwicGF1c2VVcHN0cmVhbUxvY2siLCJwcm9jZXNzb3JMb2NrIiwic2V0TWVkaWFTdHJlYW1UcmFjayIsImdldENvbnN0cmFpbnRzIiwiZGltZW5zaW9ucyIsImlzVXBzdHJlYW1QYXVzZWQiLCJpc1VzZXJQcm92aWRlZCIsInByb2Nlc3NvciIsInByb2Nlc3NlZFRyYWNrIiwibmV3VHJhY2siLCJlbCIsInByb2Nlc3NvckVsZW1lbnQiLCJyZXN0YXJ0IiwicmVwbGFjZVRyYWNrIiwid2FpdEZvckRpbWVuc2lvbnMiLCJ0aW1lb3V0Iiwic3RhcnRlZCIsImRpbXMiLCJnZXREZXZpY2VJZCIsIm11dGUiLCJzZXRUcmFja011dGVkIiwidW5tdXRlIiwic3RvcFByb2Nlc3NvciIsInN0cmVhbUNvbnN0cmFpbnRzIiwiUmVzdGFydGVkIiwiTXV0ZWQiLCJVbm11dGVkIiwibmVlZHNSZUFjcXVpc2l0aW9uIiwiX3N1cGVyIiwiZGVzdHJveSIsInVubG9jayIsIlVwc3RyZWFtUGF1c2VkIiwiVXBzdHJlYW1SZXN1bWVkIiwiZ2V0UlRDU3RhdHNSZXBvcnQiLCJzdGF0c1JlcG9ydCIsInNldFByb2Nlc3NvciIsInNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5IiwicHJvY2Vzc29yT3B0aW9ucyIsImdldFByb2Nlc3NvciIsInJlbW92ZSIsIkUyRUVNYW5hZ2VyIiwib25Xb3JrZXJNZXNzYWdlIiwiZXYiLCJFbmNyeXB0aW9uRXJyb3IiLCJrZXlQcm92aWRlciIsInBvc3RLZXkiLCJlbmNyeXB0aW9uRW5hYmxlZCIsInJvb20iLCJsb2NhbFBhcnRpY2lwYW50IiwiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCIsInBhcnRpY2lwYW50IiwiZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5Iiwib25Xb3JrZXJFcnJvciIsIndvcmtlciIsInNldHVwIiwic2V0dXBFdmVudExpc3RlbmVycyIsImtleVByb3ZpZGVyT3B0aW9ucyIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJwb3N0TWVzc2FnZSIsInNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQiLCJwb3N0RW5hYmxlIiwic2V0U2lmVHJhaWxlciIsInRyYWlsZXIiLCJwb3N0U2lmVHJhaWxlciIsInNldHVwRW5naW5lIiwiZW5naW5lIiwiUlRQVmlkZW9NYXBVcGRhdGUiLCJydHBNYXAiLCJwb3N0UlRQTWFwIiwiVHJhY2tQdWJsaXNoZWQiLCJwdWIiLCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkIiwiQ29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGVkIiwiVHJhY2tVbnN1YnNjcmliZWQiLCJfIiwiVHJhY2tTdWJzY3JpYmVkIiwic2V0dXBFMkVFUmVjZWl2ZXIiLCJTaWduYWxDb25uZWN0ZWQiLCJpc0UyRUVFbmFibGVkIiwiTG9jYWxUcmFja1B1Ymxpc2hlZCIsInB1YmxpY2F0aW9uIiwic2V0dXBFMkVFU2VuZGVyIiwicGFydGljaXBhbnRJZCIsInBvc3RSYXRjaGV0UmVxdWVzdCIsImVuYWJsZU1zZyIsIlJlZmVyZW5jZUVycm9yIiwicmVtb3RlSWQiLCJoYW5kbGVSZWNlaXZlciIsImhhbmRsZVNlbmRlciIsInRyYW5zZm9ybSIsIndyaXRhYmxlU3RyZWFtIiwicmVhZGFibGUiLCJyZWFkYWJsZVN0cmVhbSIsInJlY2VpdmVyU3RyZWFtcyIsInNlbmRlclN0cmVhbXMiLCJRdWV1ZVRhc2tTdGF0dXMiLCJBc3luY1F1ZXVlIiwicGVuZGluZ1Rhc2tzIiwidGFza011dGV4IiwibmV4dFRhc2tJbmRleCIsInJ1biIsInRhc2siLCJ0YXNrSW5mbyIsImVucXVldWVkQXQiLCJXQUlUSU5HIiwiZXhlY3V0ZWRBdCIsIlJVTk5JTkciLCJDT01QTEVURUQiLCJmbHVzaCIsInNuYXBzaG90IiwicGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMiLCJjYW5QYXNzVGhyb3VnaFF1ZXVlIiwicmVxIiwiY2FuUGFzcyIsIlNpZ25hbENvbm5lY3Rpb25TdGF0ZSIsIlNpZ25hbENsaWVudCIsImN1cnJlbnRTdGF0ZSIsImlzRGlzY29ubmVjdGVkIiwiRElTQ09OTkVDVElORyIsIkRJU0NPTk5FQ1RFRCIsInVzZUpTT04iLCJyZXNldENhbGxiYWNrcyIsIm9uQW5zd2VyIiwib25MZWF2ZSIsIm9uTG9jYWxUcmFja1B1Ymxpc2hlZCIsIm9uTG9jYWxUcmFja1VucHVibGlzaGVkIiwib25OZWdvdGlhdGVSZXF1ZXN0ZWQiLCJvbk9mZmVyIiwib25SZW1vdGVNdXRlQ2hhbmdlZCIsIm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJvblRva2VuUmVmcmVzaCIsIm9uVHJpY2tsZSIsIm9uQ2xvc2UiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwiQ09OTkVDVElORyIsInJlcyIsInJlY29ubmVjdCIsIlJFQ09OTkVDVElORyIsImNsZWFyUGluZ0ludGVydmFsIiwicmVjb25uZWN0UmVhc29uIiwiY29ubmVjdE9wdGlvbnMiLCJjbGllbnRJbmZvIiwiY3JlYXRlQ29ubmVjdGlvblBhcmFtcyIsImFib3J0SGFuZGxlciIsIndzVGltZW91dCIsIndlYnNvY2tldFRpbWVvdXQiLCJhYm9ydGVkIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwiQ09OTkVDVEVEIiwicmVzcCIsImZldGNoIiwidG9GaXhlZCIsInRleHQiLCJoYW5kbGVXU0Vycm9yIiwic2hvdWxkUHJvY2Vzc01lc3NhZ2UiLCJwaW5nVGltZW91dER1cmF0aW9uIiwicGluZ0ludGVydmFsRHVyYXRpb24iLCJpbnRlcnZhbCIsInN0YXJ0UGluZ0ludGVydmFsIiwic2lnbmFsTGF0ZW5jeSIsImhhbmRsZVNpZ25hbFJlc3BvbnNlIiwib25jbG9zZSIsImhhbmRsZU9uQ2xvc2UiLCJjbG9zZVByb21pc2UiLCJDTE9TSU5HIiwicmFjZSIsInNlbmRPZmZlciIsIm9mZmVyIiwic2VuZFJlcXVlc3QiLCJ0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwic2VuZEFuc3dlciIsImFuc3dlciIsInNlbmRJY2VDYW5kaWRhdGUiLCJzZW5kTXV0ZVRyYWNrIiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YiIsInNlbmRTeW5jU3RhdGUiLCJzeW5jIiwic2VuZFVwZGF0ZVZpZGVvTGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwic2VuZFNpbXVsYXRlU2NlbmFyaW8iLCJzZW5kUGluZyIsInNlbmRMZWF2ZSIsIkNMSUVOVF9JTklUSUFURUQiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsIk9QRU4iLCJwaW5nSGFuZGxlZCIsInNkIiwiZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwib25QYXJ0aWNpcGFudFVwZGF0ZSIsIm9uU3BlYWtlcnNDaGFuZ2VkIiwib25Sb29tVXBkYXRlIiwib25Db25uZWN0aW9uUXVhbGl0eSIsIm9uU3RyZWFtU3RhdGVVcGRhdGUiLCJvblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJvblN1YnNjcmlwdGlvbkVycm9yIiwicmVzZXRQaW5nVGltZW91dCIsInNldFJlY29ubmVjdGVkIiwib25DbG9zZUNhbGxiYWNrIiwiY2xlYXJQaW5nVGltZW91dCIsInRvVVRDU3RyaW5nIiwicnNkIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXV0b1N1YnNjcmliZSIsInB1Ymxpc2hPbmx5IiwiYWRhcHRpdmVTdHJlYW0iLCJjb25uZWN0aW9uIiwicGFyc2VyJDEiLCJncmFtbWFyJDIiLCJncmFtbWFyJDEiLCJyZWciLCJyYXRlIiwic3VidHlwZSIsImNvbmZpZyIsInNlc3Npb25Db25maWciLCJzdHIiLCJyYWRkciIsInRjcHR5cGUiLCJnZW5lcmF0aW9uIiwiZGlyMiIsImNsa3NyY0V4dCIsIm1lZGlhQ2xvY2tWYWx1ZSIsInJhdGVOdW1lcmF0b3IiLCJyYXRlRGVub21pbmF0b3IiLCJvYmpzIiwiZ3JhbW1hckV4cG9ydHMiLCJ0b0ludElmSW50IiwiYXR0YWNoUHJvcGVydGllcyIsInJhd05hbWUiLCJwYXJzZVJlZyIsImNvbnRlbnQiLCJuZWVkc0JsYW5rIiwia2V5TG9jYXRpb24iLCJncmFtbWFyIiwidmFsaWRMaW5lIiwic2Vzc2lvbiIsInJ0cCIsImZtdHAiLCJwYXJhbVJlZHVjZXIiLCJhY2MiLCJwYXJzZVBhcmFtcyIsInBhcnNlRm10cENvbmZpZyIsInBhcnNlUGF5bG9hZHMiLCJwYXJzZVJlbW90ZUNhbmRpZGF0ZXMiLCJjYW5kaWRhdGVzIiwicGFyc2VJbWFnZUF0dHJpYnV0ZXMiLCJwYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QiLCJzY2lkIiwicGF1c2VkIiwiZm9ybWF0UmVnRXhwIiwiZm9ybWF0U3RyIiwibWFrZUxpbmUiLCJkZWZhdWx0T3V0ZXJPcmRlciIsImRlZmF1bHRJbm5lck9yZGVyIiwid3JpdGVyJDEiLCJwYXlsb2FkcyIsIm91dGVyT3JkZXIiLCJpbm5lck9yZGVyIiwicGFyc2VyIiwid3JpdGUiLCJzdGFydEJpdHJhdGVGb3JTVkMiLCJQQ0V2ZW50cyIsIk5lZ290aWF0aW9uU3RhcnRlZCIsIk5lZ290aWF0aW9uQ29tcGxldGUiLCJSVFBWaWRlb1BheWxvYWRUeXBlcyIsIlBDVHJhbnNwb3J0IiwiY3JlYXRlUEMiLCJtZWRpYUNvbnN0cmFpbnRzIiwicGVuZGluZ0NhbmRpZGF0ZXMiLCJyZXN0YXJ0aW5nSWNlIiwicmVuZWdvdGlhdGUiLCJ0cmFja0JpdHJhdGVzIiwicmVtb3RlU3RlcmVvTWlkcyIsInJlbW90ZU5hY2tNaWRzIiwibmVnb3RpYXRlIiwiY3JlYXRlQW5kU2VuZE9mZmVyIiwib25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UiLCJvbmRhdGFjaGFubmVsIiwib25uZWdvdGlhdGlvbm5lZWRlZCIsIm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UiLCJvbmljZWNhbmRpZGF0ZSIsIm9udHJhY2siLCJvbkljZUNhbmRpZGF0ZSIsIm9uaWNlY2FuZGlkYXRlZXJyb3IiLCJvbkljZUNhbmRpZGF0ZUVycm9yIiwib25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvblNpZ25hbGluZ1N0YXRlY2hhbmdlIiwib25Db25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbkRhdGFDaGFubmVsIiwib25UcmFjayIsImlzSUNFQ29ubmVjdGVkIiwicmVtb3RlRGVzY3JpcHRpb24iLCJtdW5nZWRTRFAiLCJzdGVyZW9NaWRzIiwibmFja01pZHMiLCJleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyIiwic2RwUGFyc2VkIiwidHJhY2ticiIsImNvZGVjUGF5bG9hZCIsImZtdHBGb3VuZCIsImF0dHIiLCJtYXhiciIsInNldE11bmdlZFNEUCIsImljZVJlc3RhcnQiLCJjdXJyZW50U0QiLCJlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8iLCJlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDIiwibXNpZCIsInJvdW5kIiwiY3JlYXRlQW5kU2V0QW5zd2VyIiwiZGF0YUNoYW5uZWxEaWN0IiwidHJhbnNjZWl2ZXJJbml0Iiwic2V0VHJhY2tDb2RlY0JpdHJhdGUiLCJzZXRDb25maWd1cmF0aW9uIiwicnRjQ29uZmlnIiwiY2FuUmVtb3ZlVHJhY2siLCJnZXRDb25uZWN0aW9uU3RhdGUiLCJnZXRJQ0VDb25uZWN0aW9uU3RhdGUiLCJnZXRTaWduYWxsaW5nU3RhdGUiLCJnZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImdldFJlbW90ZURlc2NyaXB0aW9uIiwiZ2V0Q29ubmVjdGVkQWRkcmVzcyIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY2FuZGlkYXRlUGFpcnMiLCJzZWxlY3RlZCIsInNlbGVjdGVkSUQiLCJyZW1vdGVDYW5kaWRhdGVJZCIsIm11bmdlZCIsInJlbW90ZSIsIm9yaWdpbmFsU2RwIiwicmVtb3RlU2RwIiwib3B1c1BheWxvYWQiLCJydGNwRmIiLCJtYXhJRCIsImRkRm91bmQiLCJleHQiLCJkZWZhdWx0VmlkZW9Db2RlYyIsInB1Ymxpc2hEZWZhdWx0cyIsImF1ZGlvQml0cmF0ZSIsImF1ZGlvUHJlc2V0IiwiZHR4IiwicmVkIiwiZm9yY2VTdGVyZW8iLCJzY3JlZW5TaGFyZUVuY29kaW5nIiwic3RvcE1pY1RyYWNrT25NdXRlIiwidmlkZW9Db2RlYyIsImJhY2t1cENvZGVjIiwiYXV0b0dhaW5Db250cm9sIiwiZWNob0NhbmNlbGxhdGlvbiIsIm5vaXNlU3VwcHJlc3Npb24iLCJyb29tT3B0aW9uRGVmYXVsdHMiLCJkeW5hY2FzdCIsInN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2giLCJyZWNvbm5lY3RQb2xpY3kiLCJkaXNjb25uZWN0T25QYWdlTGVhdmUiLCJleHBXZWJBdWRpb01peCIsInJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMiLCJtYXhSZXRyaWVzIiwicGVlckNvbm5lY3Rpb25UaW1lb3V0IiwiUENUcmFuc3BvcnRTdGF0ZSIsIlBDVHJhbnNwb3J0TWFuYWdlciIsIm5lZWRzUHVibGlzaGVyIiwiaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJuZWVkc1N1YnNjcmliZXIiLCJpc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJ1cGRhdGVTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TRUQiLCJORVciLCJvblN0YXRlQ2hhbmdlIiwicHVibGlzaGVyIiwic3Vic2NyaWJlciIsImdvb2dDb25zdHJhaW50cyIsImdvb2dEc2NwIiwiU1VCU0NSSUJFUiIsIm9uUHVibGlzaGVyT2ZmZXIiLCJyZXF1aXJlUHVibGlzaGVyIiwicmVxdWlyZSIsInJlcXVpcmVTdWJzY3JpYmVyIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInVwZGF0ZUNvbmZpZ3VyYXRpb24iLCJlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24iLCJhYm9ydENvbnRyb2xsZXIiLCJ0cmFuc3BvcnQiLCJlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQiLCJuZWdvdGlhdGlvblRpbWVvdXQiLCJzaWduYWwiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsImxvc3N5RGF0YUNoYW5uZWwiLCJyZWxpYWJsZURhdGFDaGFubmVsIiwibWluUmVjb25uZWN0V2FpdCIsImxlYXZlUmVjb25uZWN0IiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsImlzQ2xvc2VkIiwiX2lzQ2xvc2VkIiwiZnVsbFJlY29ubmVjdE9uTmV4dCIsInBjU3RhdGUiLCJOZXciLCJwZW5kaW5nVHJhY2tSZXNvbHZlcnMiLCJyZWNvbm5lY3RBdHRlbXB0cyIsInJlY29ubmVjdFN0YXJ0IiwiYXR0ZW1wdGluZ1JlY29ubmVjdCIsImpvaW5BdHRlbXB0cyIsIm1heEpvaW5BdHRlbXB0cyIsInNob3VsZEZhaWxOZXh0IiwiaGFuZGxlRGF0YUNoYW5uZWwiLCJyZWxpYWJsZURDU3ViIiwibG9zc3lEQ1N1YiIsImhhbmRsZURhdGFNZXNzYWdlIiwiZGF0YVByb2Nlc3NMb2NrIiwiQmxvYiIsImFycmF5QnVmZmVyIiwiZHAiLCJBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsIkRhdGFQYWNrZXRSZWNlaXZlZCIsImhhbmRsZURhdGFFcnJvciIsImN1cnJlbnRUYXJnZXQiLCJjaGFubmVsS2luZCIsIm1heFJldHJhbnNtaXRzIiwiRXJyb3JFdmVudCIsImhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93IiwiTE9TU1kiLCJ1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMiLCJoYW5kbGVEaXNjb25uZWN0IiwiZGlzY29ubmVjdFJlYXNvbiIsImRpc2Nvbm5lY3QiLCJEaXNjb25uZWN0ZWQiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiZWxhcHNlZE1zIiwiY2xlYXJSZWNvbm5lY3RUaW1lb3V0IiwicmVnaW9uVXJsUHJvdmlkZXIiLCJ1cGRhdGVUb2tlbiIsInJlY29ubmVjdFRpbWVvdXQiLCJhdHRlbXB0UmVjb25uZWN0Iiwid2FpdEZvclJlc3RhcnRlZCIsIm9uUmVzdGFydGVkIiwib25EaXNjb25uZWN0ZWQiLCJpc0J1ZmZlclN0YXR1c0xvdyIsImRjQnVmZmVyU3RhdHVzIiwiRENCdWZmZXJTdGF0dXNDaGFuZ2VkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiYnVmZmVyZWRBbW91bnQiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImhhbmRsZUJyb3dzZXJPbkxpbmUiLCJjbGllbnQiLCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJ1cGRhdGUiLCJTdHJlYW1TdGF0ZUNoYW5nZWQiLCJzaWduYWxPcHRzIiwic2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MiLCJqb2luUmVzcG9uc2UiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJwY01hbmFnZXIiLCJjb25maWd1cmUiLCJjbGllbnRDb25maWd1cmF0aW9uIiwiQ2xvc2luZyIsImRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lciIsImNsZWFyUGVuZGluZ1JlY29ubmVjdCIsImNsZWFudXBQZWVyQ29ubmVjdGlvbnMiLCJjbGVhbnVwQ2xpZW50IiwiZGNDbGVhbnVwIiwib25idWZmZXJlZGFtb3VudGxvdyIsIm9uY2xvc2luZyIsImxvc3N5REMiLCJyZWxpYWJsZURDIiwicHVibGljYXRpb25UaW1lb3V0IiwidXBkYXRlTXV0ZVN0YXR1cyIsImRhdGFTdWJzY3JpYmVyUmVhZHlTdGF0ZSIsImdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MiLCJzZXRSZWdpb25VcmxQcm92aWRlciIsInByb3ZpZGVyIiwibWFrZVJUQ0NvbmZpZ3VyYXRpb24iLCJUcmFuc3BvcnRzQ3JlYXRlZCIsInB1Ymxpc2hlclN0YXRlIiwic3Vic2NyaWJlclN0YXRlIiwic2hvdWxkRW1pdCIsIlJSX1NVQlNDUklCRVJfRkFJTEVEIiwiUlJfUFVCTElTSEVSX0ZBSUxFRCIsIk1lZGlhVHJhY2tBZGRlZCIsImNyZWF0ZURhdGFDaGFubmVscyIsIlJlbW90ZU11dGUiLCJsZWF2ZSIsInNlcnZlclJlc3BvbnNlIiwiZTJlZUVuYWJsZWQiLCJlbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMiLCJydGNJY2VTZXJ2ZXJzIiwiaWNlU2VydmVyIiwicnRjSWNlU2VydmVyIiwiRU5BQkxFRCIsImljZVRyYW5zcG9ydFBvbGljeSIsImNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSIsIm9yZGVyZWQiLCJzZXRQcmVmZXJyZWRDb2RlYyIsImNhcCIsIm1hdGNoZWQiLCJwYXJ0aWFsTWF0Y2hlZCIsInVubWF0Y2hlZCIsIm1hdGNoZXNWaWRlb0NvZGVjIiwic2RwRm10cExpbmUiLCJzZXRDb2RlY1ByZWZlcmVuY2VzIiwiY3JlYXRlU2VuZGVyIiwiY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIiLCJjcmVhdGVSVENSdHBTZW5kZXIiLCJjcmVhdGVTaW11bGNhc3RTZW5kZXIiLCJzaW11bGNhc3RUcmFjayIsImNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyIiwic2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIiLCJESVNBQkxFRCIsInJlc3RhcnRDb25uZWN0aW9uIiwicmVjb3ZlcmFibGUiLCJTaWduYWxSZWNvbm5lY3RFcnJvciIsIlJSX1VOS05PV04iLCJyZWdpb25VcmwiLCJSZXN0YXJ0aW5nIiwiU2lnbmFsUmVzdGFydGVkIiwid2FpdEZvclBDUmVjb25uZWN0ZWQiLCJyZXNldEF0dGVtcHRzIiwibmV4dFJlZ2lvblVybCIsImdldE5leHRCZXN0UmVnaW9uVXJsIiwiUmVzdW1pbmciLCJTaWduYWxSZXN1bWVkIiwiUmVzdW1lZCIsIndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uIiwiUmVjb25uZWN0aW5nIiwic2VuZERhdGFQYWNrZXQiLCJwYWNrZXQiLCJlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQiLCJlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkIiwidHJhbnNwb3J0TmFtZSIsInRhcmdldENoYW5uZWwiLCJlbmRUaW1lIiwidmVyaWZ5VHJhbnNwb3J0IiwiQWJvcnRDb250cm9sbGVyIiwiaGFuZGxlQ2xvc2VkIiwiYWJvcnQiLCJydHBUeXBlcyIsInJlbW90ZVRyYWNrcyIsImxvY2FsVHJhY2tzIiwicHJldmlvdXNBbnN3ZXIiLCJwcmV2aW91c09mZmVyIiwiaXNEZXNpcmVkIiwic3Vic2NyaXB0aW9uIiwiZGF0YUNoYW5uZWxzSW5mbyIsImZhaWxOZXh0IiwiZ2V0SW5mbyIsIlJlZ2lvblVybFByb3ZpZGVyIiwibGFzdFVwZGF0ZUF0Iiwic2V0dGluZ3NDYWNoZVRpbWUiLCJhdHRlbXB0ZWRSZWdpb25zIiwiVVJMIiwiZ2V0U2VydmVyVXJsIiwicmVnaW9uU2V0dGluZ3MiLCJmZXRjaFJlZ2lvblNldHRpbmdzIiwicmVnaW9uc0xlZnQiLCJhdHRlbXB0ZWQiLCJuZXh0UmVnaW9uIiwicmVnaW9uU2V0dGluZ3NSZXNwb25zZSIsImdldENsb3VkQ29uZmlnVXJsIiwiaGVhZGVycyIsImF1dGhvcml6YXRpb24iLCJzdGF0dXNUZXh0IiwiaG9zdCIsIm1vbml0b3JGcmVxdWVuY3kiLCJjb21wdXRlQml0cmF0ZSIsImN1cnJlbnRTdGF0cyIsInByZXZTdGF0cyIsImJ5dGVzTm93IiwiYnl0ZXNQcmV2IiwiYnl0ZXNSZWNlaXZlZCIsImJ5dGVzU2VudCIsIkxvY2FsQXVkaW9UcmFjayIsInN0b3BPbk11dGUiLCJtb25pdG9yU2VuZGVyIiwiZ2V0U2VuZGVyU3RhdHMiLCJjaGVja0ZvclNpbGVuY2UiLCJzZXREZXZpY2VJZCIsInJlc3RhcnRUcmFjayIsImRldmljZUhhc0NoYW5nZWQiLCJzdGFydE1vbml0b3IiLCJzZXRBdWRpb0NvbnRleHQiLCJhdWRpb1N0YXRzIiwicGFja2V0c1NlbnQiLCJyb3VuZFRyaXBUaW1lIiwiaml0dGVyIiwidHJhY2tJc1NpbGVudCIsIkF1ZGlvU2lsZW5jZURldGVjdGVkIiwibWVkaWFUcmFja1RvTG9jYWxUcmFjayIsIkxvY2FsVmlkZW9UcmFjayIsInByZXNldHMxNjkiLCJwcmVzZXRzNDMiLCJwcmVzZXRzU2NyZWVuU2hhcmUiLCJkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMiLCJjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyIsImZyb21QcmVzZXQiLCJ2aWRlb1JpZHMiLCJjb21wdXRlVmlkZW9FbmNvZGluZ3MiLCJpc1NjcmVlblNoYXJlIiwidmlkZW9FbmNvZGluZyIsInVzZVNpbXVsY2FzdCIsInNjYWxhYmlsaXR5TW9kZSIsImRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmciLCJvcmlnaW5hbCIsInNtIiwiU2NhbGFiaWxpdHlNb2RlIiwic3BhdGlhbCIsInByZXNldHMiLCJzb3J0UHJlc2V0cyIsInNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzIiwiZGVmYXVsdFNpbXVsY2FzdExheWVycyIsInZpZGVvU2ltdWxjYXN0TGF5ZXJzIiwibWlkUHJlc2V0IiwibG93UHJlc2V0IiwiZW5jb2RpbmdzRnJvbVByZXNldHMiLCJjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MiLCJzZXJ2ZXJSZXF1ZXN0ZWQiLCJwcmVzZXRzRm9yUmVzb2x1dGlvbiIsInByZXNldCIsImFzcGVjdCIsImFicyIsImNhblNldFByaW9yaXR5IiwibmV0d29ya1ByaW9yaXR5IiwidG9wRnJhbWVyYXRlIiwibm90aWZ5T25jZSIsImFFbmMiLCJiRW5jIiwicmVzdWx0cyIsInRlbXBvcmFsIiwic3VmZml4IiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsImVfMSIsIl9lIiwiX2YiLCJfZyIsInNjIiwiZV8xXzEiLCJyZXR1cm4iLCJlXzIiLCJlXzJfMSIsIml0ZW1zIiwidnMiLCJmcmFtZUhlaWdodCIsImZyYW1lV2lkdGgiLCJmaXJDb3VudCIsInBsaUNvdW50IiwibmFja0NvdW50IiwiZnJhbWVzU2VudCIsInJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCIsInF1YWxpdHlMaW1pdGF0aW9uUmVhc29uIiwicXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlcyIsInNldFB1Ymxpc2hpbmdRdWFsaXR5IiwibWF4UXVhbGl0eSIsInEiLCJISUdIIiwic2V0UHVibGlzaGluZ0xheWVycyIsImVfMyIsImVfM18xIiwiZV80IiwiX2giLCJlXzRfMSIsImFkZFNpbXVsY2FzdFRyYWNrIiwic2ltdWxjYXN0Q29kZWNJbmZvIiwic2V0UHVibGlzaGluZ0NvZGVjcyIsImNvZGVjc18xIiwiY29kZWNzXzFfMSIsImVfNSIsImN1cnJlbnRDb2RlYyIsIm5ld0NvZGVjcyIsInNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIiLCJlXzVfMSIsInNlbmRlckVuY29kaW5ncyIsImhhc0NoYW5nZWQiLCJjbG9zYWJsZVNwYXRpYWwiLCJ2aWRlb1F1YWxpdHlGb3JSaWQiLCJzdWJzY3JpYmVkUXVhbGl0eSIsIk1FRElVTSIsInZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyIsInN2YyIsImVuY29kaW5nU00iLCJzY2FsZSIsIlJlbW90ZVRyYWNrIiwic2V0TXV0ZWQiLCJzZXRNZWRpYVN0cmVhbSIsIm9uUmVtb3ZlVHJhY2siLCJtb25pdG9yUmVjZWl2ZXIiLCJSZW1vdGVBdWRpb1RyYWNrIiwiYXVkaW9PdXRwdXQiLCJnZXRSZWNlaXZlclN0YXRzIiwid2ViQXVkaW9QbHVnaW5Ob2RlcyIsInNpbmtJZCIsInNldFZvbHVtZSIsImdhaW5Ob2RlIiwic2V0VGFyZ2V0QXRUaW1lIiwiX3NldFZvbHVtZSIsImVsZW1lbnRWb2x1bWUiLCJnZXRWb2x1bWUiLCJoaWdoZXN0Vm9sdW1lIiwic2V0U2lua0lkIiwibmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24iLCJjb25uZWN0V2ViQXVkaW8iLCJkaXNjb25uZWN0V2ViQXVkaW8iLCJzZXRXZWJBdWRpb1BsdWdpbnMiLCJub2RlcyIsInNvdXJjZU5vZGUiLCJsYXN0Tm9kZSIsIm5vZGUiLCJkZXN0aW5hdGlvbiIsInJlc3VtZSIsInJlY2VpdmVyU3RhdHMiLCJjb25jZWFsZWRTYW1wbGVzIiwiY29uY2VhbG1lbnRFdmVudHMiLCJzaWxlbnRDb25jZWFsZWRTYW1wbGVzIiwic2lsZW50Q29uY2VhbG1lbnRFdmVudHMiLCJ0b3RhbEF1ZGlvRW5lcmd5IiwidG90YWxTYW1wbGVzRHVyYXRpb24iLCJSRUFDVElPTl9ERUxBWSIsIlJlbW90ZVZpZGVvVHJhY2siLCJhZGFwdGl2ZVN0cmVhbVNldHRpbmdzIiwiZWxlbWVudEluZm9zIiwiZGVib3VuY2VkSGFuZGxlUmVzaXplIiwidXBkYXRlRGltZW5zaW9ucyIsImlzQWRhcHRpdmVTdHJlYW0iLCJlbGVtZW50SW5mbyIsIkhUTUxFbGVtZW50SW5mbyIsIm9ic2VydmVFbGVtZW50SW5mbyIsInVwZGF0ZVZpc2liaWxpdHkiLCJvYnNlcnZlIiwic3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvIiwic3RvcEVsZW1lbnRJbmZvcyIsInN0b3BPYnNlcnZpbmciLCJkZXRhY2hlZEVsZW1lbnRzIiwic3RvcE9ic2VydmluZ0VsZW1lbnQiLCJnZXREZWNvZGVySW1wbGVtZW50YXRpb24iLCJkZWNvZGVySW1wbGVtZW50YXRpb24iLCJjb2RlY0lEIiwiY29kZWNJZCIsImZyYW1lc0RlY29kZWQiLCJmcmFtZXNEcm9wcGVkIiwiZnJhbWVzUmVjZWl2ZWQiLCJwYWNrZXRzUmVjZWl2ZWQiLCJsYXN0VmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlDaGFuZ2VkQXQiLCJiYWNrZ3JvdW5kUGF1c2UiLCJwYXVzZVZpZGVvSW5CYWNrZ3JvdW5kIiwiaXNQaVBNb2RlIiwicGljdHVyZUluUGljdHVyZSIsImlzVmlzaWJsZSIsInZpc2libGUiLCJsYXN0VmlzaWJsZSIsIlZpc2liaWxpdHlDaGFuZ2VkIiwicGl4ZWxEZW5zaXR5IiwiZ2V0UGl4ZWxEZW5zaXR5IiwiY3VycmVudEVsZW1lbnRXaWR0aCIsImN1cnJlbnRFbGVtZW50SGVpZ2h0IiwibGFzdERpbWVuc2lvbnMiLCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkIiwiaXNQaVAiLCJpc0ludGVyc2VjdGluZyIsIm9uVmlzaWJpbGl0eUNoYW5nZWQiLCJvbkVudGVyUGlQIiwib25MZWF2ZVBpUCIsImlzRWxlbWVudEluVmlld3BvcnQiLCJwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidW5vYnNlcnZlIiwidG9wIiwib2Zmc2V0VG9wIiwibGVmdCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsIm9wYWNpdHkiLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9mZnNldFBhcmVudCIsInBhZ2VZT2Zmc2V0IiwiaW5uZXJIZWlnaHQiLCJwYWdlWE9mZnNldCIsImlubmVyV2lkdGgiLCJUcmFja1B1YmxpY2F0aW9uIiwibWV0YWRhdGFNdXRlZCIsImhhbmRsZU11dGVkIiwiaGFuZGxlVW5tdXRlZCIsInRyYWNrTmFtZSIsInNldFRyYWNrIiwiaXNFbmFibGVkIiwiaXNTdWJzY3JpYmVkIiwiaXNFbmNyeXB0ZWQiLCJhdWRpb1RyYWNrIiwidmlkZW9UcmFjayIsInVwZGF0ZUluZm8iLCJzaW11bGNhc3RlZCIsIlN1YnNjcmlwdGlvblN0YXR1cyIsIlBlcm1pc3Npb25TdGF0dXMiLCJMb2NhbFRyYWNrUHVibGljYXRpb24iLCJ0aSIsImhhbmRsZVRyYWNrRW5kZWQiLCJxdWFsaXR5RnJvbVByb3RvIiwiRVhDRUxMRU5UIiwiRXhjZWxsZW50IiwiR09PRCIsIkdvb2QiLCJQb29yIiwiTE9TVCIsIkxvc3QiLCJQYXJ0aWNpcGFudCIsImlzQWdlbnQiLCJwZXJtaXNzaW9ucyIsImF1ZGlvTGV2ZWwiLCJpc1NwZWFraW5nIiwiX2Nvbm5lY3Rpb25RdWFsaXR5IiwiYXVkaW9UcmFja3MiLCJ2aWRlb1RyYWNrcyIsImdldFRyYWNrIiwiZ2V0VHJhY2tCeU5hbWUiLCJjb25uZWN0aW9uUXVhbGl0eSIsImlzQ2FtZXJhRW5hYmxlZCIsImlzTWljcm9waG9uZUVuYWJsZWQiLCJpc1NjcmVlblNoYXJlRW5hYmxlZCIsInBhcnRpY2lwYW50SW5mbyIsIl9zZXROYW1lIiwiX3NldE1ldGFkYXRhIiwicGVybWlzc2lvbiIsInNldFBlcm1pc3Npb25zIiwibWQiLCJjaGFuZ2VkIiwicHJldk1ldGFkYXRhIiwiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQiLCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwicHJldlBlcm1pc3Npb25zIiwiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQiLCJzZXRJc1NwZWFraW5nIiwic3BlYWtpbmciLCJsYXN0U3Bva2VBdCIsIklzU3BlYWtpbmdDaGFuZ2VkIiwic2V0Q29ubmVjdGlvblF1YWxpdHkiLCJwcmV2UXVhbGl0eSIsIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsImFkZFRyYWNrUHVibGljYXRpb24iLCJUcmFja011dGVkIiwiVHJhY2tVbm11dGVkIiwidHJhY2tQZXJtaXNzaW9uVG9Qcm90byIsInBlcm1zIiwiYWxsb3dBbGwiLCJhbGxvd2VkVHJhY2tTaWRzIiwiUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiIsImN1cnJlbnRWaWRlb1F1YWxpdHkiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiZW1pdFRyYWNrVXBkYXRlIiwiaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlIiwidmlkZW9EaW1lbnNpb25zIiwic3Vic2NyaWJlZCIsInNldFN1YnNjcmliZWQiLCJwcmV2U3RhdHVzIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwicHJldlBlcm1pc3Npb24iLCJwZXJtaXNzaW9uU3RhdHVzIiwiZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZCIsImVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkIiwiVW5zdWJzY3JpYmVkIiwiRGVzaXJlZCIsIlN1YnNjcmliZWQiLCJBbGxvd2VkIiwiTm90QWxsb3dlZCIsInNldEVuYWJsZWQiLCJpc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQiLCJzZXRWaWRlb1F1YWxpdHkiLCJzZXRWaWRlb0RpbWVuc2lvbnMiLCJzZXRWaWRlb0ZQUyIsInZpZGVvUXVhbGl0eSIsInByZXZUcmFjayIsInNldEFsbG93ZWQiLCJzZXRTdWJzY3JpcHRpb25FcnJvciIsIlN1YnNjcmlwdGlvbkZhaWxlZCIsInByZXZNZXRhZGF0YU11dGVkIiwicHJldmlvdXNTdGF0dXMiLCJjdXJyZW50U3RhdHVzIiwiU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCIsInByZXZpb3VzUGVybWlzc2lvblN0YXR1cyIsImN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQiLCJVcGRhdGVTZXR0aW5ncyIsIlJlbW90ZVBhcnRpY2lwYW50IiwiZnJvbVBhcnRpY2lwYW50SW5mbyIsInBpIiwidm9sdW1lTWFwIiwiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCIsIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCIsInByZXZpb3VzVHJhY2siLCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZCIsImF1ZGlvUHVibGljYXRpb24iLCJhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayIsInRyaWVzTGVmdCIsImdldFRyYWNrUHVibGljYXRpb24iLCJpc1ZpZGVvIiwiaGFzTWV0YWRhdGEiLCJ2YWxpZFRyYWNrcyIsIm5ld1RyYWNrcyIsImV4aXN0aW5nVHJhY2tPZlNvdXJjZSIsInB1Ymxpc2hlZFRyYWNrIiwib2xkVHJhY2siLCJ1bnB1Ymxpc2hUcmFjayIsInNlbmRVbnB1Ymxpc2giLCJUcmFja1VucHVibGlzaGVkIiwic2V0QXVkaW9PdXRwdXQiLCJwcm9taXNlcyIsIkxvY2FsUGFydGljaXBhbnQiLCJwZW5kaW5nUHVibGlzaGluZyIsInBlbmRpbmdQdWJsaXNoUHJvbWlzZXMiLCJwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMiLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUiLCJlbmNyeXB0aW9uVHlwZSIsImhhbmRsZVJlY29ubmVjdGluZyIsInJlY29ubmVjdEZ1dHVyZSIsImhhbmRsZVJlY29ubmVjdGVkIiwidXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsImhhbmRsZURpc2Nvbm5lY3RlZCIsImFsbFBhcnRpY2lwYW50c0FsbG93ZWQiLCJvblRyYWNrVW5tdXRlZCIsIm9uVHJhY2tNdXRlZCIsIm9uVHJhY2tVcHN0cmVhbVBhdXNlZCIsIm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQiLCJoYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsInJvb21PcHRpb25zIiwibmV3Q29kZWNzXzEiLCJuZXdDb2RlY3NfMV8xIiwicHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrIiwiaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkIiwidW5wdWJsaXNoZWQiLCJjdXJyZW50UGVybWlzc2lvbnMiLCJxdWVyeSIsIm9uY2hhbmdlIiwiYWN0aXZlRGV2aWNlTWFwIiwibGFzdENhbWVyYUVycm9yIiwiY2FtZXJhRXJyb3IiLCJsYXN0TWljcm9waG9uZUVycm9yIiwibWljcm9waG9uZUVycm9yIiwiTG9jYWxUcmFja1VucHVibGlzaGVkIiwic2V0TWV0YWRhdGEiLCJzZXROYW1lIiwic2V0Q2FtZXJhRW5hYmxlZCIsInB1Ymxpc2hPcHRpb25zIiwic2V0VHJhY2tFbmFibGVkIiwic2V0TWljcm9waG9uZUVuYWJsZWQiLCJzZXRTY3JlZW5TaGFyZUVuYWJsZWQiLCJzZXRFMkVFRW5hYmxlZCIsIkdDTSIsInJlcHVibGlzaEFsbFRyYWNrcyIsImFkZCIsImNyZWF0ZVRyYWNrcyIsImNyZWF0ZVNjcmVlblRyYWNrcyIsInB1Ymxpc2hQcm9taXNlcyIsImxvY2FsVHJhY2siLCJwdWJsaXNoVHJhY2siLCJwdWJsaXNoZWRUcmFja3MiLCJNZWRpYURldmljZXNFcnJvciIsInNjcmVlbkF1ZGlvVHJhY2siLCJlbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lIiwiYXVkaW9DYXB0dXJlRGVmYXVsdHMiLCJ2aWRlb0NhcHR1cmVEZWZhdWx0cyIsIkF1ZGlvU3RyZWFtQWNxdWlyZWQiLCJpc0F1ZGlvIiwidHJhY2tDb25zdHJhaW50cyIsImNvbk9yQm9vbCIsInNjcmVlblZpZGVvIiwic2NyZWVuQXVkaW8iLCJkZWZhdWx0Q29uc3RyYWludHMiLCJkZXZpY2VLaW5kIiwiZXhpc3RpbmdQdWJsaWNhdGlvbiIsImlzU3RlcmVvSW5wdXQiLCJjaGFubmVsQ291bnQiLCJpc1N0ZXJlbyIsImUyZWUiLCJwdWJsaXNoUHJvbWlzZSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX28iLCJkZWZhdWx0UmVzIiwicHJpbWFyeUNvZGVjTWltZSIsInVwZGF0ZWRDb2RlYyIsInRyYWNrVHJhbnNjZWl2ZXIiLCJzdG9wT25VbnB1Ymxpc2giLCJnZXRQdWJsaWNhdGlvbkZvclRyYWNrIiwibmVnb3RpYXRpb25OZWVkZWQiLCJ0cmFja1NlbmRlciIsImNsZWFyIiwidW5wdWJsaXNoVHJhY2tzIiwicmVzdGFydFRyYWNrcyIsImxvY2FsUHVicyIsInB1Ymxpc2hEYXRhIiwidG9waWMiLCJzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwibXV0ZWRPblNlcnZlciIsImNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kiLCJSb29tU3RhdGUiLCJfdGhpcyIsImFjdGl2ZVNwZWFrZXJzIiwiYXVkaW9FbmFibGVkIiwiaXNWaWRlb1BsYXliYWNrQmxvY2tlZCIsInVubG9ja0Rpc2Nvbm5lY3QiLCJkaXNjb25uZWN0TG9jayIsImNvbm5lY3RGdXR1cmUiLCJzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGluZyIsImNvbm5lY3RGbiIsImF0dGVtcHRDb25uZWN0aW9uIiwibmV4dFVybCIsImNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMiLCJjb25uZWN0U2lnbmFsIiwiZTJlZU1hbmFnZXIiLCJzZXJ2ZXJJbmZvIiwiYXBwbHlKb2luUmVzcG9uc2UiLCJoYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMiLCJoYW5kbGVSb29tVXBkYXRlIiwicmVjcmVhdGVFbmdpbmUiLCJtYXliZUNyZWF0ZUVuZ2luZSIsImFjcXVpcmVBdWRpb0NvbnRleHQiLCJjb25uT3B0aW9ucyIsInNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cyIsInJlc3VsdGluZ0Vycm9yIiwib25QYWdlTGVhdmUiLCJoYW5kbGVEZXZpY2VDaGFuZ2UiLCJyZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUiLCJzdG9wVHJhY2tzIiwic3RhcnRBdWRpbyIsImVsZW1lbnRzIiwiYXVkaW9JZCIsImR1bW15QXVkaW9FbCIsImdldEVsZW1lbnRCeUlkIiwiYm9keSIsImFwcGVuZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkIiwiaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCIsInN0YXJ0VmlkZW8iLCJoYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQiLCJoYW5kbGVSZXN0YXJ0aW5nIiwiY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlIiwiaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJoYW5kbGVTaWduYWxSZXN0YXJ0ZWQiLCJjYWNoZWRQYXJ0aWNpcGFudFNpZHMiLCJSZWNvbm5lY3RlZCIsIlBhcnRpY2lwYW50Q29ubmVjdGVkIiwicGFydGljaXBhbnRJbmZvcyIsImlkZW50aXR5VG9TaWQiLCJyZW1vdGVQYXJ0aWNpcGFudCIsImlzTmV3UGFydGljaXBhbnQiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJlbWl0V2hlbkNvbm5lY3RlZCIsIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCIsImhhbmRsZVNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJVcGRhdGVzIiwibGFzdFNwZWFrZXJzIiwiaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZVVwZGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlRGF0YVBhY2tldCIsInVzZXJQYWNrZXQiLCJEYXRhUmVjZWl2ZWQiLCJjYW5QbGF5YmFja0F1ZGlvIiwiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQiLCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIk1lZGlhRGV2aWNlc0NoYW5nZWQiLCJvbGRSb29tIiwicm9vbUluZm8iLCJSb29tTWV0YWRhdGFDaGFuZ2VkIiwiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCIsImhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwib25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwib25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQiLCJvbkxvY2FsVHJhY2tNdXRlZCIsIm9uTG9jYWxUcmFja1VubXV0ZWQiLCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIiwiQWN0aXZlRGV2aWNlQ2hhbmdlZCIsIm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJvbk1lZGlhRGV2aWNlc0Vycm9yIiwib25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic3dpdGNoQWN0aXZlRGV2aWNlIiwic2V0dXBFMkVFIiwiaXNSZWNvcmRpbmciLCJvblRyYWNrQWRkZWQiLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwiZGlmZlBhcnRpY2lwYW50cyIsImdldExvY2FsRGV2aWNlcyIsInByZXBhcmVDb25uZWN0aW9uIiwic2ltdWxhdGVTY2VuYXJpbyIsInBvc3RBY3Rpb24iLCJjYW5QbGF5YmFja1ZpZGVvIiwiZ2V0QWN0aXZlQXVkaW9PdXRwdXREZXZpY2UiLCJnZXRBY3RpdmVEZXZpY2UiLCJzdWNjZXNzIiwiZGV2aWNlQ29uc3RyYWludCIsInByZXZEZXZpY2VJZCIsInJlY29ubmVjdGVkSGFuZGxlciIsInNob3VsZFN0b3BUcmFja3MiLCJQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCIsIm5ld0NvbnRleHRJc1J1bm5pbmciLCJjcmVhdGVQYXJ0aWNpcGFudCIsInRyYWNrUHVibGljYXRpb24iLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJTVEFURV9NSVNNQVRDSCIsInNpbXVsYXRlUGFydGljaXBhbnRzIiwidXNlUmVhbFRyYWNrcyIsInBhcnRpY2lwYW50T3B0aW9ucyIsImFzcGVjdFJhdGlvcyIsImNhbVB1YiIsImF1ZGlvUHViIiwiZHVtbXlWaWRlbyIsIl9sZW4yIiwiX2tleTIiLCJDaGVja1N0YXR1cyIsIkNoZWNrZXIiLCJJRExFIiwibG9ncyIsImVycm9yc0FzV2FybmluZ3MiLCJvbkNvbXBsZXRlIiwic2V0U3RhdHVzIiwicGVyZm9ybSIsImFwcGVuZFdhcm5pbmciLCJhcHBlbmRFcnJvciIsIlNLSVBQRUQiLCJpc1N1Y2Nlc3MiLCJTVUNDRVNTIiwiYXBwZW5kTWVzc2FnZSIsImNyZWF0ZUxvY2FsVHJhY2tzIiwibWVkaWFQcm9taXNlIiwiY3JlYXRlTG9jYWxWaWRlb1RyYWNrIiwiY3JlYXRlTG9jYWxBdWRpb1RyYWNrIiwiY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MiLCJQdWJsaXNoQXVkaW9DaGVjayIsIm51bVBhY2tldHMiLCJtZWRpYVR5cGUiLCJQdWJsaXNoVmlkZW9DaGVjayIsIlJlY29ubmVjdENoZWNrIiwicmVjb25uZWN0aW5nVHJpZ2dlcmVkIiwicmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RSZXNvbHZlciIsIlRVUk5DaGVjayIsImpvaW5SZXMiLCJoYXNUTFMiLCJoYXNUVVJOIiwiaGFzU1RVTiIsIldlYlJUQ0NoZWNrIiwiaGFzVGNwIiwiaGFzSXB2NFVkcCIsInByZXZUcmlja2xlIiwiaXNJUFByaXZhdGUiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJzZWNvbmQiLCJXZWJTb2NrZXRDaGVjayIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiZGVmYXVsdEZhY2luZ01vZGUiLCJjb25maWRlbmNlIiwicmF3RmFjaW5nTW9kZSIsImlzRmFjaW5nTW9kZVZhbHVlIiwibGFiZWxBbmFseXNpc1Jlc3VsdCIsImZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwiLCJrbm93bkRldmljZUxhYmVscyIsImtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyIsImRldmljZUxhYmVsIiwic2VjdGlvbiIsImFsbG93ZWRWYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;